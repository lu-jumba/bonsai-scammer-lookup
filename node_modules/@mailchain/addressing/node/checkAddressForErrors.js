'use strict';

var errors = require('./errors.js');
var address$3 = require('./protocols/ethereum/address.js');
var address$2 = require('./protocols/near/address.js');
var address$1 = require('./protocols/tezos/address.js');
var address = require('./protocols/filecoin/address.js');
var consts = require('./protocols/consts.js');

const DEFAULT_MAILCHAIN_DOMAIN = 'mailchain.com';
/**
 * Performs offline checks to see if an address is invalid. Even if there is no error addresses need to be resolved to be sure they are valid.
 *
 * @param address fully qualified address to check
 * @param mailchainDomain
 * @returns an error if it's invalid or undefined if validation passes.
 */
function checkAddressForErrors(address, mailchainDomain = DEFAULT_MAILCHAIN_DOMAIN) {
    address = address.trim();
    if (!address.endsWith(`${mailchainDomain}`)) {
        return new errors.BadlyFormattedAddressError();
    }
    const parts = address.split('@');
    if (parts.length !== 2) {
        return new errors.BadlyFormattedAddressError();
    }
    const local = parts[0];
    const domain = parts[1];
    const domainParts = parts[1].split('.');
    if (domain === DEFAULT_MAILCHAIN_DOMAIN) {
        return validateMailchainProtocolAddress(local);
    }
    else if (domainParts.length === 3) {
        return validateIdentityProviderAddress(local, domainParts[0]);
    }
    // At this point there are no errors but we don't know if the address is valid, it needs to be resolved
    return undefined;
}
function validateMailchainProtocolAddress(tldTrimmedAddress) {
    const mailchainAddressPattern = /^[a-zA-Z0-9-_]{2,20}$/;
    if (!mailchainAddressPattern.test(tldTrimmedAddress)) {
        // check mailchain protocol address
        return new errors.IdentityProviderAddressInvalidError();
    }
    return undefined;
}
function validateIdentityProviderAddress(address$4, identityProvider) {
    switch (identityProvider) {
        case consts.ETHEREUM:
            if (!address$3.validateEthereumAddress(address$4)) {
                return new errors.IdentityProviderAddressInvalidError();
            }
            break;
        case consts.NEAR:
            if (!address$2.validateNearAccountId(address$4)) {
                return new errors.IdentityProviderAddressInvalidError();
            }
            break;
        case consts.TEZOS:
            if (!address$1.validateTezosAddress(address$4)) {
                return new errors.IdentityProviderAddressInvalidError();
            }
            break;
        case consts.FILECOIN:
            if (!address.validateFilecoinAddress(address$4)) {
                return new errors.IdentityProviderAddressInvalidError();
            }
            break;
    }
    // couldn't find the identity provider or it passed validation.
    // doesn't mean it's valid but it didn't fail offline validation
    return undefined;
}

exports.checkAddressForErrors = checkAddressForErrors;
