'use strict';

var encoding = require('@mailchain/encoding');
var base32 = require('@mailchain/encoding/base32');
var blake2b = require('@noble/hashes/blake2b');
var isEqual = require('lodash/isEqual');
var types = require('./types.js');

const MIN_FIL_ADDRESS_STR_LENGTH = 6;
const MAX_FIL_ADDRESS_STR_LENGTH = 115;
const MAINNET_PREFIX = 'f';
const CALIBRATION_PREFIX = 't';
const ETHEREUM_NAMESPACE = 10;
const ETHEREUM_ADDRESS_LENGTH = 20;
const CHECKSUM_LENGTH = 4;
function convertFilDelegatedAddressToEthAddress(fileCoinAddress) {
    const filAddress = fileCoinAddress.toLowerCase();
    //check prefix and length of initial address
    if (!(filAddress.startsWith(MAINNET_PREFIX) || filAddress.startsWith(CALIBRATION_PREFIX))) {
        return {
            error: new Error(`invalid Filecoin address, should start with '${MAINNET_PREFIX}' or '${CALIBRATION_PREFIX}'`),
        };
    }
    if (filAddress.length < MIN_FIL_ADDRESS_STR_LENGTH || filAddress.length > MAX_FIL_ADDRESS_STR_LENGTH) {
        return { error: new Error('invalid address length') };
    }
    //split address in namespace and sub address
    const raw = filAddress.slice(2);
    const namespaceStr = raw.slice(0, raw.indexOf('f'));
    const encodedSubAddress = raw.slice(raw.indexOf('f') + 1);
    //check namespace
    const namespace = parseInt(namespaceStr, 10);
    if (namespace !== ETHEREUM_NAMESPACE) {
        return {
            error: new Error(`invalid namespace, supported only Ethereum Address Manager {${ETHEREUM_NAMESPACE}}`),
        };
    }
    //decode base 32 the address + checksum
    const subAddress = base32.decodeBase32(encodedSubAddress);
    if (subAddress.length < ETHEREUM_ADDRESS_LENGTH + CHECKSUM_LENGTH) {
        return { error: new Error('invalid subAddress length') };
    }
    //separate address and checksum
    const ethAddress = subAddress.slice(0, ETHEREUM_ADDRESS_LENGTH);
    const checksum = subAddress.slice(ETHEREUM_ADDRESS_LENGTH);
    if (ethAddress.length !== ETHEREUM_ADDRESS_LENGTH) {
        return { error: new Error('invalid Ethereum address length') };
    }
    //get checksum payload and validate it
    if (!validateChecksum(types.FilecoinAddressType.DELEGATED, namespace, ethAddress, checksum)) {
        return { error: new Error('invalid address checksum') };
    }
    return { data: ethAddress };
}
function convertEthAddressToFilDelegated(ethereumAddress, prefix = MAINNET_PREFIX) {
    if (ethereumAddress.length != ETHEREUM_ADDRESS_LENGTH) {
        throw new Error('invalid Ethereum address length');
    }
    const checksum = computeAddressChecksum(types.FilecoinAddressType.DELEGATED, ETHEREUM_NAMESPACE, ethereumAddress);
    const subAddress = new Uint8Array(ethereumAddress.length + checksum.length);
    subAddress.set(ethereumAddress, 0);
    subAddress.set(checksum, ethereumAddress.length);
    const encodedSubAddr = base32.encodeBase32(subAddress);
    const filAddress = `${prefix}${types.FilecoinAddressType.DELEGATED}${ETHEREUM_NAMESPACE}f${encodedSubAddr}`;
    return encoding.decodeUtf8(filAddress);
}
function validateChecksum(addressType, namespace, address, checksum) {
    const digest = computeAddressChecksum(addressType, namespace, address);
    return isEqual(digest, checksum);
}
function computeAddressChecksum(addressType, namespace, address) {
    const namespaceBytes = numberToUInt8Array(namespace);
    const payload = new Uint8Array(1 + namespaceBytes.length + address.length);
    payload.set(new Uint8Array([addressType]), 0);
    payload.set(namespaceBytes, 1);
    payload.set(address, 1 + namespaceBytes.length);
    return blake2b.blake2b(payload, { dkLen: CHECKSUM_LENGTH });
}
/** Convert potentially large number to a byte array */
function numberToUInt8Array(num) {
    if (num === 0)
        return new Uint8Array([0]);
    const res = [];
    res.unshift(num & 255);
    while (num >= 256) {
        num = num >>> 8;
        res.unshift(num & 255);
    }
    return new Uint8Array(res);
}

exports.CALIBRATION_PREFIX = CALIBRATION_PREFIX;
exports.MAINNET_PREFIX = MAINNET_PREFIX;
exports.convertEthAddressToFilDelegated = convertEthAddressToFilDelegated;
exports.convertFilDelegatedAddressToEthAddress = convertFilDelegatedAddressToEthAddress;
