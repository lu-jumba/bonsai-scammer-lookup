'use strict';

var crypto = require('@mailchain/crypto');
var sha256 = require('@noble/hashes/sha256');
var blake2b = require('@noble/hashes/blake2b');
var encoding = require('@mailchain/encoding');
var _const = require('./const.js');

/**
 * Derive the tezos address corresponding to the {@link PublicKey}.
 *
 * @param publicKey must be either a key of {@link KindSECP256K1} or {@link KindED25519} or {@link KindSECP256R1}.
 * @throw if the provided key is on unsupported curve
 */
function tezosAddressFromPublicKey(publicKey) {
    let prefixArray;
    switch (publicKey.curve) {
        case crypto.KindSECP256K1:
            prefixArray = _const.prefix.tz2;
            break;
        case crypto.KindED25519:
            prefixArray = _const.prefix.tz1;
            break;
        case crypto.KindSECP256R1:
            prefixArray = _const.prefix.tz3;
            break;
        default:
            throw new Error(`public key curve not supported`);
    }
    return composeAddress(publicKey.bytes, prefixArray);
}
function checksum(input) {
    const h = sha256.sha256(input);
    const h2 = sha256.sha256(h);
    return h2.slice(0, 4);
}
function hash(pkBytes) {
    return blake2b.blake2b(pkBytes, { dkLen: 160 / 8 });
}
function composeAddress(key, prefixArray) {
    const h = hash(key);
    const result = new Uint8Array(27);
    result.set(prefixArray, 0);
    result.set(h, 3);
    result.set(checksum(result.slice(0, 23)), 23);
    return result;
}
function validateTezosAddress(address) {
    if (address.length !== 36) {
        return false;
    }
    else if (address.slice(0, 3) !== _const.Prefix.TZ1 &&
        address.slice(0, 3) !== _const.Prefix.TZ2 &&
        address.slice(0, 3) !== _const.Prefix.TZ3) {
        return false;
    }
    else if (!encoding.isBase58(address)) {
        return false;
    }
    const decoded = encoding.decodeBase58(address);
    const addressChecksum = checksum(decoded.slice(0, 23));
    if (decoded.slice(-4).toString() !== addressChecksum.toString()) {
        return false;
    }
    return true;
}

exports.tezosAddressFromPublicKey = tezosAddressFromPublicKey;
exports.validateTezosAddress = validateTezosAddress;
