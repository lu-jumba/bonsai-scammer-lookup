'use strict';

var addressPredicates = require('./addressPredicates.js');
var encoding = require('./encoding.js');
var formatMailLike = require('./formatMailLike.js');
var matchesNameservice = require('./nameservices/matchesNameservice.js');
var nameserviceDescriptions = require('./nameservices/nameserviceDescriptions.js');
var parseWalletAddress = require('./parseWalletAddress.js');
var consts = require('./protocols/consts.js');

/**
 * alice@mailchian.com
 */
const humanMailchainAccount = (address) => {
    if (addressPredicates.isMailchainAccountAddress(address)) {
        const domainParts = address.domain.split('.');
        return formatMailLike.formatMailLike(address.username, domainParts[0]);
    }
    return undefined;
};
const humanNearAddress = (address) => {
    const props = parseWalletAddress.parseWalletAddress(address);
    if (props == null || props.protocol !== consts.NEAR)
        return;
    const usernameParts = address.username.split('.');
    if (usernameParts.length == 1 &&
        addressPredicates.isNearImplicitAccount({
            domain: address.domain,
            username: usernameParts[0],
        })) {
        return formatMailLike.formatMailLike([`${usernameParts[0].slice(0, 6)}...${usernameParts[0].slice(-4)}`, ...usernameParts.slice(1)].join('.'), props.protocol);
    }
    else if (usernameParts.length >= 2 &&
        addressPredicates.isNearImplicitAccount({
            domain: address.domain,
            username: usernameParts[0],
        }) &&
        usernameParts[usernameParts.length - 1] !== 'near') {
        // testnet or local implicit accounts
        return formatMailLike.formatMailLike([`${usernameParts[0].slice(0, 6)}...${usernameParts[0].slice(-4)}`, ...usernameParts.slice(1)].join('.'), props.protocol);
    }
    else if (usernameParts.length >= 2 && usernameParts[usernameParts.length - 1] !== 'near') {
        // testnet or local named accounts
        return formatMailLike.formatMailLike(address.username, props.protocol);
    }
    return address.username;
};
const humanTezosAddress = (address) => {
    if (!addressPredicates.isTezosAddress(address))
        return undefined;
    return formatMailLike.formatMailLike(`${address.username.slice(0, 7)}...${address.username.slice(-4)}`, consts.TEZOS);
};
/**
 * `0xdDfFC3003797e44FCd103eE7A4aE78Ed02853A55@ethereum.mailchain.com` into `0xdDfFC...3A55@ethereum`
 */
const humanWalletAddress = (address) => {
    const domainParts = address.domain.split('.');
    if (domainParts.length <= 2)
        return undefined;
    if (addressPredicates.isEthereumAddress(address)) {
        return formatMailLike.formatMailLike(`${address.username.slice(0, 6)}...${address.username.slice(-4)}`, consts.ETHEREUM);
    }
    // TODO: since other addresses except ethereum not support, very basic support for them
    const props = parseWalletAddress.parseWalletAddress(address);
    if (props == null)
        return undefined;
    try {
        // native test by trying to decode username
        encoding.decodeAddressByProtocol(address.username, props.protocol);
        return formatMailLike.formatMailLike(`${address.username.slice(0, 4)}...${address.username.slice(-4)}`, props.protocol);
    }
    catch (e) {
        return undefined;
    }
};
/**
 * Address with matching NS description `alice.eth@ens.mailchain.com` into `alice.eth`
 */
const humanNsAddress = (address) => {
    for (const desc of nameserviceDescriptions.NAMESERVICE_DESCRIPTIONS) {
        const matchingNsDomain = matchesNameservice.matchesNameservice(address, desc);
        if (matchingNsDomain) {
            return address.username;
        }
    }
    return undefined;
};
/** If the other formatting rules fail, apply this generic one */
const humanCatchAll = (address) => {
    const domainParts = address.domain.split('.');
    if (domainParts.length === 2) {
        return formatMailLike.formatMailLike(address.username, domainParts[0]);
    }
    else if (domainParts.length > 2) {
        const domainPartsToInclude = domainParts.slice(0, -2); // drop the last two
        return formatMailLike.formatMailLike(address.username, ...domainPartsToInclude);
    }
    return formatMailLike.formatMailLike(address.username, address.domain);
};
const humanNameServiceFormatters = [
    humanMailchainAccount,
    humanNearAddress,
    humanTezosAddress,
    humanWalletAddress,
    humanNsAddress,
    humanCatchAll,
];

exports.humanNameServiceFormatters = humanNameServiceFormatters;
