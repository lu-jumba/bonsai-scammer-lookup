'use strict';

var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');
var blake2b = require('@noble/hashes/blake2b');

async function verifyTezosSignedMessage(key, msg, signature) {
    const messagePayload = createTezosSignedMessagePayload(msg);
    const bytesHash = blake2b.blake2b(messagePayload, { dkLen: 256 / 8 });
    switch (key.curve) {
        case crypto.KindED25519:
        case crypto.KindSECP256R1:
        case crypto.KindSECP256K1:
            return key.verify(bytesHash, signature);
        default:
            throw new crypto.ErrorUnsupportedKey(key.curve);
    }
}
function createTezosSignedMessagePayload(msg) {
    return formatAsTezosMicheline(encoding.decodeUtf8(`Tezos Signed Message: ${msg}`));
}
function formatAsTezosMicheline(payload) {
    const bytesLength = payload.length.toString(16);
    const addPadding = `00000000${bytesLength}`;
    const paddedBytesLength = addPadding.slice(addPadding.length - 8);
    return encoding.decodeHex('0501' + paddedBytesLength + encoding.encodeHex(payload));
}

exports.createTezosSignedMessagePayload = createTezosSignedMessagePayload;
exports.verifyTezosSignedMessage = verifyTezosSignedMessage;
