'use strict';

var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');
var canonicalize = require('canonicalize');
var raw_ed25519 = require('./raw_ed25519.js');

function createMailerProofSigningData(mailerProofParams, version) {
    switch (version) {
        case '1.0':
            const canonicalized = canonicalize({
                authorContentSignature: encoding.encodeHex(mailerProofParams.authorContentSignature),
                expires: Math.round(mailerProofParams.expires.getTime() / 1000),
                mailerMessagingKey: encoding.encodeHex(crypto.publicKeyToBytes(mailerProofParams.mailerMessagingKey)),
            });
            if (!canonicalized) {
                throw new Error('content could not be canonicalized');
            }
            return canonicalized;
        default:
            throw new Error(`version ${version} is not supported`);
    }
}
async function signMailerProofParams(author, mailerProofParams, version) {
    return raw_ed25519.signRawEd25519(author, encoding.decodeUtf8(createMailerProofSigningData(mailerProofParams, version)));
}
async function createMailerProof(author, mailerProofParams, version) {
    const signature = await signMailerProofParams(author, mailerProofParams, version);
    return {
        params: mailerProofParams,
        signature,
        version,
    };
}
async function verifyMailerProof(author, mailerProof) {
    return raw_ed25519.verifyRawEd25519(author, Buffer.from(createMailerProofSigningData(mailerProof.params, mailerProof.version)), mailerProof.signature);
}

exports.createMailerProof = createMailerProof;
exports.createMailerProofSigningData = createMailerProofSigningData;
exports.signMailerProofParams = signMailerProofParams;
exports.verifyMailerProof = verifyMailerProof;
