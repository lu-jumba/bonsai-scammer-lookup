'use strict';

var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');
var isEqual = require('lodash/isEqual');
var addressing = require('@mailchain/addressing');
var eth_personal = require('../eth_personal.js');

/**
 * Gets the public key from signature and compares it to the expected address to validate it's correct.
 *
 * The public key that {@link SECP256K1PublicKey.fromSignature} returns will verify the message with the signature.
 * However it's not guaranteed that the returned public key will be for the expected address.
 * @param message the message being signed
 * @param signature the signature of the message made with the private key part of the public key we are trying to extract
 */
async function ethereumPublicKeyFromSignature(message, signature, expectedAddress) {
    const messageHash = await eth_personal.getMessageHash(message);
    const publicKey = await crypto.SECP256K1PublicKey.fromSignature(messageHash, signature);
    const address = await addressing.addressFromPublicKey(publicKey, addressing.ETHEREUM);
    if (!isEqual(address, expectedAddress)) {
        throw new Error(`inconsistent public key calculated, expected address "${encoding.encodeHex(expectedAddress)}" but actual is "${encoding.encodeHex(address)} (both hex encoded)"`);
    }
    return publicKey;
}

exports.ethereumPublicKeyFromSignature = ethereumPublicKeyFromSignature;
