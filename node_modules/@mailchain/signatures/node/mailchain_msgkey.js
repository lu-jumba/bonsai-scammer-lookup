'use strict';

var encoding = require('@mailchain/encoding');
var crypto = require('@mailchain/crypto');
var errors = require('./errors.js');

function mailchainProvidedMessagingKeyMessage(msgKey, address, protocol) {
    if (address.length === 0)
        throw new errors.AddressIsEmptyError();
    if (protocol.length === 0)
        throw new errors.ProtocolIsEmptyError();
    if (address.includes('@')) {
        throw new errors.AddressMustBeProtocolAddressError();
    }
    switch (msgKey.curve) {
        case crypto.KindED25519:
            const encodedKey = encoding.encodeHexZeroX(crypto.publicKeyToBytes(msgKey));
            return new Uint8Array(Buffer.from(`\x11Mailchain provided messaging key:\nAddress:${address}\nProtocol:${protocol}\nKey:${encodedKey}`));
        default:
            throw new crypto.ErrorUnsupportedKey(msgKey.curve);
    }
}
function signMailchainProvidedMessagingKey(key, msgKey, address, protocol) {
    switch (key.curve) {
        case crypto.KindED25519:
            const msg = mailchainProvidedMessagingKeyMessage(msgKey, address, protocol);
            return key.sign(msg);
        default:
            throw new crypto.ErrorUnsupportedKey(key.curve);
    }
}
function verifyMailchainProvidedMessagingKey(key, msgKey, signature, address, protocol) {
    switch (key.curve) {
        case crypto.KindED25519:
            const msg = mailchainProvidedMessagingKeyMessage(msgKey, address, protocol);
            return key.verify(msg, signature);
        default:
            throw new crypto.ErrorUnsupportedKey(key.curve);
    }
}

exports.mailchainProvidedMessagingKeyMessage = mailchainProvidedMessagingKeyMessage;
exports.signMailchainProvidedMessagingKey = signMailchainProvidedMessagingKey;
exports.verifyMailchainProvidedMessagingKey = verifyMailchainProvidedMessagingKey;
