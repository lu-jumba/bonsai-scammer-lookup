'use strict';

var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');

async function verifyEthereumPersonalMessage(key, message, signature) {
    switch (key.curve) {
        case crypto.KindSECP256K1:
            const messageHash = await getMessageHash(message);
            return key.verify(messageHash, signature);
        default:
            throw new crypto.ErrorUnsupportedKey(key.curve);
    }
}
async function signEthereumPersonalMessage(key, message) {
    switch (key.curve) {
        case crypto.KindSECP256K1:
            const messageHash = await getMessageHash(message);
            return key.sign(messageHash);
        default:
            throw new crypto.ErrorUnsupportedKey(key.curve);
    }
}
async function getMessageHash(message) {
    const { hashMessage } = await import('@ethersproject/hash');
    return encoding.decodeHexZeroX(hashMessage(message));
}

exports.getMessageHash = getMessageHash;
exports.signEthereumPersonalMessage = signEthereumPersonalMessage;
exports.verifyEthereumPersonalMessage = verifyEthereumPersonalMessage;
