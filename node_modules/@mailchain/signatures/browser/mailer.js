import { publicKeyToBytes } from '@mailchain/crypto';
import { encodeHex, decodeUtf8 } from '@mailchain/encoding';
import canonicalize from 'canonicalize';
import { signRawEd25519, verifyRawEd25519 } from './raw_ed25519.js';

function createMailerProofSigningData(mailerProofParams, version) {
    switch (version) {
        case '1.0':
            const canonicalized = canonicalize({
                authorContentSignature: encodeHex(mailerProofParams.authorContentSignature),
                expires: Math.round(mailerProofParams.expires.getTime() / 1000),
                mailerMessagingKey: encodeHex(publicKeyToBytes(mailerProofParams.mailerMessagingKey)),
            });
            if (!canonicalized) {
                throw new Error('content could not be canonicalized');
            }
            return canonicalized;
        default:
            throw new Error(`version ${version} is not supported`);
    }
}
async function signMailerProofParams(author, mailerProofParams, version) {
    return signRawEd25519(author, decodeUtf8(createMailerProofSigningData(mailerProofParams, version)));
}
async function createMailerProof(author, mailerProofParams, version) {
    const signature = await signMailerProofParams(author, mailerProofParams, version);
    return {
        params: mailerProofParams,
        signature,
        version,
    };
}
async function verifyMailerProof(author, mailerProof) {
    return verifyRawEd25519(author, Buffer.from(createMailerProofSigningData(mailerProof.params, mailerProof.version)), mailerProof.signature);
}

export { createMailerProof, createMailerProofSigningData, signMailerProofParams, verifyMailerProof };
