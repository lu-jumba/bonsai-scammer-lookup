import { encodeHexZeroX } from '@mailchain/encoding';
import { ErrorUnsupportedKey, KindED25519, publicKeyToBytes } from '@mailchain/crypto';
import { AddressIsEmptyError, ProtocolIsEmptyError, AddressMustBeProtocolAddressError } from './errors.js';

function mailchainProvidedMessagingKeyMessage(msgKey, address, protocol) {
    if (address.length === 0)
        throw new AddressIsEmptyError();
    if (protocol.length === 0)
        throw new ProtocolIsEmptyError();
    if (address.includes('@')) {
        throw new AddressMustBeProtocolAddressError();
    }
    switch (msgKey.curve) {
        case KindED25519:
            const encodedKey = encodeHexZeroX(publicKeyToBytes(msgKey));
            return new Uint8Array(Buffer.from(`\x11Mailchain provided messaging key:\nAddress:${address}\nProtocol:${protocol}\nKey:${encodedKey}`));
        default:
            throw new ErrorUnsupportedKey(msgKey.curve);
    }
}
function signMailchainProvidedMessagingKey(key, msgKey, address, protocol) {
    switch (key.curve) {
        case KindED25519:
            const msg = mailchainProvidedMessagingKeyMessage(msgKey, address, protocol);
            return key.sign(msg);
        default:
            throw new ErrorUnsupportedKey(key.curve);
    }
}
function verifyMailchainProvidedMessagingKey(key, msgKey, signature, address, protocol) {
    switch (key.curve) {
        case KindED25519:
            const msg = mailchainProvidedMessagingKeyMessage(msgKey, address, protocol);
            return key.verify(msg, signature);
        default:
            throw new ErrorUnsupportedKey(key.curve);
    }
}

export { mailchainProvidedMessagingKeyMessage, signMailchainProvidedMessagingKey, verifyMailchainProvidedMessagingKey };
