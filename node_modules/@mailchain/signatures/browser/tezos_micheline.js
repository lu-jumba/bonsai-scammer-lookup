import { ErrorUnsupportedKey, KindSECP256K1, KindSECP256R1, KindED25519 } from '@mailchain/crypto';
import { decodeUtf8, decodeHex, encodeHex } from '@mailchain/encoding';
import { blake2b } from '@noble/hashes/blake2b';

async function verifyTezosSignedMessage(key, msg, signature) {
    const messagePayload = createTezosSignedMessagePayload(msg);
    const bytesHash = blake2b(messagePayload, { dkLen: 256 / 8 });
    switch (key.curve) {
        case KindED25519:
        case KindSECP256R1:
        case KindSECP256K1:
            return key.verify(bytesHash, signature);
        default:
            throw new ErrorUnsupportedKey(key.curve);
    }
}
function createTezosSignedMessagePayload(msg) {
    return formatAsTezosMicheline(decodeUtf8(`Tezos Signed Message: ${msg}`));
}
function formatAsTezosMicheline(payload) {
    const bytesLength = payload.length.toString(16);
    const addPadding = `00000000${bytesLength}`;
    const paddedBytesLength = addPadding.slice(addPadding.length - 8);
    return decodeHex('0501' + paddedBytesLength + encodeHex(payload));
}

export { createTezosSignedMessagePayload, verifyTezosSignedMessage };
