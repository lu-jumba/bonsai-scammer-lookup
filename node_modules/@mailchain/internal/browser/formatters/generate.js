import { publicKeyToBytes } from '@mailchain/crypto';
import { encodeHexZeroX } from '@mailchain/encoding';
import { createMessageComposer } from '@mailchain/message-composer';
import { X_IDENTITY_KEYS } from './consts.js';

const createMimeMessage = async (mailData, resolvedAddresses) => {
    const msg = createMessageComposer()
        .id(mailData.id)
        .date(mailData.date)
        .subject(mailData.subject)
        .from(mailData.from)
        .recipients('To', ...mailData.recipients)
        .recipients('Cc', ...mailData.carbonCopyRecipients)
        .recipients('Bcc', ...mailData.blindCarbonCopyRecipients)
        .message('html', Buffer.from(mailData.message))
        .message('plain', Buffer.from(mailData.plainTextMessage));
    const visibleIdentityKeyAddresses = [mailData.from, ...mailData.recipients, ...mailData.carbonCopyRecipients];
    if (mailData.replyTo) {
        msg.replyTo(mailData.replyTo);
        visibleIdentityKeyAddresses.push(mailData.replyTo);
    }
    const msgWithIdentityAttributes = addAllIdentityKeyAttr(msg, visibleIdentityKeyAddresses, mailData.blindCarbonCopyRecipients, resolvedAddresses);
    const builtMsg = await msgWithIdentityAttributes.build();
    return {
        original: builtMsg.forSender,
        visibleRecipients: builtMsg.forVisibleRecipients,
        blindRecipients: builtMsg.forBlindedRecipients.map(([recipient, content]) => ({
            recipient: { name: recipient.name, address: recipient.address },
            content,
        })),
    };
};
function addAllIdentityKeyAttr(msg, visibleIdentityKeyAddresses, blindCarbonCopyRecipients, resolvedAddresses) {
    const visibleIdentityKeyAttrs = [];
    // Add the X-IdentityKeys for the visible recipients
    for (const { address } of visibleIdentityKeyAddresses) {
        putIdentityKeyAttr(address, resolvedAddresses, visibleIdentityKeyAttrs);
    }
    if (visibleIdentityKeyAttrs.length > 0) {
        msg.customHeader(X_IDENTITY_KEYS, '', ['v', '1'], ...visibleIdentityKeyAttrs);
    }
    // Add the X-IdentityKeys for the blind recipients
    const allBlindIdentityKeyAttrs = [];
    for (const { address } of blindCarbonCopyRecipients) {
        const bccIdentityKeyAttrs = [...visibleIdentityKeyAttrs];
        const putAttr = putIdentityKeyAttr(address, resolvedAddresses, bccIdentityKeyAttrs);
        if (putAttr) {
            allBlindIdentityKeyAttrs.push(putAttr);
            msg.overrideBccHeader(address, X_IDENTITY_KEYS, '', ['v', '1'], ...bccIdentityKeyAttrs);
        }
    }
    // Add ALL (incl. bcc) the X-IdentityKeys for the sender
    if (allBlindIdentityKeyAttrs.length > 0) {
        msg.overrideSenderHeader(X_IDENTITY_KEYS, '', ['v', '1'], ...visibleIdentityKeyAttrs, ...allBlindIdentityKeyAttrs);
    }
    return msg;
}
function putIdentityKeyAttr(address, resolvedAddresses, attrs) {
    const lookupResult = resolvedAddresses.get(address);
    if (!lookupResult)
        return undefined;
    if (lookupResult.identityKey == null)
        return undefined;
    const { identityKey, protocol } = lookupResult;
    const attrValue = `${encodeHexZeroX(publicKeyToBytes(identityKey))}:${protocol}`;
    const attr = [address, attrValue];
    attrs.push(attr);
    return attr;
}

export { createMimeMessage };
