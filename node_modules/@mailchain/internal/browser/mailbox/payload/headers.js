import { parseMailerContentFromJSON, createContentBuffer } from '../../transport/mailer/content.js';
import { headersMapFromBuffers, parseSignatureHeader, parseOriginHeader, createSignatureHeader, createOriginHeader } from '../../transport/serialization/headers.js';

const HEADER_CONTENT_ENCODING = 'Content-Encoding';
const HEADER_CONTENT_ENCRYPTION = 'Content-Encryption';
const HEADER_CONTENT_LENGTH = 'Content-Length';
const HEADER_CONTENT_SIGNATURE = 'Content-Signature';
const HEADER_CONTENT_TYPE = 'Content-Type';
const HEADER_CREATED = 'Created';
const HEADER_ORIGIN = 'Origin';
const HEADER_MAILER_CONTENT = 'Mailer-Content';
class SerializableMailPayloadHeaders {
    constructor(headers) {
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.headers = headers;
    }
    static FromEncryptedMailPayloadHeaders(headers) {
        return new this(headers);
    }
    static FromBuffer(buffer) {
        const { headers } = headersMapFromBuffers(buffer, [
            HEADER_CONTENT_ENCODING,
            HEADER_CONTENT_ENCRYPTION,
            HEADER_CONTENT_LENGTH,
            HEADER_CONTENT_SIGNATURE,
            HEADER_CONTENT_TYPE,
            HEADER_CREATED,
            HEADER_ORIGIN,
        ]);
        const output = {
            ContentEncoding: headers.get(HEADER_CONTENT_ENCODING).toString(),
            ContentEncryption: headers.get(HEADER_CONTENT_ENCRYPTION).toString(),
            ContentLength: Number.parseInt(headers.get(HEADER_CONTENT_LENGTH).toString()),
            ContentSignature: parseSignatureHeader(headers.get(HEADER_CONTENT_SIGNATURE).toString()),
            ContentType: headers.get(HEADER_CONTENT_TYPE).toString(),
            Created: new Date(headers.get(HEADER_CREATED).toString()),
            Origin: parseOriginHeader(headers.get(HEADER_ORIGIN).toString()),
        };
        if (headers.get(HEADER_MAILER_CONTENT)) {
            output.MailerContent = parseMailerContentFromJSON(headers.get(HEADER_MAILER_CONTENT).toString());
        }
        return new this(output);
    }
    ToBuffer() {
        const headers = [];
        headers.push(`${HEADER_CONTENT_ENCODING}: ${this.headers.ContentEncoding}`);
        headers.push(`${HEADER_CONTENT_ENCRYPTION}: ${this.headers.ContentEncryption}`);
        headers.push(`${HEADER_CONTENT_LENGTH}: ${this.headers.ContentLength}`);
        headers.push(`${HEADER_CONTENT_SIGNATURE}: ${createSignatureHeader(this.headers.ContentSignature, this.headers.Origin)}`);
        headers.push(`${HEADER_CONTENT_TYPE}: ${this.headers.ContentType}`);
        headers.push(`${HEADER_CREATED}: ${this.headers.Created.toISOString()}`);
        headers.push(`${HEADER_ORIGIN}: ${createOriginHeader(this.headers.Origin)}`);
        if (this.headers.MailerContent) {
            headers.push(`${HEADER_MAILER_CONTENT}:  ${createContentBuffer(this.headers.MailerContent)}`);
        }
        return Buffer.from(headers.join('\r\n'), 'utf8');
    }
}

export { SerializableMailPayloadHeaders };
