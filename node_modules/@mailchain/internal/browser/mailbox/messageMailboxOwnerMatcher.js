import { parseNameServiceAddress } from '@mailchain/addressing';
import { isPublicKeyEqual } from '@mailchain/crypto';
import uniqBy from 'lodash/uniqBy';
import { createMailchainApiAddressIdentityKeyResolver, createMessageHeaderIdentityKeyResolver } from './addressIdentityKeyResolver.js';
import { IdentityKeys } from '../identityKeys/identityKeys.js';

class MessageMailboxOwnerMatcher {
    constructor(addressIdentityKeyResolvers) {
        Object.defineProperty(this, "addressIdentityKeyResolvers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: addressIdentityKeyResolvers
        });
    }
    /** Create {@link MessageMailboxOwnerMatcher} with {@link createMailchainApiAddressIdentityKeyResolver} as default resolver.  */
    static create(config) {
        const identityKeys = IdentityKeys.create(config);
        return new MessageMailboxOwnerMatcher([
            ['mailchain-api', createMailchainApiAddressIdentityKeyResolver(identityKeys)],
        ]);
    }
    /**
     * Build new {@link MessageMailboxOwnerMatcher} with an additional identity key resolver {@link createMessageHeaderIdentityKeyResolver}.
     *
     * Note: this doesn't modify the original {@link MessageMailboxOwnerMatcher}.
     */
    withMessageIdentityKeys(addressIdentityKeys) {
        const resolver = createMessageHeaderIdentityKeyResolver(addressIdentityKeys);
        return new MessageMailboxOwnerMatcher([['message-header', resolver], ...this.addressIdentityKeyResolvers]);
    }
    /** Find the matching {@link Alias} from the provided `mailData` that match to the `userMailbox`. */
    async findMatches(mailData, userMailbox) {
        const allRecipients = uniqBy([...mailData.recipients, ...mailData.carbonCopyRecipients, ...mailData.blindCarbonCopyRecipients], (r) => r.address);
        const matches = [];
        for (const recipient of allRecipients) {
            const address = parseNameServiceAddress(recipient.address);
            for (const [matchBy, resolver] of this.addressIdentityKeyResolvers) {
                const result = await resolver(address);
                if (result != null && isPublicKeyEqual(result.identityKey, userMailbox.identityKey)) {
                    matches.push({ address: parseNameServiceAddress(recipient.address), matchBy });
                    break; // found a match for this recipient, break the resolvers loop
                }
            }
        }
        if (matches.length === 0) {
            return [{ address: userMailbox.aliases[0].address, matchBy: 'fallback' }];
        }
        return matches;
    }
}

export { MessageMailboxOwnerMatcher };
