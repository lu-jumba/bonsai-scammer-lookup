import { ED25519ExtendedPrivateKey } from '@mailchain/crypto';
import { SerializableMailPayloadHeaders } from './payload/headers.js';
import { encryptPayload } from '../transport/serialization/encrypt.js';
import { CHUNK_LENGTH_1MB } from '../transport/serialization/chunk.js';
import { serialize, deserialize } from '../transport/serialization/serialization.js';
import { decryptPayload } from '../transport/serialization/decrypt.js';

function createMailchainMessageCrypto(keyRing) {
    const inboxKey = ED25519ExtendedPrivateKey.fromPrivateKey(keyRing.rootInboxKey());
    const encrypt = async (payload) => {
        const headers = SerializableMailPayloadHeaders.FromEncryptedMailPayloadHeaders(payload.Headers).ToBuffer();
        const encryptedPayload = await encryptPayload(headers, payload.Content, inboxKey, CHUNK_LENGTH_1MB);
        const serializedContent = serialize(encryptedPayload);
        return new Uint8Array(serializedContent);
    };
    const decrypt = async (serializedContent) => {
        const encryptedPayload = deserialize(Buffer.from(serializedContent));
        const { headers, content } = await decryptPayload(encryptedPayload, inboxKey);
        return {
            Content: content,
            Headers: SerializableMailPayloadHeaders.FromBuffer(headers).headers,
        };
    };
    return { encrypt, decrypt };
}

export { createMailchainMessageCrypto };
