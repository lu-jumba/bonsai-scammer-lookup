import { decodeBase64, encodeBase64 } from '@mailchain/encoding';
import { parseNameServiceAddress, formatAddress } from '@mailchain/addressing';
import { publicKeyFromBytes, publicKeyToBytes } from '@mailchain/crypto';
import { createAxiosConfiguration, getAxiosWithSigner, InboxApiFactory, PutEncryptedMessageRequestBodyFolderEnum } from '@mailchain/api';
import { preview } from '../protobuf/inbox/inbox.js';
import { parseMimeText } from '../formatters/parse.js';
import { mailchainAddressHasher, getAddressHash, getMailAddressesHashes } from './addressHasher.js';
import { createMailchainMessageIdCreator } from './messageId.js';
import { createMailchainMessageCrypto } from './messageCrypto.js';
import { createMailchainUserMailboxHasher } from './userMailboxHasher.js';
import { MessageMailboxOwnerMatcher } from './messageMailboxOwnerMatcher.js';
import { createMailchainApiAddressIdentityKeyResolver } from './addressIdentityKeyResolver.js';
import { getAllMessagePreviewMigrations } from './migrations.js';
import { convertPayload } from './payload/payload.js';
import { IdentityKeys } from '../identityKeys/identityKeys.js';

class MailchainMailboxOperations {
    constructor(inboxApi, messagePreviewCrypto, messageCrypto, messageMailboxOwnerMatcher, addressHasher, messageIdCreator, userMailboxHasher, messageDateOffset, migration) {
        Object.defineProperty(this, "inboxApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: inboxApi
        });
        Object.defineProperty(this, "messagePreviewCrypto", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagePreviewCrypto
        });
        Object.defineProperty(this, "messageCrypto", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messageCrypto
        });
        Object.defineProperty(this, "messageMailboxOwnerMatcher", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messageMailboxOwnerMatcher
        });
        Object.defineProperty(this, "addressHasher", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: addressHasher
        });
        Object.defineProperty(this, "messageIdCreator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messageIdCreator
        });
        Object.defineProperty(this, "userMailboxHasher", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: userMailboxHasher
        });
        Object.defineProperty(this, "messageDateOffset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messageDateOffset
        });
        Object.defineProperty(this, "migration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: migration
        });
    }
    static create(sdkConfig, keyRing) {
        const axiosConfig = createAxiosConfiguration(sdkConfig.apiPath);
        const axiosClient = getAxiosWithSigner(keyRing.accountMessagingKey());
        const inboxApi = InboxApiFactory(axiosConfig, undefined, axiosClient);
        const messagePreviewCrypto = keyRing.inboxKey();
        const messageMessageCrypto = createMailchainMessageCrypto(keyRing);
        const messageMailboxOwnerMatcher = MessageMailboxOwnerMatcher.create(sdkConfig);
        const addressHasher = mailchainAddressHasher(createMailchainApiAddressIdentityKeyResolver(IdentityKeys.create(sdkConfig)), keyRing);
        const messageHasher = createMailchainMessageIdCreator(keyRing);
        const userMailboxHasher = createMailchainUserMailboxHasher(keyRing);
        return new MailchainMailboxOperations(inboxApi, messagePreviewCrypto, messageMessageCrypto, messageMailboxOwnerMatcher, addressHasher, messageHasher, userMailboxHasher, keyRing.inboxMessageDateOffset(), getAllMessagePreviewMigrations(sdkConfig));
    }
    async getMessage(messageId) {
        const message = await this.inboxApi.getMessage(messageId).then((res) => res.data.message);
        return this.handleMessagePreview(message);
    }
    async getInboxMessages() {
        const messages = await this.inboxApi.getMessagesInInboxView().then((res) => res.data.messages);
        return this.handleMessagePreviews(messages);
    }
    async getStarredMessages() {
        const messages = await this.inboxApi.getMessagesInStarredView().then((res) => res.data.messages);
        return this.handleMessagePreviews(messages);
    }
    async getTrashMessages() {
        const messages = await this.inboxApi.getMessagesInTrashView().then((res) => res.data.messages);
        return this.handleMessagePreviews(messages);
    }
    async getUnreadMessages() {
        const messages = await this.inboxApi.getMessagesInUnreadView().then((res) => res.data.messages);
        return this.handleMessagePreviews(messages);
    }
    async getSentMessages() {
        const messages = await this.inboxApi.getMessagesInSentView().then((res) => res.data.messages);
        return this.handleMessagePreviews(messages);
    }
    async getOutboxMessages() {
        const messages = await this.inboxApi.getMessagesInOutboxView().then((res) => res.data.messages);
        return this.handleMessagePreviews(messages);
    }
    async getArchivedMessages() {
        const messages = await this.inboxApi.getMessagesInArchivedView().then((res) => res.data.messages);
        return this.handleMessagePreviews(messages);
    }
    async searchMessages() {
        const messages = await this.inboxApi.getMessagesSearch().then((res) => res.data.messages);
        return this.handleMessagePreviews(messages);
    }
    async handleMessagePreviews(messages) {
        const messagePreviews = [];
        for (const message of messages) {
            try {
                messagePreviews.push(await this.handleMessagePreview(message));
            }
            catch (error) {
                // TODO: decide how to handle
                console.error(`failed to read message preview: version=${message.version};messageId=${message.messageId}`, error);
            }
        }
        return messagePreviews;
    }
    async handleMessagePreview(apiMessage) {
        const encryptedPreviewData = decodeBase64(apiMessage.encryptedPreview);
        // const previewData = await this.messagePreviewCrypto.decrypt(encryptedPreviewData);
        // const preview = protoInbox.preview.MessagePreview.decode(previewData);
        const originalPreviewData = {
            version: apiMessage.version,
            messagePreview: preview.MessagePreview.decode(await this.messagePreviewCrypto.decrypt(encryptedPreviewData)),
        };
        const message = (await this.migration.shouldApply(originalPreviewData))
            ? await this.migration.apply(originalPreviewData)
            : originalPreviewData;
        if (apiMessage.version !== message.version) {
            console.debug(`${apiMessage.messageId} migrated from v${apiMessage.version} to v${message.version}`);
            // TODO #750: save migrated message to Mailchain
        }
        const { messagePreview } = message;
        return {
            mailbox: publicKeyFromBytes(messagePreview.mailbox),
            messageId: apiMessage.messageId,
            owner: messagePreview.owner,
            to: messagePreview.to,
            bcc: messagePreview.bcc,
            cc: messagePreview.cc,
            from: messagePreview.from,
            subject: messagePreview.subject,
            snippet: messagePreview.snippet,
            hasAttachment: messagePreview.hasAttachment,
            timestamp: new Date(messagePreview.timestamp * 1000),
            isRead: !apiMessage.systemLabels.includes('unread'),
            systemLabels: apiMessage.systemLabels,
        };
    }
    async getFullMessage(messageId) {
        const encryptedMessage = await this.inboxApi
            .getEncryptedMessageBody(messageId, { responseType: 'arraybuffer' })
            .then((res) => res.data);
        const messageData = await this.messageCrypto.decrypt(new Uint8Array(encryptedMessage));
        const { mailData } = await parseMimeText(messageData.Content);
        const to = mailData.recipients.map((r) => r.address);
        const cc = mailData.carbonCopyRecipients.map((r) => r.address);
        const bcc = mailData.blindCarbonCopyRecipients.map((r) => r.address);
        return {
            from: mailData.from.address,
            to,
            replyTo: mailData.replyTo ? mailData.replyTo.address : undefined,
            subject: mailData.subject,
            timestamp: mailData.date,
            body: mailData.message,
            cc,
            bcc,
        };
    }
    async saveSentMessage(params) {
        const messageId = await this.messageIdCreator({ type: 'sent', mailData: params.content });
        const owner = parseNameServiceAddress(params.content.from.address);
        return this.saveMessage(messageId, params.payload, params.content, params.userMailbox, owner, 'outbox');
    }
    async saveReceivedMessage({ userMailbox, receivedTransportPayload, }) {
        const payload = convertPayload(receivedTransportPayload);
        const { mailData, addressIdentityKeys } = await parseMimeText(payload.Content);
        const owners = await this.messageMailboxOwnerMatcher
            .withMessageIdentityKeys(addressIdentityKeys)
            .findMatches(mailData, userMailbox);
        if (owners.length === 0)
            throw new Error('no owners found for message');
        const savedMessages = [];
        for (const { address: owner } of owners) {
            const messageId = await this.messageIdCreator({
                type: 'received',
                mailData,
                owner: formatAddress(owner, 'mail'),
                mailbox: userMailbox.identityKey,
            });
            const savedMessage = await this.saveMessage(messageId, payload, mailData, userMailbox, owner, 'inbox');
            savedMessages.push(savedMessage);
        }
        if (savedMessages.length === 0) {
            throw new Error(`no message was saved for message with ID [${mailData.id}]`);
        }
        return savedMessages;
    }
    async saveMessage(messageId, payload, content, userMailbox, owner, folder) {
        const ownerAddress = formatAddress(owner, 'mail');
        const messagePreview = createMessagePreview(userMailbox, owner, content);
        const encodedMessagePreview = preview.MessagePreview.encode(messagePreview).finish();
        const encryptedMessagePreview = await this.messagePreviewCrypto.encrypt(encodedMessagePreview);
        const encryptedMessage = await this.messageCrypto.encrypt(payload);
        const { recipients: to, carbonCopyRecipients: cc, blindCarbonCopyRecipients: bcc } = content;
        const addresses = [content.from, ...to, ...cc, ...bcc].map((a) => a.address);
        addresses.push(ownerAddress);
        const addressHashes = await this.addressHasher(addresses);
        const { resourceId } = await this.inboxApi.postEncryptedMessageBody(encryptedMessage).then((res) => res.data);
        await this.inboxApi.putEncryptedMessage(messageId, {
            version: 3,
            folder: folder === 'outbox'
                ? PutEncryptedMessageRequestBodyFolderEnum.Outbox
                : PutEncryptedMessageRequestBodyFolderEnum.Inbox,
            date: messagePreview.timestamp - this.messageDateOffset,
            mailbox: Array.from(await this.userMailboxHasher(userMailbox)),
            // Note: 'hashedOwner' is only 'username' hash because there is no need for 'identity-key' because that is covered by 'mailbox'
            hashedOwner: Array.from(getAddressHash(addressHashes, ownerAddress, 'username')),
            // Note: 'hashedFrom' takes only single type of hash because there is API type restriction, so 'identity-key' hash is proffered.
            hashedFrom: Array.from(getAddressHash(addressHashes, content.from.address, 'identity-key', 'username')),
            hashedTo: getMailAddressesHashes(addressHashes, to).map((h) => Array.from(h)),
            hashedCc: getMailAddressesHashes(addressHashes, cc).map((h) => Array.from(h)),
            hashedBcc: getMailAddressesHashes(addressHashes, bcc).map((h) => Array.from(h)),
            encryptedPreview: encodeBase64(encryptedMessagePreview),
            messageBodyResourceId: resourceId,
        });
        return {
            mailbox: userMailbox.identityKey,
            messageId,
            from: messagePreview.from,
            to: messagePreview.to,
            cc: messagePreview.cc,
            bcc: messagePreview.bcc,
            subject: messagePreview.subject,
            owner: messagePreview.owner,
            snippet: messagePreview.snippet,
            isRead: folder === 'outbox',
            systemLabels: folder === 'outbox' ? ['outbox'] : ['unread', 'inbox'],
            hasAttachment: false,
            timestamp: new Date(messagePreview.timestamp * 1000),
        };
    }
    async markOutboxMessageAsSent(messageId) {
        await this.modifySystemLabel(messageId, 'outbox', false);
        await this.modifySystemLabel(messageId, 'sent', true);
    }
    async modifyArchiveMessage(messageId, archived) {
        await this.modifySystemLabel(messageId, 'archive', archived);
    }
    async modifyIsReadMessage(messageId, isRead) {
        await this.modifySystemLabel(messageId, 'unread', !isRead);
    }
    async modifyTrashMessage(messageId, trash) {
        await this.modifySystemLabel(messageId, 'trash', trash);
    }
    async modifyStarredMessage(messageId, isStarred) {
        await this.modifySystemLabel(messageId, 'starred', isStarred);
    }
    async modifySystemLabel(messageId, systemLabel, include) {
        await this.modifyUserLabel(messageId, systemLabel, include);
    }
    async modifyUserLabel(messageId, userLabel, include) {
        if (include) {
            await this.inboxApi.putMessageLabel(messageId, userLabel);
        }
        else {
            await this.inboxApi.deleteMessageLabel(messageId, userLabel);
        }
    }
}
function createMessagePreview(userMailbox, owner, content, snippetLength = 100) {
    return preview.MessagePreview.create({
        owner: formatAddress(owner, 'mail'),
        mailbox: publicKeyToBytes(userMailbox.identityKey),
        to: content.recipients.map((it) => it.address),
        cc: content.carbonCopyRecipients.map((it) => it.address),
        bcc: content.blindCarbonCopyRecipients.map((it) => it.address),
        from: content.from.address,
        subject: content.subject,
        snippet: content.plainTextMessage.substring(0, snippetLength - 1).trim(),
        hasAttachment: false,
        timestamp: Math.round(content.date.getTime() / 1000),
    });
}

export { MailchainMailboxOperations };
