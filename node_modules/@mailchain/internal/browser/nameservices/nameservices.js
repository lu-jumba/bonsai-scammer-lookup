import { publicKeyToBytes, isPublicKeyEqual } from '@mailchain/crypto';
import { encodeHexZeroX } from '@mailchain/encoding';
import { ETHEREUM, TEZOS, createNameServiceAddress } from '@mailchain/addressing';
import { NAMESERVICE_DESCRIPTIONS } from '@mailchain/addressing/nameservices';
import { IdentityKeysApiFactory, createAxiosConfiguration } from '@mailchain/api';
import { IdentityKeys } from '../identityKeys/identityKeys.js';

const PROTOCOLS_SUPPORTING_NAMESERVICE = [ETHEREUM, TEZOS];
class Nameservices {
    constructor(identityKeysApi, identityKeysService, mailchainAddressDomain) {
        Object.defineProperty(this, "identityKeysApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: identityKeysApi
        });
        Object.defineProperty(this, "identityKeysService", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: identityKeysService
        });
        Object.defineProperty(this, "mailchainAddressDomain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: mailchainAddressDomain
        });
    }
    static create(config) {
        const identityKeysApi = IdentityKeysApiFactory(createAxiosConfiguration(config.apiPath));
        const identityKeysService = IdentityKeys.create(config);
        return new Nameservices(identityKeysApi, identityKeysService, config.mailchainAddressDomain);
    }
    async reverseResolveNames(identityKey) {
        return this.identityKeysApi.getIdentityKeyResolvableNames(encodeHexZeroX(publicKeyToBytes(identityKey))).then(({ data }) => data.resolvableNames?.map((resolved) => ({
            ...resolved,
            address: createNameServiceAddress(resolved.name, resolved.resolver, this.mailchainAddressDomain),
        })) ?? [], (e) => {
            console.error(e);
            return [];
        });
    }
    async nameResolvesToMailbox(nsName, mailboxIdentityKey) {
        for (const nsDesc of NAMESERVICE_DESCRIPTIONS) {
            const nsAddress = createNameServiceAddress(nsName, nsDesc.name, this.mailchainAddressDomain);
            try {
                const addressIdentityKey = await this.identityKeysService.getAddressIdentityKey(nsAddress);
                if (addressIdentityKey != null &&
                    isPublicKeyEqual(addressIdentityKey.identityKey, mailboxIdentityKey)) {
                    return nsAddress;
                }
            }
            catch (e) {
                console.log(`failed to resolve address: ${e}`);
            }
        }
        return null;
    }
}

export { Nameservices, PROTOCOLS_SUPPORTING_NAMESERVICE };
