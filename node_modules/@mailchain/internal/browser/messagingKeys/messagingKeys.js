import { encodeHexZeroX } from '@mailchain/encoding';
import { checkAddressForErrors, encodeAddressByProtocol, ALL_PROTOCOLS, ProtocolNotSupportedError, IdentityProviderAddressInvalidError, BadlyFormattedAddressError } from '@mailchain/addressing';
import { publicKeyToBytes } from '@mailchain/crypto';
import { AddressesApiFactory, createAxiosConfiguration, IdentityKeysApiFactory, encodingTypeToEncodingEnum, CryptoKeyConvert } from '@mailchain/api';
import { convertPublic } from '@mailchain/api/helpers/apiKeyToCryptoKey';
import { isAxiosError } from 'axios';
import { IdentityNotFoundError, IdentityProviderAddressUnsupportedError, IdentityExpiredError, IdentityProviderUnsupportedError, UnexpectedMailchainError } from './errors.js';
import { MessagingKeyContractCall } from './messagingKeyContract.js';
import { partitionMailchainResults } from '../mailchainResult.js';

class ResoleAddressesFailuresError extends Error {
    constructor(successes, failures) {
        super(`Not all addresses were resolved. Check the failed resolutions for more information.`);
        Object.defineProperty(this, "successes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: successes
        });
        Object.defineProperty(this, "failures", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: failures
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'resolve_addresses_failures'
        });
        Object.defineProperty(this, "docs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'https://docs.mailchain.com/developer/errors/codes#resolve_addresses_failures'
        });
    }
}
class MessagingKeys {
    constructor(addressApi, identityKeysApi, messagingKeyContractCall, mailchainAddressDomain) {
        Object.defineProperty(this, "addressApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: addressApi
        });
        Object.defineProperty(this, "identityKeysApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: identityKeysApi
        });
        Object.defineProperty(this, "messagingKeyContractCall", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKeyContractCall
        });
        Object.defineProperty(this, "mailchainAddressDomain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: mailchainAddressDomain
        });
    }
    static create(configuration) {
        return new MessagingKeys(AddressesApiFactory(createAxiosConfiguration(configuration.apiPath)), IdentityKeysApiFactory(createAxiosConfiguration(configuration.apiPath)), MessagingKeyContractCall.create(configuration), configuration.mailchainAddressDomain);
    }
    /**
     * Resolve the messaging key for the given address.
     *
     * @param address Address to resolve.
     *
     * @returns A {@link ResolvedAddress resolved address} which may be a registered or vended.
     *
     * @example
     * import { messagingKeys } from '@mailchain/sdk';
     *
     * const resolvedAddress = await messagingKeys.resolve(address);
     * console.log(resolvedAddress);
     *
     */
    async resolve(address) {
        const validateAddressError = checkAddressForErrors(address, this.mailchainAddressDomain);
        if (validateAddressError != null) {
            return { error: validateAddressError };
        }
        const { data, error } = await this.getAddressMessagingKey(address);
        if (error != null) {
            return { error };
        }
        return this.messagingKeyContractCall.resolve(data.protocol, data.contractCall, data.identityKey ? convertPublic(data.identityKey) : undefined);
    }
    async resolveMany(addresses) {
        const deduplicatedAddresses = [...new Set(addresses)];
        const resolvedAddresses = await Promise.all(deduplicatedAddresses.map(async (address) => {
            const resolvedAddress = await this.resolve(address);
            return { params: address, result: resolvedAddress };
        }));
        const { failures, successes } = partitionMailchainResults(resolvedAddresses);
        if (failures.length > 0) {
            return { error: new ResoleAddressesFailuresError(successes, failures) };
        }
        return {
            data: new Map(successes.map((r) => [r.params, r.data])),
        };
    }
    async update(proof) {
        const encodedIdentityKey = encodeHexZeroX(publicKeyToBytes(proof.identityKey));
        const encodedAddress = encodeAddressByProtocol(proof.address, proof.protocol);
        await this.identityKeysApi.putMsgKeyByIDKey(encodedIdentityKey, {
            address: {
                encoding: encodingTypeToEncodingEnum(encodedAddress.encoding),
                value: encodedAddress.encoded,
                network: proof.network,
                protocol: proof.protocol,
            },
            locale: proof.locale,
            messageVariant: proof.messageVariant,
            messagingKey: CryptoKeyConvert.public(proof.messagingKey),
            nonce: proof.nonce,
            signature: encodeHexZeroX(proof.signature),
            signatureMethod: proof.signatureMethod,
        });
    }
    async getAddressMessagingKey(address) {
        try {
            const { data } = await this.addressApi.getAddressMessagingKey(address);
            const protocol = data.protocol;
            if (!ALL_PROTOCOLS.includes(protocol)) {
                return { error: new ProtocolNotSupportedError(protocol) };
            }
            return { data };
        }
        catch (e) {
            if (isAxiosError(e)) {
                switch (e.response?.data?.code) {
                    case 'identity_provider_unsupported':
                        return {
                            error: new IdentityProviderUnsupportedError(),
                        };
                    case 'identity_expired':
                        return {
                            error: new IdentityExpiredError(),
                        };
                    case 'identity_provider_address_unsupported':
                        return {
                            error: new IdentityProviderAddressUnsupportedError(),
                        };
                    case 'identity_not_found':
                        return {
                            error: new IdentityNotFoundError(),
                        };
                    case 'address_format_invalid':
                    case 'tld_unknown':
                        return {
                            error: new BadlyFormattedAddressError(),
                        };
                    case 'identity_address_invalid':
                        return {
                            error: new IdentityProviderAddressInvalidError(),
                        };
                }
            }
            return {
                error: new UnexpectedMailchainError(`Failed to resolve messaging key of address ${address}`, e),
            };
        }
    }
    async getAddressMessagingKeyStatus(address) {
        try {
            const { data } = await this.addressApi.getAddressMessagingKeyStatus(address);
            return { data: data.status };
        }
        catch (e) {
            return {
                error: new IdentityProviderUnsupportedError(),
            };
        }
    }
}

export { MessagingKeys, ResoleAddressesFailuresError };
