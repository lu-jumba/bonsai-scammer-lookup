import { decodeHexZeroX } from '@mailchain/encoding';
import { MessagingKeysApiFactory, createAxiosConfiguration, getAddressFromApiResponse, ApiKeyConvert } from '@mailchain/api';
import { createProofMessage } from '@mailchain/signatures/keyreg';
import { MessagingKeyVerificationError, verify, PublicKeyNotFoundError, verifyMailchainProvidedMessagingKey } from '@mailchain/signatures';

class MessagingKeyVerifier {
    constructor(messagingKeysApi) {
        Object.defineProperty(this, "messagingKeysApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKeysApi
        });
    }
    static create(configuration) {
        return new MessagingKeyVerifier(MessagingKeysApiFactory(createAxiosConfiguration(configuration.apiPath)));
    }
    async verifyRegisteredKeyProof(registeredKeyProof, messagingKey) {
        if (!registeredKeyProof)
            throw new MessagingKeyVerificationError();
        if (registeredKeyProof.signature == null)
            throw new MessagingKeyVerificationError();
        const params = {
            AddressEncoding: registeredKeyProof.address.encoding,
            PublicKeyEncoding: registeredKeyProof.messagingKeyEncoding,
            Locale: registeredKeyProof.locale,
            Variant: registeredKeyProof.variant,
        };
        const message = createProofMessage(params, getAddressFromApiResponse(registeredKeyProof.address), messagingKey, registeredKeyProof.nonce);
        // verify the proof with the correct signer
        const identityKey = ApiKeyConvert.public(registeredKeyProof.identityKey);
        const isVerified = await verify(registeredKeyProof.signingMethod, identityKey, message, decodeHexZeroX(registeredKeyProof.signature));
        return {
            identityKey,
            result: isVerified,
        };
    }
    async verifyProvidedKeyProof(providedKeyProof, messagingKey) {
        const mailchainPublicKeyResponse = await this.messagingKeysApi.getMailchainPublicKey();
        if (!mailchainPublicKeyResponse.data.key?.value)
            throw new PublicKeyNotFoundError();
        const mailchainPublicKey = ApiKeyConvert.public(mailchainPublicKeyResponse.data.key);
        if (!providedKeyProof.signature)
            throw new MessagingKeyVerificationError();
        return await verifyMailchainProvidedMessagingKey(mailchainPublicKey, messagingKey, decodeHexZeroX(providedKeyProof?.signature), providedKeyProof.address, providedKeyProof.protocol);
    }
}

export { MessagingKeyVerifier };
