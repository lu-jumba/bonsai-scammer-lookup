import { isPublicKeyEqual } from '@mailchain/crypto';
import { SenderMessagingKeyIncorrect } from '@mailchain/signatures';
import { AddressNonce } from './addressNonce.js';
import { MessagingKeys } from './messagingKeys.js';
import { MessagingKeyNotRegisteredError } from './errors.js';

class PrivateMessagingKeys {
    constructor(messagingKeys, addressNonce) {
        Object.defineProperty(this, "messagingKeys", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKeys
        });
        Object.defineProperty(this, "addressNonce", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: addressNonce
        });
    }
    static create(config) {
        return new PrivateMessagingKeys(MessagingKeys.create(config), AddressNonce.create(config));
    }
    async getExportablePrivateMessagingKey(address, keyRing) {
        const { data: resolvedAddress, error: resolveAddressError } = await this.messagingKeys.resolve(address);
        if (resolveAddressError != null) {
            return { error: resolveAddressError };
        }
        const { data: getMessagingKeyLatestNonce, error: getMessagingKeyLatestNonceError } = await this.addressNonce.getMessagingKeyLatestNonce(resolvedAddress.protocolAddress, resolvedAddress.protocol);
        if (getMessagingKeyLatestNonceError != null) {
            return { error: getMessagingKeyLatestNonceError };
        }
        if (resolvedAddress.type === 'vended') {
            return { error: new MessagingKeyNotRegisteredError() };
        }
        const privateMessagingKey = keyRing.addressExportableMessagingKey(resolvedAddress.protocolAddress, resolvedAddress.protocol, getMessagingKeyLatestNonce);
        if (!isPublicKeyEqual(privateMessagingKey.publicKey, resolvedAddress.messagingKey)) {
            return { error: new SenderMessagingKeyIncorrect() };
        }
        return { data: privateMessagingKey };
    }
}

export { PrivateMessagingKeys };
