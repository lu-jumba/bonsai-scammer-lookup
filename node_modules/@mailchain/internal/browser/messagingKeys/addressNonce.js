import { NEAR, ETHEREUM, TEZOS, FILECOIN, MAILCHAIN, ProtocolNotSupportedError, isBlockchainProtocolEnabled } from '@mailchain/addressing';
import axios from 'axios';
import { MessagingKeysApiFactory, createAxiosConfiguration } from '@mailchain/api';
import { NearContractCallResolver } from './contractResolvers/near.js';
import { MailchainKeyRegContractCallResolver } from './contractResolvers/mailchain.js';
import { MessagingKeyNotFoundInContractError } from './contractResolvers/errors.js';
import { UnexpectedMailchainError } from './errors.js';

class AddressNonce {
    constructor(messagingKeysApi, resolvers) {
        Object.defineProperty(this, "messagingKeysApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKeysApi
        });
        Object.defineProperty(this, "resolvers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: resolvers
        });
    }
    static create(configuration, axiosInstance = axios.create()) {
        const mailchainKeyRegistryResolver = MailchainKeyRegContractCallResolver.create(configuration, axiosInstance);
        return new AddressNonce(MessagingKeysApiFactory(createAxiosConfiguration(configuration.apiPath)), new Map([
            [NEAR, NearContractCallResolver.create(configuration, axiosInstance)],
            [ETHEREUM, mailchainKeyRegistryResolver],
            [TEZOS, mailchainKeyRegistryResolver],
            [FILECOIN, mailchainKeyRegistryResolver],
        ]));
    }
    /**
     * Get the latest nonce for an address.
     *
     * @param address the protocol get the latest nonce for.
     * @param protocol where to find the address.
     * @returns The latest nonce for the given address.
     */
    async getMessagingKeyLatestNonce(address, protocol) {
        if (protocol === MAILCHAIN) {
            return { data: 1 }; // currently mailchain accounts do not support incrementing nonces
        }
        const resolver = this.resolvers.get(protocol);
        if (!resolver) {
            return { error: new ProtocolNotSupportedError(protocol) };
        }
        if (!isBlockchainProtocolEnabled(protocol)) {
            return { error: new ProtocolNotSupportedError(protocol) };
        }
        const nonceContractResponse = await this.messagingKeysApi.getProtocolAddressNonce(address, protocol);
        try {
            const nonce = await resolver.latestNonce(nonceContractResponse.data.contractCall);
            return {
                data: nonce,
            };
        }
        catch (error) {
            if (error instanceof MessagingKeyNotFoundInContractError) {
                return {
                    data: 0,
                };
            }
            return {
                error: new UnexpectedMailchainError('Failed to get latest nonce.', error),
            };
        }
    }
}

export { AddressNonce };
