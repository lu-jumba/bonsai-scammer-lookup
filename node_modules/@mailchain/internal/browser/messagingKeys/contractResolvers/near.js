import { encodeUtf8, decodeBase64, decodeHex } from '@mailchain/encoding';
import { publicKeyFromKind } from '@mailchain/crypto';
import axios from 'axios';
import { NEAR } from '@mailchain/addressing';
import { MessagingKeyNotFoundInContractError, InvalidContractResponseError } from './errors.js';

class NearContractCallResolver {
    constructor(rpcEndpoint, axiosInstance) {
        Object.defineProperty(this, "rpcEndpoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: rpcEndpoint
        });
        Object.defineProperty(this, "axiosInstance", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: axiosInstance
        });
    }
    static create(config, axiosInstance = axios.create()) {
        return new NearContractCallResolver(config.nearRpcUrl, axiosInstance);
    }
    async resolve(contract) {
        const rpcResponse = await this.callContract(contract);
        const result = encodeUtf8(Uint8Array.from(rpcResponse.result));
        if (result === 'null') {
            return { error: new MessagingKeyNotFoundInContractError() };
        }
        const parsedResult = parseMessagingKeyContractResult(result);
        if (parsedResult.error != null) {
            return parsedResult;
        }
        return {
            data: {
                messagingKey: parsedResult.data.messagingKey,
                protocol: NEAR,
            },
        };
    }
    async latestNonce(contract) {
        const rpcResponse = await this.callContract(contract);
        const result = encodeUtf8(Uint8Array.from(rpcResponse.result));
        if (result === 'null') {
            throw new MessagingKeyNotFoundInContractError();
        }
        return parseInt(result, 10);
    }
    async callContract(contract) {
        if (contract.body.length === 0) {
            throw new Error('No body on contract call');
        }
        const body = encodeUtf8(decodeBase64(contract.body));
        const postData = JSON.parse(body);
        const response = await this.axiosInstance.request({
            method: contract.method,
            url: this.rpcEndpoint,
            data: postData,
        });
        if (response.status !== 200) {
            throw new Error(`Failed to get messaging key from near, status: ${response.status}, response: ${response.data}`);
        }
        const { data } = response;
        if (data.result.error != null) {
            throw new Error(`Contract error; error=${data.result.error}`);
        }
        if (!data.result.result) {
            throw new Error(`No error but missing result response: ${data}`);
        }
        return data.result;
    }
}
function parseMessagingKeyContractResult(result) {
    const parsedResult = JSON.parse(result);
    if (typeof parsedResult !== 'object') {
        return { error: new InvalidContractResponseError('Object expected.') };
    }
    const [curve, messageKey] = parsedResult;
    if (curve == null || messageKey == null) {
        return { error: new InvalidContractResponseError('Result does not have correct number of elements.') };
    }
    if (typeof curve !== 'string') {
        return { error: new InvalidContractResponseError('Curve format must be string.') };
    }
    if (typeof messageKey !== 'string') {
        return { error: new InvalidContractResponseError('Message key format must be string.') };
    }
    return { data: { messagingKey: publicKeyFromKind(curve, decodeHex(messageKey)) } };
}

export { NearContractCallResolver };
