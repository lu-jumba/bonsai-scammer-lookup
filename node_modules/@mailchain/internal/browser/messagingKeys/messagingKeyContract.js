import { MessagingKeysApiFactory, createAxiosConfiguration } from '@mailchain/api';
import axios from 'axios';
import { ETHEREUM, NEAR, TEZOS } from '@mailchain/addressing';
import { convertPublic } from '@mailchain/api/helpers/apiKeyToCryptoKey';
import { MessagingKeyVerificationError } from '@mailchain/signatures';
import { FILECOIN, MAILCHAIN, ProtocolNotSupportedError } from '@mailchain/addressing/protocols';
import { NearContractCallResolver } from './contractResolvers/near.js';
import { MessagingKeyVerifier } from './verify.js';
import { MailchainKeyRegContractCallResolver } from './contractResolvers/mailchain.js';
import { MessagingKeyNotFoundInContractError, InvalidContractResponseError } from './contractResolvers/errors.js';
import { MessagingKeyContactError } from './errors.js';

class MessagingKeyContractCall {
    constructor(resolvers, messagingKeysApi, messagingKeyVerifier) {
        Object.defineProperty(this, "resolvers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: resolvers
        });
        Object.defineProperty(this, "messagingKeysApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKeysApi
        });
        Object.defineProperty(this, "messagingKeyVerifier", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKeyVerifier
        });
    }
    static create(configuration, axiosInstance = axios.create()) {
        const mailchainKeyRegistryResolver = MailchainKeyRegContractCallResolver.create(configuration, axiosInstance);
        return new MessagingKeyContractCall(new Map([
            [ETHEREUM, mailchainKeyRegistryResolver],
            [FILECOIN, mailchainKeyRegistryResolver],
            [MAILCHAIN, mailchainKeyRegistryResolver],
            [NEAR, NearContractCallResolver.create(configuration, axiosInstance)],
            [TEZOS, mailchainKeyRegistryResolver],
        ]), MessagingKeysApiFactory(createAxiosConfiguration(configuration.apiPath)), MessagingKeyVerifier.create(configuration));
    }
    async resolve(protocol, contractCall, identityKey) {
        const resolver = this.resolvers.get(protocol);
        if (!resolver) {
            return { error: new ProtocolNotSupportedError(protocol) };
        }
        const { data, error } = await resolver.resolve(contractCall);
        if (error != null) {
            if (error instanceof MessagingKeyNotFoundInContractError) {
                const vendedKeyResponse = await this.messagingKeysApi.getVendedPublicMessagingKey(contractCall.address, contractCall.protocol);
                const verified = await this.messagingKeyVerifier.verifyProvidedKeyProof(vendedKeyResponse.data.proof, convertPublic(vendedKeyResponse.data.messagingKey));
                if (!verified) {
                    return { error: new MessagingKeyVerificationError() };
                }
                return {
                    data: {
                        messagingKey: convertPublic(vendedKeyResponse.data.messagingKey),
                        identityKey,
                        protocol,
                        type: 'vended',
                        protocolAddress: contractCall.address,
                    },
                };
            }
            else if (error instanceof InvalidContractResponseError) {
                return { error: new MessagingKeyContactError(error) };
            }
            return {
                error: new MessagingKeyContactError(error),
            };
        }
        const { messagingKey } = data;
        return {
            data: { type: 'registered', messagingKey, identityKey, protocol, protocolAddress: contractCall.address },
        };
    }
}

export { MessagingKeyContractCall };
