import { decodeBase64, encodeBase64 } from '@mailchain/encoding';
import { encodeAddressByProtocol, createWalletAddress, parseNameServiceAddress, MAILCHAIN, decodeAddressByProtocol, formatAddress } from '@mailchain/addressing';
import { publicKeyFromBytes, publicKeyToBytes } from '@mailchain/crypto';
import { createAxiosConfiguration, UserApiFactory, getAxiosWithSigner } from '@mailchain/api';
import { user } from '../protobuf/user/user.js';
import { combineMigrations } from '../migration.js';
import { createV6FixNsAliasFormatMigration, createV5NsMigration, createV4AliasesMigration, createV3LabelMigration, createV2IdentityKey } from './migrations.js';
import { createMailboxAlias } from './createAlias.js';
import { consolidateMailbox } from './consolidateMailbox.js';
import { Nameservices } from '../nameservices/nameservices.js';
import { IdentityKeys } from '../identityKeys/identityKeys.js';

class UserNotFoundError extends Error {
    constructor() {
        super(`user not found for provided key`);
    }
}
const CURRENT_MAILBOX_VERSION = 6;
class MailchainUserProfile {
    constructor(mailchainAddressDomain, userApi, accountIdentityKey, mailboxCrypto, migration) {
        Object.defineProperty(this, "mailchainAddressDomain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: mailchainAddressDomain
        });
        Object.defineProperty(this, "userApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: userApi
        });
        Object.defineProperty(this, "accountIdentityKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: accountIdentityKey
        });
        Object.defineProperty(this, "mailboxCrypto", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: mailboxCrypto
        });
        Object.defineProperty(this, "migration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: migration
        });
    }
    static create(config, accountIdentityKey, mailboxCrypto) {
        const axiosConfig = createAxiosConfiguration(config.apiPath);
        const identityKeys = IdentityKeys.create(config);
        const userApi = UserApiFactory(axiosConfig, undefined, getAxiosWithSigner(accountIdentityKey));
        const nameservice = Nameservices.create(config);
        const migrations = combineMigrations(createV2IdentityKey(identityKeys, config.mailchainAddressDomain), createV3LabelMigration(config.mailchainAddressDomain), createV4AliasesMigration(config.mailchainAddressDomain), createV5NsMigration(nameservice), createV6FixNsAliasFormatMigration(config.mailchainAddressDomain));
        return new MailchainUserProfile(config.mailchainAddressDomain, userApi, () => Promise.resolve(accountIdentityKey.publicKey), mailboxCrypto, migrations);
    }
    async getUsername() {
        return this.userApi
            .getUsername()
            .then((response) => {
            const { data } = response;
            return {
                address: data.address,
                username: data.username,
            };
        })
            .catch((e) => {
            if (e.response?.status === 404) {
                throw new UserNotFoundError();
            }
            throw e;
        });
    }
    async setSetting(key, value) {
        await this.userApi.putUserSetting(key, { value });
    }
    async getSettings() {
        const { data } = await this.userApi.getUserSettings();
        return data.settings ?? {};
    }
    async mailboxes() {
        const { mailboxes: apiMailboxes } = await this.userApi.getUserMailboxes().then((r) => r.data);
        const resultMailboxes = [];
        for (const apiMailbox of apiMailboxes) {
            try {
                const decryptedMailbox = await this.mailboxCrypto.decrypt(decodeBase64(apiMailbox.encryptedMailboxInformation));
                const originalMailboxData = {
                    version: apiMailbox.version,
                    protoMailbox: user.Mailbox.decode(decryptedMailbox),
                };
                const mailboxData = (await this.migration.shouldApply(originalMailboxData))
                    ? await this.migration.apply(originalMailboxData)
                    : originalMailboxData;
                if (apiMailbox.version !== mailboxData.version) {
                    console.debug(`${apiMailbox.mailboxId} migrated from v${apiMailbox.version} to v${mailboxData.version}`);
                    this.internalUpdateMailbox(apiMailbox.mailboxId, mailboxData.protoMailbox, mailboxData.version).then(() => console.debug(`successfully stored migrated mailbox ${apiMailbox.mailboxId}`), (e) => console.warn(`failed storing migrated mailbox ${apiMailbox.mailboxId}`, e));
                }
                const { protoMailbox } = mailboxData;
                const protocol = protoMailbox.protocol;
                const encodedAddress = encodeAddressByProtocol(protoMailbox.address, protocol).encoded;
                const fallbackAlias = createMailboxAlias(createWalletAddress(encodedAddress, protocol, this.mailchainAddressDomain));
                const mailboxAliases = protoMailbox.aliases.map(user.Mailbox.Alias.create).map((protoAlias) => {
                    return createMailboxAlias(parseNameServiceAddress(protoAlias.address), {
                        allowSending: !protoAlias.blockSending,
                        allowReceiving: !protoAlias.blockReceiving,
                    });
                });
                resultMailboxes.push({
                    type: 'wallet',
                    id: apiMailbox.mailboxId,
                    identityKey: publicKeyFromBytes(protoMailbox.identityKey),
                    label: protoMailbox.label ?? null,
                    aliases: mailboxAliases.length > 0 ? mailboxAliases : [fallbackAlias],
                    messagingKeyParams: {
                        address: protoMailbox.address,
                        protocol,
                        network: protoMailbox.network,
                        nonce: protoMailbox.nonce,
                    },
                });
            }
            catch (e) {
                console.error(`failed processing mailbox ${apiMailbox.mailboxId}`, e);
            }
        }
        return [await this.accountMailbox(), ...resultMailboxes];
    }
    async accountMailbox() {
        const { username, address } = await this.getUsername();
        const addressAlias = createMailboxAlias(createWalletAddress(username, MAILCHAIN, this.mailchainAddressDomain));
        return {
            type: 'account',
            id: address,
            identityKey: await this.accountIdentityKey(),
            label: null,
            aliases: [addressAlias],
            messagingKeyParams: {
                address: decodeAddressByProtocol(username, MAILCHAIN).decoded,
                protocol: MAILCHAIN,
                network: this.mailchainAddressDomain,
                nonce: 1,
            },
        };
    }
    async addMailbox(mailbox) {
        const consolidatedMailbox = consolidateMailbox(mailbox);
        const protoMailbox = createProtoUserMailbox(consolidatedMailbox);
        const encrypted = await this.mailboxCrypto.encrypt(user.Mailbox.encode(protoMailbox).finish());
        const { mailboxId } = await this.userApi
            .postUserMailbox({ encryptedMailboxInformation: encodeBase64(encrypted), version: CURRENT_MAILBOX_VERSION })
            .then((res) => res.data);
        return { ...consolidatedMailbox, type: 'wallet', id: mailboxId };
    }
    async updateMailbox(mailboxId, mailbox) {
        const consolidatedMailbox = consolidateMailbox(mailbox);
        const protoMailbox = createProtoUserMailbox(consolidatedMailbox);
        await this.internalUpdateMailbox(mailboxId, protoMailbox, CURRENT_MAILBOX_VERSION);
        return { id: mailboxId, type: 'wallet', ...consolidatedMailbox };
    }
    async removeMailbox(mailboxId) {
        await this.userApi.deleteUserMailbox(mailboxId);
        return;
    }
    async internalUpdateMailbox(addressId, protoMailbox, version) {
        const encrypted = await this.mailboxCrypto.encrypt(user.Mailbox.encode(protoMailbox).finish());
        await this.userApi.putUserMailbox(addressId, { encryptedMailboxInformation: encodeBase64(encrypted), version });
        return protoMailbox;
    }
}
function createProtoUserMailbox(mailbox) {
    return user.Mailbox.create({
        identityKey: publicKeyToBytes(mailbox.identityKey),
        address: mailbox.messagingKeyParams.address,
        protocol: mailbox.messagingKeyParams.protocol,
        network: mailbox.messagingKeyParams.network,
        nonce: mailbox.messagingKeyParams.nonce,
        label: mailbox.label,
        aliases: mailbox.aliases.map(createProtoAlias),
    });
}
function createProtoAlias(alias) {
    return user.Mailbox.Alias.create({
        address: formatAddress(alias.address, 'mail'),
        blockSending: !alias.allowSending,
        blockReceiving: !alias.allowReceiving,
    });
}

export { MailchainUserProfile, UserNotFoundError };
