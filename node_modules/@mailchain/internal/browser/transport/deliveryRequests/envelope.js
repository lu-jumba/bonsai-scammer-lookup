import { PrivateKeyEncrypter, ED25519PrivateKey, privateKeyToBytes, secureRandom } from '@mailchain/crypto';
import { protocol } from '../../protobuf/protocol/protocol.js';
import { createECDHKeyBundle } from './keybundle.js';

/* eslint-disable @typescript-eslint/naming-convention */
/**
 *
 * @param recipientIdentityKey this is a Mailchain identity key.
 * @param messageKey root key used to encrypt message and payload
 */
async function createEnvelope(recipientMessagingKey, messageRootEncryptionKey, messageURI, rand = secureRandom) {
    const keyBundle = await createECDHKeyBundle(recipientMessagingKey, rand);
    const encrypter = PrivateKeyEncrypter.fromPrivateKey(ED25519PrivateKey.fromSeed(keyBundle.secret), rand);
    const encryptedMessageKey = await encrypter.encrypt(privateKeyToBytes(messageRootEncryptionKey.privateKey)); //TODO: look into encoding extended keys
    const encryptedMessageURI = await encrypter.encrypt(Buffer.from(messageURI, 'utf8'));
    const payload = {
        encryptedMessageKey,
        encryptedMessageUri: encryptedMessageURI,
        ecdhKeyBundle: keyBundle.keyBundle,
    };
    const errMsg = protocol.Envelope.verify(payload);
    if (errMsg)
        throw Error(errMsg);
    return protocol.Envelope.create(payload);
}

export { createEnvelope };
