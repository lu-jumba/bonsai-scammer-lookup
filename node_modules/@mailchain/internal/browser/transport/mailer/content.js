import { publicKeyToBytes, publicKeyFromBytes } from '@mailchain/crypto';
import { encodeHex, decodeHex } from '@mailchain/encoding';
import canonicalize from 'canonicalize';

function createContentBuffer(content) {
    // fields are alphabetically ordered
    const canonicalized = canonicalize({
        authorMessagingKey: encodeHex(publicKeyToBytes(content.authorMessagingKey)),
        contentUri: content.contentUri,
        date: Math.round(content.date.getTime()),
        authorMailAddress: content.authorMailAddress.address,
        mailerProof: {
            params: {
                authorContentSignature: encodeHex(content.mailerProof.params.authorContentSignature),
                expires: Math.round(content.mailerProof.params.expires.getTime()),
                mailerMessagingKey: encodeHex(publicKeyToBytes(content.mailerProof.params.mailerMessagingKey)),
            },
            signature: encodeHex(content.mailerProof.signature),
            version: content.mailerProof.version,
        },
        messageId: content.messageId,
        to: content.to.map((recipient) => recipient.address),
        version: content.version,
    });
    if (!canonicalized) {
        throw new Error('content could not be canonicalized');
    }
    return canonicalized;
}
function parseMailerContentFromJSON(content) {
    const rawMailerContent = JSON.parse(content);
    if (!rawMailerContent.mailerProof) {
        throw new Error('mailerProof is required');
    }
    if (!rawMailerContent.mailerProof.params) {
        throw new Error('mailerProof.params is required');
    }
    if (rawMailerContent.mailerProof.params.authorContentSignature === '') {
        throw new Error('authorContentSignature is required');
    }
    const authorContentSignature = decodeHex(rawMailerContent.mailerProof.params.authorContentSignature);
    if (rawMailerContent.authorMessagingKey === '') {
        throw new Error('authorMessagingKey is required');
    }
    const authorMessagingKey = publicKeyFromBytes(decodeHex(rawMailerContent.authorMessagingKey));
    return {
        authorMessagingKey,
        contentUri: rawMailerContent.contentUri,
        date: new Date(rawMailerContent.date),
        authorMailAddress: { address: rawMailerContent.authorMailAddress, name: '' },
        to: rawMailerContent.to.map((address) => ({ address, name: '' })),
        mailerProof: {
            params: {
                expires: new Date(rawMailerContent.mailerProof.params.expires),
                mailerMessagingKey: publicKeyFromBytes(decodeHex(rawMailerContent.mailerProof.params.mailerMessagingKey)),
                authorContentSignature,
            },
            signature: decodeHex(rawMailerContent.mailerProof.signature),
            version: rawMailerContent.version,
        },
        messageId: rawMailerContent.messageId,
        version: rawMailerContent.version,
    };
}

export { createContentBuffer, parseMailerContentFromJSON };
