import { publicKeyToBytes, publicKeyFromBytes } from '@mailchain/crypto';
import { encodeHex, decodeHex } from '@mailchain/encoding';
import canonicalize from 'canonicalize';

function createMailerProofBuffer(mailerProof) {
    // fields are alphabetically ordered
    const canonicalized = canonicalize({
        params: {
            authorContentSignature: encodeHex(mailerProof.params.authorContentSignature),
            expires: Math.round(mailerProof.params.expires.getTime()),
            mailerMessagingKey: encodeHex(publicKeyToBytes(mailerProof.params.mailerMessagingKey)),
        },
        signature: encodeHex(mailerProof.signature),
        version: mailerProof.version,
    });
    if (!canonicalized) {
        throw new Error('content could not be canonicalized');
    }
    return canonicalized;
}
function parseMailerProofFromJSON(content) {
    const rawRawMailerProof = JSON.parse(content);
    if (!rawRawMailerProof.params) {
        throw new Error('mailerProof.params is required');
    }
    if (rawRawMailerProof.params.authorContentSignature === '') {
        throw new Error('authorContentSignature is required');
    }
    const authorContentSignature = decodeHex(rawRawMailerProof.params.authorContentSignature);
    if (rawRawMailerProof.params.mailerMessagingKey === '') {
        throw new Error('mailerMessagingKey is required');
    }
    return {
        params: {
            expires: new Date(rawRawMailerProof.params.expires),
            mailerMessagingKey: publicKeyFromBytes(decodeHex(rawRawMailerProof.params.mailerMessagingKey)),
            authorContentSignature,
        },
        signature: decodeHex(rawRawMailerProof.signature),
        version: rawRawMailerProof.version,
    };
}

export { createMailerProofBuffer, parseMailerProofFromJSON };
