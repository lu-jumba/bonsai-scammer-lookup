import { deriveHardenedKey, secureRandom, PrivateKeyEncrypter } from '@mailchain/crypto';
import { chunkBuffer, CHUNK_LENGTH_1MB } from './chunk.js';

/**
 * Encrypts a payload
 *
 * @param input
 * @param payloadRootKey is used to derive a separate key for the headers and each part of the message
 * @param chunkSize approx 1mb
 * @returns
 */
async function encryptPayload(headers, content, payloadRootKey, chunkSize = CHUNK_LENGTH_1MB, rand = secureRandom) {
    const chunks = chunkBuffer(content, chunkSize);
    const encryptedContentChunks = await encryptChunks(chunks, payloadRootKey, rand);
    const headersEncryptionKey = deriveHardenedKey(payloadRootKey, 'headers');
    const encryptedHeaders = await encryptBuffer(headers, headersEncryptionKey.privateKey, rand);
    return {
        EncryptedHeaders: encryptedHeaders,
        EncryptedContentChunks: encryptedContentChunks,
    };
}
/**
 * Encrypts each chunk with a different key derived from payloadRootKey
 * @param chunks chunks of max 1mb to encrypt
 * @param payloadRootKey root key used to derive encryption keys for each chunk
 * @returns list of encrypted chunks
 */
async function encryptChunks(chunks, payloadRootKey, rand = secureRandom) {
    const encryptedChunks = new Array(chunks.length);
    const contentRootKey = deriveHardenedKey(payloadRootKey, 'content');
    for (let i = 0; i < chunks.length; i++) {
        const chunkKey = deriveHardenedKey(contentRootKey, i);
        encryptedChunks[i] = await encryptBuffer(chunks[i], chunkKey.privateKey, rand);
    }
    return encryptedChunks;
}
async function encryptBuffer(buffer, key, rand = secureRandom) {
    const encrypted = await PrivateKeyEncrypter.fromPrivateKey(key, rand).encrypt(buffer);
    return Buffer.from(encrypted);
}

export { encryptBuffer, encryptChunks, encryptPayload };
