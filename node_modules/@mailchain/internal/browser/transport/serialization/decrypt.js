import { deriveHardenedKey, PrivateKeyDecrypter } from '@mailchain/crypto';

/**
 * Decrypt a payload
 *
 * @param input
 * @param payloadRootKey is used to derive a separate key for the headers and each part of the message
 * @returns
 */
async function decryptPayload(input, payloadRootKey) {
    const decryptedContentChunks = await decryptChunks(input.EncryptedContentChunks, payloadRootKey);
    const headersEncryptionKey = deriveHardenedKey(payloadRootKey, 'headers');
    const decryptedHeaders = await decryptBuffer(input.EncryptedHeaders, headersEncryptionKey.privateKey);
    return {
        headers: decryptedHeaders,
        content: Buffer.concat(decryptedContentChunks),
    };
}
/**
 * Decrypt each chunk with the key derived from payloadRootKey
 * @param chunks chunks of max 1mb to decrypt
 * @param payloadRootKey root key used to derive encryption keys for each chunk
 * @returns list of decrypted chunks
 */
async function decryptChunks(chunks, payloadRootKey) {
    const decryptedChunks = new Array(chunks.length);
    const contentRootKey = deriveHardenedKey(payloadRootKey, 'content');
    for (let i = 0; i < chunks.length; i++) {
        const chunkKey = deriveHardenedKey(contentRootKey, i);
        decryptedChunks[i] = await decryptBuffer(chunks[i], chunkKey.privateKey);
    }
    return decryptedChunks;
}
async function decryptBuffer(buffer, key) {
    if (buffer.length === 0) {
        throw new Error('can not decrypt empty data');
    }
    const decrypted = await PrivateKeyDecrypter.fromPrivateKey(key).decrypt(buffer);
    return Buffer.from(decrypted);
}

export { decryptBuffer, decryptChunks, decryptPayload };
