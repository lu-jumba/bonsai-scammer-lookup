import { publicKeyToBytes } from '@mailchain/crypto';
import { encodeHexZeroX } from '@mailchain/encoding';
import { isBlockchainProtocolEnabled } from '@mailchain/addressing/protocols';
import { ecdhKeyRingDecrypter } from '@mailchain/keyring/functions';
import { createAxiosConfiguration, MessagingKeysApiFactory, getAxiosWithSigner, ApiKeyConvert } from '@mailchain/api';
import uniqBy from 'lodash/uniqBy';
import { encodeAddressByProtocol } from '@mailchain/addressing';
import { IdentityKeys } from '../identityKeys/identityKeys.js';

class PreviousMessageSync {
    constructor(identityKeys, messagingKeysApiFactory, keyRing, messageSync) {
        Object.defineProperty(this, "identityKeys", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: identityKeys
        });
        Object.defineProperty(this, "messagingKeysApiFactory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKeysApiFactory
        });
        Object.defineProperty(this, "keyRing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: keyRing
        });
        Object.defineProperty(this, "messageSync", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messageSync
        });
    }
    static create(sdkConfig, keyRing, messageSync) {
        const axiosConfig = createAxiosConfiguration(sdkConfig.apiPath);
        return new PreviousMessageSync(IdentityKeys.create(sdkConfig), (messagingKey) => MessagingKeysApiFactory(axiosConfig, undefined, getAxiosWithSigner(messagingKey)), keyRing, messageSync);
    }
    async sync(mailbox) {
        const messagingKeysApi = this.messagingKeysApiFactory(this.keyRing.addressMessagingKey(encodeAddressByProtocol(mailbox.messagingKeyParams.address, mailbox.messagingKeyParams.protocol)
            .encoded, mailbox.messagingKeyParams.protocol, mailbox.messagingKeyParams.nonce));
        const encodedIdentityKey = encodeHexZeroX(publicKeyToBytes(mailbox.identityKey));
        const addresses = await this.identityKeys.reverse(mailbox.identityKey);
        // add all address found by identity key and also registered
        const allAddresses = uniqBy([
            ...addresses.map((x) => ({
                protocol: x.protocol,
                address: x.value,
            })),
            ...mailbox.aliases.map((x) => ({
                address: x.address.username,
                protocol: mailbox.messagingKeyParams.protocol,
            })),
        ], (x) => x.address + x.protocol);
        // type Address
        // const aliasMessagingKeyss: [Address, PrivateKey][] = [];
        const aliasMessagingKeys = await Promise.allSettled(allAddresses.map(async (x) => {
            if (!isBlockchainProtocolEnabled(x.protocol)) {
                throw new Error(`unsupported protocol of [${x.protocol}] for [${x.address}]`);
            }
            // TODO: https://github.com/mailchain/monorepo/issues/405, the private key should be invalidated at the end of the sync
            const { privateKey: apiPrivateKey } = await messagingKeysApi
                .getVendedPrivateMessagingKey(x.address, x.protocol, encodedIdentityKey)
                .then((r) => r.data);
            return { address: x, messagingKey: ApiKeyConvert.private(apiPrivateKey) };
        }));
        const filteredAliasMessagingKeys = [];
        aliasMessagingKeys.forEach((x) => {
            if (x.status === 'fulfilled') {
                filteredAliasMessagingKeys.push(x.value);
            }
        });
        const results = [];
        for (const x of filteredAliasMessagingKeys) {
            const { address, messagingKey } = x;
            const tmpResult = await this.messageSync.syncWithMessagingKey(mailbox, ecdhKeyRingDecrypter(messagingKey));
            results.push({ ...tmpResult, address });
        }
        return results;
    }
}

export { PreviousMessageSync };
