import { formatAddress } from '@mailchain/addressing';
import { publicKeyFromBytes, publicKeyToBytes } from '@mailchain/crypto';
import axios from 'axios';
import { createAxiosConfiguration, AddressesApiFactory, IdentityKeysApiFactory } from '@mailchain/api';
import { decodeHexZeroX, encodeHexZeroX } from '@mailchain/encoding';

class IdentityKeys {
    constructor(addressesApi, identityKeyApi) {
        Object.defineProperty(this, "addressesApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: addressesApi
        });
        Object.defineProperty(this, "identityKeyApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: identityKeyApi
        });
    }
    static create(config) {
        const axiosConfig = createAxiosConfiguration(config.apiPath);
        return new IdentityKeys(AddressesApiFactory(axiosConfig), IdentityKeysApiFactory(axiosConfig));
    }
    async getAddressIdentityKey(address) {
        return this.resolve(formatAddress(address, 'mail'));
    }
    async resolve(address) {
        return this.addressesApi
            .getAddressIdentityKey(address)
            .then(({ data }) => ({
            identityKey: publicKeyFromBytes(decodeHexZeroX(data.identityKey)),
            protocol: data.protocol,
        }))
            .catch((e) => {
            if (axios.isAxiosError(e)) {
                if (e.response?.data.code === 'identity_not_found') {
                    return null;
                }
                else if (e.response?.status === 404) {
                    return null;
                }
            }
            throw e;
        });
    }
    async reverse(identityKey) {
        const { addresses } = (await this.identityKeyApi.getIdentityKeyAddresses(encodeHexZeroX(publicKeyToBytes(identityKey)))).data;
        return addresses;
    }
}

export { IdentityKeys };
