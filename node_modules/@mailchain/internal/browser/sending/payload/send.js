import { ED25519ExtendedPrivateKey, ED25519PrivateKey } from '@mailchain/crypto';
import { TransportApiFactory, getAxiosWithSigner } from '@mailchain/api';
import { UnexpectedMailchainError } from '../../messagingKeys/errors.js';
import { serializeAndEncryptPayload } from '../../transport/payload/payload.js';

class PayloadSender {
    constructor(transportApi) {
        Object.defineProperty(this, "transportApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: transportApi
        });
    }
    static create(configuration, accountKeySigner) {
        return new PayloadSender(TransportApiFactory(configuration, undefined, getAxiosWithSigner(accountKeySigner)));
    }
    /**
     * Encrypt the payload with ephemeral key and deliver it to the storage nodes.
     * @returns the URL to get the message from the and ephemeral key used for the encryption of it
     */
    async sendPayload(payload) {
        try {
            // create root encryption key that will be used to encrypt message content.
            const payloadRootEncryptionKey = ED25519ExtendedPrivateKey.fromPrivateKey(ED25519PrivateKey.generate());
            const serializedContent = await serializeAndEncryptPayload(payload, payloadRootEncryptionKey);
            const { uri: payloadUri } = await this.transportApi
                .postEncryptedPayload(serializedContent)
                .then((r) => r.data);
            return {
                data: {
                    payloadUri,
                    payloadRootEncryptionKey,
                },
            };
        }
        catch (error) {
            return {
                error: new UnexpectedMailchainError('failed to send payload', error),
            };
        }
    }
}

export { PayloadSender };
