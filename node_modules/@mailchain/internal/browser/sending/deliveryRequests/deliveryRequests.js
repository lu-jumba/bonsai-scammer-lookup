import { publicKeyToBytes } from '@mailchain/crypto';
import { encodeBase64, encodeHexZeroX } from '@mailchain/encoding';
import { TransportApiFactory, createAxiosConfiguration, getAxiosWithSigner } from '@mailchain/api';
import { protocol } from '../../protobuf/protocol/protocol.js';
import { partitionMailchainResults } from '../../mailchainResult.js';
import { createDelivery } from '../../transport/deliveryRequests/delivery.js';

class SomeDeliveryRequestsFailedError extends Error {
    constructor(successes, failures) {
        super(`Not all delivery requests were successfully sent. Check the failed delivery requests to retry failed requests.`);
        Object.defineProperty(this, "successes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: successes
        });
        Object.defineProperty(this, "failures", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: failures
        });
    }
}
class SendDeliveryRequestTransportError extends Error {
    constructor(cause, params) {
        super('failed sending delivery request', { cause });
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: params
        });
    }
}
class DeliveryRequests {
    constructor(transportApi) {
        Object.defineProperty(this, "transportApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: transportApi
        });
    }
    static create(configuration, sender) {
        return new DeliveryRequests(TransportApiFactory(createAxiosConfiguration(configuration.apiPath), undefined, getAxiosWithSigner(sender)));
    }
    /**
     * Send the same payload delivery request to multiple recipients
     */
    async sendManyDeliveryRequests(params) {
        const { recipients, payloadUri, payloadRootEncryptionKey } = params;
        const results = await Promise.all(recipients.map(async (recipientMessageKey) => {
            const sendDeliveryRequestParams = {
                recipientMessageKey,
                payloadUri,
                payloadRootEncryptionKey,
            };
            const result = await this.sendDeliveryRequest(sendDeliveryRequestParams);
            return { result, params: sendDeliveryRequestParams };
        }));
        const { successes: sent, failures: failed } = partitionMailchainResults(results);
        if (failed.length > 0) {
            return {
                error: new SomeDeliveryRequestsFailedError(sent, failed),
            };
        }
        return {
            data: sent.map((s) => s.data),
        };
    }
    /**
     * Create delivery request for the recipient of the message providing the key used to encrypt the payload.
     *
     * @param recipientMessageKey the key of the message
     * @param messageUri the URL to get the message from
     * @param payloadRootEncryptionKey the root ephemeral key used to encrypt the Payload
     */
    async sendDeliveryRequest(params) {
        const { recipientMessageKey, payloadRootEncryptionKey, payloadUri } = params;
        const deliveryCreated = await createDelivery(recipientMessageKey, payloadRootEncryptionKey, payloadUri);
        try {
            const { deliveryRequestID: deliveryRequestId } = await this.transportApi
                .postDeliveryRequest({
                encryptedDeliveryRequest: encodeBase64(protocol.Delivery.encode(deliveryCreated).finish()),
                recipientMessagingKey: encodeHexZeroX(publicKeyToBytes(recipientMessageKey)),
            })
                .then((response) => response.data);
            return { data: { deliveryRequestId, recipientMessageKey } };
        }
        catch (e) {
            return {
                error: new SendDeliveryRequestTransportError(e, params),
            };
        }
    }
}

export { DeliveryRequests, SendDeliveryRequestTransportError, SomeDeliveryRequestsFailedError };
