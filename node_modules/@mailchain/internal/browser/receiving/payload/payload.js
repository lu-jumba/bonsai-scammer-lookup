import { decodeBase64 } from '@mailchain/encoding';
import axios from 'axios';
import { PayloadOriginVerifier } from '../../transport/payload/verifier.js';
import { SerializableTransportPayloadHeaders } from '../../transport/payload/headers.js';
import { DeliveryRequests } from '../deliveryRequests/deliveryRequests.js';
import { deserialize } from '../../transport/serialization/serialization.js';
import { decryptPayload } from '../../transport/serialization/decrypt.js';

class PayloadReceiver {
    constructor(deliveryRequests, payloadOriginVerifier, axiosInstance) {
        Object.defineProperty(this, "deliveryRequests", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: deliveryRequests
        });
        Object.defineProperty(this, "payloadOriginVerifier", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: payloadOriginVerifier
        });
        Object.defineProperty(this, "axiosInstance", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: axiosInstance
        });
    }
    static create(configuration, receiverMessagingKeyDecrypter, axiosInstance = axios.create()) {
        return new PayloadReceiver(DeliveryRequests.create(configuration, receiverMessagingKeyDecrypter), PayloadOriginVerifier.create(), axiosInstance);
    }
    async getUndelivered() {
        const deliveryRequests = await this.deliveryRequests.getUndelivered();
        return Promise.all(deliveryRequests.map(async (result) => {
            switch (result.status) {
                case 'success':
                    const payloadResponse = await this.get(result.payloadRootEncryptionKey, result.payloadUri);
                    return processReceivedPayload(payloadResponse, result.deliveryRequestHash);
                case 'failure':
                    return {
                        cause: result.cause,
                        deliveryRequestHash: result.deliveryRequestHash,
                        status: 'error-delivery-request',
                    };
            }
        }));
    }
    async get(payloadRootEncryptionKey, payloadUri) {
        try {
            const encryptedMessageBodyResponse = await this.axiosInstance.get(payloadUri, {
                responseType: 'arraybuffer',
            });
            const encryptedMessageBody = Buffer.from(decodeBase64(encryptedMessageBodyResponse.data));
            const encryptedPayload = deserialize(encryptedMessageBody);
            const { headers, content } = await decryptPayload(encryptedPayload, payloadRootEncryptionKey);
            const payload = {
                Headers: SerializableTransportPayloadHeaders.FromBuffer(headers).headers,
                Content: content,
            };
            await this.payloadOriginVerifier.verifyPayloadOrigin(payload);
            return {
                status: 'success',
                payload,
            };
        }
        catch (error) {
            return {
                status: 'failure',
                cause: error,
            };
        }
    }
}
function processReceivedPayload(payloadResponse, deliveryRequestHash) {
    switch (payloadResponse.status) {
        case 'success':
            return {
                status: 'success',
                payload: payloadResponse.payload,
                deliveryRequestHash,
            };
        case 'failure':
            return {
                status: 'error-payload',
                cause: payloadResponse.cause,
                deliveryRequestHash,
            };
        default:
            return {
                status: 'error-payload',
                cause: new Error('Unknown payload response status'),
                deliveryRequestHash,
            };
    }
}

export { PayloadReceiver };
