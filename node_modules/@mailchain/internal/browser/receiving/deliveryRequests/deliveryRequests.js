import { TransportApiFactory, createAxiosConfiguration, getAxiosWithSigner } from '@mailchain/api';
import { publicKeyFromBytes, ED25519ExtendedPrivateKey, privateKeyFromBytes } from '@mailchain/crypto';
import { encodeHexZeroX, decodeBase64, decodeHexZeroX, encodeUtf8 } from '@mailchain/encoding';
import { signMailchainDeliveryConfirmation } from '@mailchain/signatures';
import { protocol } from '../../protobuf/protocol/protocol.js';

class DeliveryRequests {
    constructor(transportApi, messagingKey) {
        Object.defineProperty(this, "transportApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: transportApi
        });
        Object.defineProperty(this, "messagingKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKey
        });
    }
    static create(configuration, receiverMessagingKeyDecrypter) {
        return new DeliveryRequests(TransportApiFactory(createAxiosConfiguration(configuration.apiPath), undefined, getAxiosWithSigner(receiverMessagingKeyDecrypter)), receiverMessagingKeyDecrypter);
    }
    async confirmDelivery(hash) {
        const signature = await signMailchainDeliveryConfirmation(this.messagingKey, hash);
        await this.transportApi.putDeliveryRequestConfirmation(encodeHexZeroX(hash), {
            signature: encodeHexZeroX(signature),
        });
    }
    async getUndelivered() {
        const processed = this.transportApi.getDeliveryRequests().then(({ data: { deliveryRequests } }) => {
            return Promise.all(deliveryRequests.map((dr) => {
                const delivery = protocol.Delivery.decode(decodeBase64(dr.data));
                return this.processDeliveryRequest(this.messagingKey, delivery, decodeHexZeroX(dr.hash));
            }));
        });
        return processed;
    }
    async processDeliveryRequest(messagingKey, delivery, deliveryRequestHash) {
        try {
            const { envelope } = delivery;
            if (!envelope) {
                throw new Error('envelope is undefined');
            }
            const { ecdhKeyBundle, encryptedMessageKey, encryptedMessageUri } = envelope;
            if (!ecdhKeyBundle) {
                throw new Error('envelope does not contain ECDH key bundle');
            }
            if (!encryptedMessageKey) {
                throw new Error('envelope does not contain encryptedMessageKey');
            }
            if (!encryptedMessageUri) {
                throw new Error('envelope does not contain encryptedMessageUri');
            }
            if (!ecdhKeyBundle.publicEphemeralKey) {
                throw new Error('ECDH key bundle does not contain publicEphemeralKey');
            }
            const payloadRootEncryptionKeyBytes = await messagingKey.ecdhDecrypt(publicKeyFromBytes(ecdhKeyBundle.publicEphemeralKey), encryptedMessageKey);
            if (payloadRootEncryptionKeyBytes.length === 0) {
                throw new Error('payloadRootEncryptionKey is empty');
            }
            const payloadRootEncryptionKey = ED25519ExtendedPrivateKey.fromPrivateKey(privateKeyFromBytes(payloadRootEncryptionKeyBytes));
            const payloadUriBytes = await messagingKey.ecdhDecrypt(publicKeyFromBytes(ecdhKeyBundle.publicEphemeralKey), encryptedMessageUri);
            if (payloadUriBytes.length === 0) {
                throw new Error('payloadUri is empty');
            }
            const payloadUri = encodeUtf8(payloadUriBytes);
            return {
                status: 'success',
                payloadRootEncryptionKey,
                payloadUri,
                deliveryRequestHash,
            };
        }
        catch (error) {
            return {
                status: 'failure',
                cause: error,
                deliveryRequestHash,
            };
        }
    }
}

export { DeliveryRequests };
