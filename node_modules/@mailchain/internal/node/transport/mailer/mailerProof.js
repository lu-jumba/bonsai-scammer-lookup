'use strict';

var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');
var canonicalize = require('canonicalize');

function createMailerProofBuffer(mailerProof) {
    // fields are alphabetically ordered
    const canonicalized = canonicalize({
        params: {
            authorContentSignature: encoding.encodeHex(mailerProof.params.authorContentSignature),
            expires: Math.round(mailerProof.params.expires.getTime()),
            mailerMessagingKey: encoding.encodeHex(crypto.publicKeyToBytes(mailerProof.params.mailerMessagingKey)),
        },
        signature: encoding.encodeHex(mailerProof.signature),
        version: mailerProof.version,
    });
    if (!canonicalized) {
        throw new Error('content could not be canonicalized');
    }
    return canonicalized;
}
function parseMailerProofFromJSON(content) {
    const rawRawMailerProof = JSON.parse(content);
    if (!rawRawMailerProof.params) {
        throw new Error('mailerProof.params is required');
    }
    if (rawRawMailerProof.params.authorContentSignature === '') {
        throw new Error('authorContentSignature is required');
    }
    const authorContentSignature = encoding.decodeHex(rawRawMailerProof.params.authorContentSignature);
    if (rawRawMailerProof.params.mailerMessagingKey === '') {
        throw new Error('mailerMessagingKey is required');
    }
    return {
        params: {
            expires: new Date(rawRawMailerProof.params.expires),
            mailerMessagingKey: crypto.publicKeyFromBytes(encoding.decodeHex(rawRawMailerProof.params.mailerMessagingKey)),
            authorContentSignature,
        },
        signature: encoding.decodeHex(rawRawMailerProof.signature),
        version: rawRawMailerProof.version,
    };
}

exports.createMailerProofBuffer = createMailerProofBuffer;
exports.parseMailerProofFromJSON = parseMailerProofFromJSON;
