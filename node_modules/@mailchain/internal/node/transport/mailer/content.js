'use strict';

var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');
var canonicalize = require('canonicalize');

function createContentBuffer(content) {
    // fields are alphabetically ordered
    const canonicalized = canonicalize({
        authorMessagingKey: encoding.encodeHex(crypto.publicKeyToBytes(content.authorMessagingKey)),
        contentUri: content.contentUri,
        date: Math.round(content.date.getTime()),
        authorMailAddress: content.authorMailAddress.address,
        mailerProof: {
            params: {
                authorContentSignature: encoding.encodeHex(content.mailerProof.params.authorContentSignature),
                expires: Math.round(content.mailerProof.params.expires.getTime()),
                mailerMessagingKey: encoding.encodeHex(crypto.publicKeyToBytes(content.mailerProof.params.mailerMessagingKey)),
            },
            signature: encoding.encodeHex(content.mailerProof.signature),
            version: content.mailerProof.version,
        },
        messageId: content.messageId,
        to: content.to.map((recipient) => recipient.address),
        version: content.version,
    });
    if (!canonicalized) {
        throw new Error('content could not be canonicalized');
    }
    return canonicalized;
}
function parseMailerContentFromJSON(content) {
    const rawMailerContent = JSON.parse(content);
    if (!rawMailerContent.mailerProof) {
        throw new Error('mailerProof is required');
    }
    if (!rawMailerContent.mailerProof.params) {
        throw new Error('mailerProof.params is required');
    }
    if (rawMailerContent.mailerProof.params.authorContentSignature === '') {
        throw new Error('authorContentSignature is required');
    }
    const authorContentSignature = encoding.decodeHex(rawMailerContent.mailerProof.params.authorContentSignature);
    if (rawMailerContent.authorMessagingKey === '') {
        throw new Error('authorMessagingKey is required');
    }
    const authorMessagingKey = crypto.publicKeyFromBytes(encoding.decodeHex(rawMailerContent.authorMessagingKey));
    return {
        authorMessagingKey,
        contentUri: rawMailerContent.contentUri,
        date: new Date(rawMailerContent.date),
        authorMailAddress: { address: rawMailerContent.authorMailAddress, name: '' },
        to: rawMailerContent.to.map((address) => ({ address, name: '' })),
        mailerProof: {
            params: {
                expires: new Date(rawMailerContent.mailerProof.params.expires),
                mailerMessagingKey: crypto.publicKeyFromBytes(encoding.decodeHex(rawMailerContent.mailerProof.params.mailerMessagingKey)),
                authorContentSignature,
            },
            signature: encoding.decodeHex(rawMailerContent.mailerProof.signature),
            version: rawMailerContent.version,
        },
        messageId: rawMailerContent.messageId,
        version: rawMailerContent.version,
    };
}

exports.createContentBuffer = createContentBuffer;
exports.parseMailerContentFromJSON = parseMailerContentFromJSON;
