'use strict';

var headers = require('../serialization/headers.js');

const HEADER_CONTENT_ENCODING = 'Content-Encoding';
const HEADER_CONTENT_ENCRYPTION = 'Content-Encryption';
const HEADER_CONTENT_LENGTH = 'Content-Length';
const HEADER_CONTENT_LOCATION = 'Content-Location';
const HEADER_CONTENT_SIGNATURE = 'Content-Signature';
const HEADER_CONTENT_TYPE = 'Content-Type';
const HEADER_CREATED = 'Created';
const HEADER_ORIGIN = 'Origin';
class SerializableTransportPayloadHeaders {
    constructor(headers) {
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.headers = headers;
    }
    static FromEncryptedPayloadHeaders(headers) {
        return new this(headers);
    }
    static FromBuffer(buffer) {
        const { headers: headers$1, invalidHeaders: _invalidHeaders } = headers.headersMapFromBuffers(buffer, [
            HEADER_CONTENT_ENCODING,
            HEADER_CONTENT_ENCRYPTION,
            HEADER_CONTENT_LENGTH,
            HEADER_CONTENT_SIGNATURE,
            HEADER_CONTENT_TYPE,
            HEADER_CREATED,
            HEADER_ORIGIN,
        ]);
        return new this({
            ContentEncoding: headers$1.get(HEADER_CONTENT_ENCODING).toString(),
            ContentEncryption: headers$1.get(HEADER_CONTENT_ENCRYPTION).toString(),
            ContentLength: Number.parseInt(headers$1.get(HEADER_CONTENT_LENGTH).toString()),
            ContentSignature: headers.parseSignatureHeader(headers$1.get(HEADER_CONTENT_SIGNATURE).toString()),
            ContentType: headers$1.get(HEADER_CONTENT_TYPE).toString(),
            Created: new Date(headers$1.get(HEADER_CREATED).toString()),
            Origin: headers.parseOriginHeader(headers$1.get(HEADER_ORIGIN).toString()),
        });
    }
    ToBuffer() {
        const headers$1 = [];
        headers$1.push(`${HEADER_CONTENT_ENCODING}: ${this.headers.ContentEncoding}`);
        headers$1.push(`${HEADER_CONTENT_ENCRYPTION}: ${this.headers.ContentEncryption}`);
        headers$1.push(`${HEADER_CONTENT_LENGTH}: ${this.headers.ContentLength}`);
        if (this.headers.ContentLocation) {
            headers$1.push(`${HEADER_CONTENT_LOCATION}: ${this.headers.ContentLocation}`);
        }
        headers$1.push(`${HEADER_CONTENT_SIGNATURE}: ${headers.createSignatureHeader(this.headers.ContentSignature, this.headers.Origin)}`);
        headers$1.push(`${HEADER_CONTENT_TYPE}: ${this.headers.ContentType}`);
        headers$1.push(`${HEADER_CREATED}: ${this.headers.Created.toISOString()}`);
        headers$1.push(`${HEADER_ORIGIN}: ${headers.createOriginHeader(this.headers.Origin)}`);
        return Buffer.from(headers$1.join('\r\n'), 'utf8');
    }
}

exports.SerializableTransportPayloadHeaders = SerializableTransportPayloadHeaders;
