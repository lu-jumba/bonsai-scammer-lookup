'use strict';

var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');

function parseHeaderElements(input, requiredKeys) {
    const attributes = new Map();
    input.split(';').forEach((item) => {
        const parts = item.split('=', 2);
        if (parts.length !== 2) ;
        attributes.set(parts[0].trim(), parts[1].trim());
    });
    requiredKeys.forEach((item) => {
        if (!attributes.get(item)) {
            throw new Error(`missing header attribute '${item}'`);
        }
    });
    return attributes;
}
function parseSignatureHeader(input) {
    const attributes = parseHeaderElements(input, ['data']);
    const sig = encoding.decodeBase64(attributes.get('data').toString());
    if (sig.length === 0) {
        throw new Error('could not decode signature');
    }
    return sig;
}
function createSignatureHeader(signature, signer) {
    const values = [];
    values.push(`data=${encoding.encodeBase64(signature)}`);
    values.push(`alg=${crypto.kindFromPublicKey(signer)}`);
    return values.join('; ').trimEnd();
}
function parseOriginHeader(input) {
    const attributes = parseHeaderElements(input, ['data', 'alg']);
    const bytes = encoding.decodeBase64(attributes.get('data').toString());
    return crypto.publicKeyFromKind(attributes.get('alg').toString(), bytes);
}
function createOriginHeader(signer) {
    const values = [];
    values.push(`data=${encoding.encodeBase64(signer.bytes)}`);
    values.push(`alg=${crypto.kindFromPublicKey(signer)}`);
    return values.join('; ').trimEnd();
}
function headersMapFromBuffers(buffer, requiredHeaders) {
    const { headers, invalidHeaders } = buffer
        .toString('utf8')
        .split('\r\n')
        .reduce((result, line) => {
        if (line.indexOf(':') === -1) {
            // splitting on ":" causes problem with dates
            result.invalidHeaders.push(line);
        }
        result.headers.set(line.slice(0, line.indexOf(':')).trim(), line.slice(line.indexOf(':') + 1).trim());
        return result;
    }, { headers: new Map(), invalidHeaders: [] });
    const missingHeaders = requiredHeaders.filter((x) => !headers.has(x));
    if (missingHeaders.length > 0) {
        throw new Error(`missing header(s) ${missingHeaders}`);
    }
    return { headers, invalidHeaders };
}

exports.createOriginHeader = createOriginHeader;
exports.createSignatureHeader = createSignatureHeader;
exports.headersMapFromBuffers = headersMapFromBuffers;
exports.parseHeaderElements = parseHeaderElements;
exports.parseOriginHeader = parseOriginHeader;
exports.parseSignatureHeader = parseSignatureHeader;
