'use strict';

var crypto = require('@mailchain/crypto');
var chunk = require('./chunk.js');

/**
 * Encrypts a payload
 *
 * @param input
 * @param payloadRootKey is used to derive a separate key for the headers and each part of the message
 * @param chunkSize approx 1mb
 * @returns
 */
async function encryptPayload(headers, content, payloadRootKey, chunkSize = chunk.CHUNK_LENGTH_1MB, rand = crypto.secureRandom) {
    const chunks = chunk.chunkBuffer(content, chunkSize);
    const encryptedContentChunks = await encryptChunks(chunks, payloadRootKey, rand);
    const headersEncryptionKey = crypto.deriveHardenedKey(payloadRootKey, 'headers');
    const encryptedHeaders = await encryptBuffer(headers, headersEncryptionKey.privateKey, rand);
    return {
        EncryptedHeaders: encryptedHeaders,
        EncryptedContentChunks: encryptedContentChunks,
    };
}
/**
 * Encrypts each chunk with a different key derived from payloadRootKey
 * @param chunks chunks of max 1mb to encrypt
 * @param payloadRootKey root key used to derive encryption keys for each chunk
 * @returns list of encrypted chunks
 */
async function encryptChunks(chunks, payloadRootKey, rand = crypto.secureRandom) {
    const encryptedChunks = new Array(chunks.length);
    const contentRootKey = crypto.deriveHardenedKey(payloadRootKey, 'content');
    for (let i = 0; i < chunks.length; i++) {
        const chunkKey = crypto.deriveHardenedKey(contentRootKey, i);
        encryptedChunks[i] = await encryptBuffer(chunks[i], chunkKey.privateKey, rand);
    }
    return encryptedChunks;
}
async function encryptBuffer(buffer, key, rand = crypto.secureRandom) {
    const encrypted = await crypto.PrivateKeyEncrypter.fromPrivateKey(key, rand).encrypt(buffer);
    return Buffer.from(encrypted);
}

exports.encryptBuffer = encryptBuffer;
exports.encryptChunks = encryptChunks;
exports.encryptPayload = encryptPayload;
