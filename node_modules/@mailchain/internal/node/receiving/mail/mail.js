'use strict';

var axios = require('axios');
var mailer = require('../mailer/mailer.js');
var payload = require('../payload/payload.js');
var deliveryRequests = require('../deliveryRequests/deliveryRequests.js');

/**
 * Receive mail from the Mailchain network.
 */
class MailReceiver {
    constructor(deliveryRequests, mailerReceiver, payloadReceiver) {
        Object.defineProperty(this, "deliveryRequests", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: deliveryRequests
        });
        Object.defineProperty(this, "mailerReceiver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: mailerReceiver
        });
        Object.defineProperty(this, "payloadReceiver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: payloadReceiver
        });
    }
    static create(configuration, receiverMessagingKeyDecrypter, axiosInstance = axios.create()) {
        return new MailReceiver(deliveryRequests.DeliveryRequests.create(configuration, receiverMessagingKeyDecrypter), mailer.MailerContentResolver.create(configuration, axiosInstance), payload.PayloadReceiver.create(configuration, receiverMessagingKeyDecrypter, axiosInstance));
    }
    /**
     * Confirm the delivery of a mail has been completed.
     * @param hash of the delivery request.
     */
    async confirmDelivery(deliveryRequestHash) {
        await this.deliveryRequests.confirmDelivery(deliveryRequestHash);
    }
    /**
     * Get all undelivered mail.
     * @returns the mail that has been received.
     */
    async getUndelivered() {
        const undeliveredPayloads = await this.payloadReceiver.getUndelivered();
        return Promise.all(undeliveredPayloads.map(async (result) => {
            switch (result.status) {
                case 'success':
                    return {
                        status: 'success',
                        payload: await this.processReceivedPayload(result.payload),
                        deliveryRequestHash: result.deliveryRequestHash,
                    };
                case 'error-payload':
                    return {
                        status: 'failure',
                        cause: result.cause,
                    };
                case 'error-delivery-request':
                    return {
                        status: 'failure',
                        cause: result.cause,
                    };
                default:
                    return {
                        status: 'failure',
                        cause: new Error('unknown status'),
                    };
            }
        }));
    }
    /**
     * creates the mail content from the payload.
     * @param payload the decrypted payload received from the network.
     * @returns
     */
    async processReceivedPayload(payload) {
        switch (payload.Headers.ContentType) {
            case 'message/x.mailchain':
                return payload;
            case 'message/x.mailchain-mailer':
                return await this.mailerReceiver.get(payload);
            default:
                throw new Error(`Unsupported content type: ${payload.Headers.ContentType}`);
        }
    }
}

exports.MailReceiver = MailReceiver;
