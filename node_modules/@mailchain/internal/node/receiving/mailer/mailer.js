'use strict';

var signatures = require('@mailchain/signatures');
var axios = require('axios');
var encoding = require('@mailchain/encoding');
var generate = require('../../formatters/generate.js');
var author = require('./author.js');
var content = require('../../transport/mailer/content.js');

class MailerContentResolver {
    constructor(axiosInstance, sender) {
        Object.defineProperty(this, "axiosInstance", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: axiosInstance
        });
        Object.defineProperty(this, "sender", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: sender
        });
    }
    static create(configuration, axiosInstance = axios.create()) {
        return new MailerContentResolver(axiosInstance, author.MailerAuthorVerifier.create(configuration));
    }
    async get(payload) {
        if (payload.Headers.ContentType !== 'message/x.mailchain-mailer') {
            throw new Error('invalid content type');
        }
        const mailerContent = content.parseMailerContentFromJSON(payload.Content.toString());
        if (!signatures.verifyMailerProof(mailerContent.authorMessagingKey, mailerContent.mailerProof)) {
            throw new Error('invalid mailer proof');
        }
        const response = await this.axiosInstance.get(mailerContent.contentUri, {
            responseType: 'arraybuffer',
        });
        const decodedData = encoding.decodeBase64(response.data);
        if (!mailerContent.authorMessagingKey.verify(decodedData, mailerContent.mailerProof.params.authorContentSignature)) {
            throw new Error('invalid content signature');
        }
        const parsedMailerData = JSON.parse(encoding.encodeUtf8(decodedData));
        const processedContent = await processContent(mailerContent, parsedMailerData);
        const mailerPayload = {
            ...payload,
            Content: Buffer.from(processedContent, 'utf8'),
            MailerContent: mailerContent,
        };
        const senderOwnsFromAddress = await this.sender.verifyAuthorOwnsFromAddress(payload, Buffer.from(processedContent));
        // done here to check that the from address isn't manipulated during rendering
        if (!senderOwnsFromAddress) {
            throw new Error('sender does not match from address');
        }
        return mailerPayload;
    }
}
async function processContent(mailerContent, mailerData) {
    // TODO: interpolate content variables
    const { original } = await generate.createMimeMessage({
        blindCarbonCopyRecipients: [],
        carbonCopyRecipients: [],
        date: mailerContent.date,
        from: mailerContent.authorMailAddress,
        id: mailerContent.messageId,
        message: mailerData.html,
        plainTextMessage: mailerData.plainTextMessage,
        recipients: mailerContent.to,
        subject: mailerData.subject,
        replyTo: mailerData.replyTo,
    }, new Map());
    return original;
}

exports.MailerContentResolver = MailerContentResolver;
