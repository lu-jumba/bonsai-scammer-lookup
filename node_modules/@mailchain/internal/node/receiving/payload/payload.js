'use strict';

var encoding = require('@mailchain/encoding');
var axios = require('axios');
var verifier = require('../../transport/payload/verifier.js');
var headers = require('../../transport/payload/headers.js');
var deliveryRequests = require('../deliveryRequests/deliveryRequests.js');
var serialization = require('../../transport/serialization/serialization.js');
var decrypt = require('../../transport/serialization/decrypt.js');

class PayloadReceiver {
    constructor(deliveryRequests, payloadOriginVerifier, axiosInstance) {
        Object.defineProperty(this, "deliveryRequests", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: deliveryRequests
        });
        Object.defineProperty(this, "payloadOriginVerifier", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: payloadOriginVerifier
        });
        Object.defineProperty(this, "axiosInstance", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: axiosInstance
        });
    }
    static create(configuration, receiverMessagingKeyDecrypter, axiosInstance = axios.create()) {
        return new PayloadReceiver(deliveryRequests.DeliveryRequests.create(configuration, receiverMessagingKeyDecrypter), verifier.PayloadOriginVerifier.create(), axiosInstance);
    }
    async getUndelivered() {
        const deliveryRequests = await this.deliveryRequests.getUndelivered();
        return Promise.all(deliveryRequests.map(async (result) => {
            switch (result.status) {
                case 'success':
                    const payloadResponse = await this.get(result.payloadRootEncryptionKey, result.payloadUri);
                    return processReceivedPayload(payloadResponse, result.deliveryRequestHash);
                case 'failure':
                    return {
                        cause: result.cause,
                        deliveryRequestHash: result.deliveryRequestHash,
                        status: 'error-delivery-request',
                    };
            }
        }));
    }
    async get(payloadRootEncryptionKey, payloadUri) {
        try {
            const encryptedMessageBodyResponse = await this.axiosInstance.get(payloadUri, {
                responseType: 'arraybuffer',
            });
            const encryptedMessageBody = Buffer.from(encoding.decodeBase64(encryptedMessageBodyResponse.data));
            const encryptedPayload = serialization.deserialize(encryptedMessageBody);
            const { headers: headers$1, content } = await decrypt.decryptPayload(encryptedPayload, payloadRootEncryptionKey);
            const payload = {
                Headers: headers.SerializableTransportPayloadHeaders.FromBuffer(headers$1).headers,
                Content: content,
            };
            await this.payloadOriginVerifier.verifyPayloadOrigin(payload);
            return {
                status: 'success',
                payload,
            };
        }
        catch (error) {
            return {
                status: 'failure',
                cause: error,
            };
        }
    }
}
function processReceivedPayload(payloadResponse, deliveryRequestHash) {
    switch (payloadResponse.status) {
        case 'success':
            return {
                status: 'success',
                payload: payloadResponse.payload,
                deliveryRequestHash,
            };
        case 'failure':
            return {
                status: 'error-payload',
                cause: payloadResponse.cause,
                deliveryRequestHash,
            };
        default:
            return {
                status: 'error-payload',
                cause: new Error('Unknown payload response status'),
                deliveryRequestHash,
            };
    }
}

exports.PayloadReceiver = PayloadReceiver;
