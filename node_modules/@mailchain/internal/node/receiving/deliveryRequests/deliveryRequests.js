'use strict';

var api = require('@mailchain/api');
var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');
var signatures = require('@mailchain/signatures');
var protocol = require('../../protobuf/protocol/protocol.js');

class DeliveryRequests {
    constructor(transportApi, messagingKey) {
        Object.defineProperty(this, "transportApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: transportApi
        });
        Object.defineProperty(this, "messagingKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKey
        });
    }
    static create(configuration, receiverMessagingKeyDecrypter) {
        return new DeliveryRequests(api.TransportApiFactory(api.createAxiosConfiguration(configuration.apiPath), undefined, api.getAxiosWithSigner(receiverMessagingKeyDecrypter)), receiverMessagingKeyDecrypter);
    }
    async confirmDelivery(hash) {
        const signature = await signatures.signMailchainDeliveryConfirmation(this.messagingKey, hash);
        await this.transportApi.putDeliveryRequestConfirmation(encoding.encodeHexZeroX(hash), {
            signature: encoding.encodeHexZeroX(signature),
        });
    }
    async getUndelivered() {
        const processed = this.transportApi.getDeliveryRequests().then(({ data: { deliveryRequests } }) => {
            return Promise.all(deliveryRequests.map((dr) => {
                const delivery = protocol.protocol.Delivery.decode(encoding.decodeBase64(dr.data));
                return this.processDeliveryRequest(this.messagingKey, delivery, encoding.decodeHexZeroX(dr.hash));
            }));
        });
        return processed;
    }
    async processDeliveryRequest(messagingKey, delivery, deliveryRequestHash) {
        try {
            const { envelope } = delivery;
            if (!envelope) {
                throw new Error('envelope is undefined');
            }
            const { ecdhKeyBundle, encryptedMessageKey, encryptedMessageUri } = envelope;
            if (!ecdhKeyBundle) {
                throw new Error('envelope does not contain ECDH key bundle');
            }
            if (!encryptedMessageKey) {
                throw new Error('envelope does not contain encryptedMessageKey');
            }
            if (!encryptedMessageUri) {
                throw new Error('envelope does not contain encryptedMessageUri');
            }
            if (!ecdhKeyBundle.publicEphemeralKey) {
                throw new Error('ECDH key bundle does not contain publicEphemeralKey');
            }
            const payloadRootEncryptionKeyBytes = await messagingKey.ecdhDecrypt(crypto.publicKeyFromBytes(ecdhKeyBundle.publicEphemeralKey), encryptedMessageKey);
            if (payloadRootEncryptionKeyBytes.length === 0) {
                throw new Error('payloadRootEncryptionKey is empty');
            }
            const payloadRootEncryptionKey = crypto.ED25519ExtendedPrivateKey.fromPrivateKey(crypto.privateKeyFromBytes(payloadRootEncryptionKeyBytes));
            const payloadUriBytes = await messagingKey.ecdhDecrypt(crypto.publicKeyFromBytes(ecdhKeyBundle.publicEphemeralKey), encryptedMessageUri);
            if (payloadUriBytes.length === 0) {
                throw new Error('payloadUri is empty');
            }
            const payloadUri = encoding.encodeUtf8(payloadUriBytes);
            return {
                status: 'success',
                payloadRootEncryptionKey,
                payloadUri,
                deliveryRequestHash,
            };
        }
        catch (error) {
            return {
                status: 'failure',
                cause: error,
                deliveryRequestHash,
            };
        }
    }
}

exports.DeliveryRequests = DeliveryRequests;
