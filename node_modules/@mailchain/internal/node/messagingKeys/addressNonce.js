'use strict';

var addressing = require('@mailchain/addressing');
var axios = require('axios');
var api = require('@mailchain/api');
var near = require('./contractResolvers/near.js');
var mailchain = require('./contractResolvers/mailchain.js');
var errors = require('./contractResolvers/errors.js');
var errors$1 = require('./errors.js');

class AddressNonce {
    constructor(messagingKeysApi, resolvers) {
        Object.defineProperty(this, "messagingKeysApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKeysApi
        });
        Object.defineProperty(this, "resolvers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: resolvers
        });
    }
    static create(configuration, axiosInstance = axios.create()) {
        const mailchainKeyRegistryResolver = mailchain.MailchainKeyRegContractCallResolver.create(configuration, axiosInstance);
        return new AddressNonce(api.MessagingKeysApiFactory(api.createAxiosConfiguration(configuration.apiPath)), new Map([
            [addressing.NEAR, near.NearContractCallResolver.create(configuration, axiosInstance)],
            [addressing.ETHEREUM, mailchainKeyRegistryResolver],
            [addressing.TEZOS, mailchainKeyRegistryResolver],
            [addressing.FILECOIN, mailchainKeyRegistryResolver],
        ]));
    }
    /**
     * Get the latest nonce for an address.
     *
     * @param address the protocol get the latest nonce for.
     * @param protocol where to find the address.
     * @returns The latest nonce for the given address.
     */
    async getMessagingKeyLatestNonce(address, protocol) {
        if (protocol === addressing.MAILCHAIN) {
            return { data: 1 }; // currently mailchain accounts do not support incrementing nonces
        }
        const resolver = this.resolvers.get(protocol);
        if (!resolver) {
            return { error: new addressing.ProtocolNotSupportedError(protocol) };
        }
        if (!addressing.isBlockchainProtocolEnabled(protocol)) {
            return { error: new addressing.ProtocolNotSupportedError(protocol) };
        }
        const nonceContractResponse = await this.messagingKeysApi.getProtocolAddressNonce(address, protocol);
        try {
            const nonce = await resolver.latestNonce(nonceContractResponse.data.contractCall);
            return {
                data: nonce,
            };
        }
        catch (error) {
            if (error instanceof errors.MessagingKeyNotFoundInContractError) {
                return {
                    data: 0,
                };
            }
            return {
                error: new errors$1.UnexpectedMailchainError('Failed to get latest nonce.', error),
            };
        }
    }
}

exports.AddressNonce = AddressNonce;
