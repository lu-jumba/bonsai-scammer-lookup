'use strict';

var encoding = require('@mailchain/encoding');
var crypto = require('@mailchain/crypto');
var axios = require('axios');
var addressing = require('@mailchain/addressing');
var errors = require('./errors.js');

class NearContractCallResolver {
    constructor(rpcEndpoint, axiosInstance) {
        Object.defineProperty(this, "rpcEndpoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: rpcEndpoint
        });
        Object.defineProperty(this, "axiosInstance", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: axiosInstance
        });
    }
    static create(config, axiosInstance = axios.create()) {
        return new NearContractCallResolver(config.nearRpcUrl, axiosInstance);
    }
    async resolve(contract) {
        const rpcResponse = await this.callContract(contract);
        const result = encoding.encodeUtf8(Uint8Array.from(rpcResponse.result));
        if (result === 'null') {
            return { error: new errors.MessagingKeyNotFoundInContractError() };
        }
        const parsedResult = parseMessagingKeyContractResult(result);
        if (parsedResult.error != null) {
            return parsedResult;
        }
        return {
            data: {
                messagingKey: parsedResult.data.messagingKey,
                protocol: addressing.NEAR,
            },
        };
    }
    async latestNonce(contract) {
        const rpcResponse = await this.callContract(contract);
        const result = encoding.encodeUtf8(Uint8Array.from(rpcResponse.result));
        if (result === 'null') {
            throw new errors.MessagingKeyNotFoundInContractError();
        }
        return parseInt(result, 10);
    }
    async callContract(contract) {
        if (contract.body.length === 0) {
            throw new Error('No body on contract call');
        }
        const body = encoding.encodeUtf8(encoding.decodeBase64(contract.body));
        const postData = JSON.parse(body);
        const response = await this.axiosInstance.request({
            method: contract.method,
            url: this.rpcEndpoint,
            data: postData,
        });
        if (response.status !== 200) {
            throw new Error(`Failed to get messaging key from near, status: ${response.status}, response: ${response.data}`);
        }
        const { data } = response;
        if (data.result.error != null) {
            throw new Error(`Contract error; error=${data.result.error}`);
        }
        if (!data.result.result) {
            throw new Error(`No error but missing result response: ${data}`);
        }
        return data.result;
    }
}
function parseMessagingKeyContractResult(result) {
    const parsedResult = JSON.parse(result);
    if (typeof parsedResult !== 'object') {
        return { error: new errors.InvalidContractResponseError('Object expected.') };
    }
    const [curve, messageKey] = parsedResult;
    if (curve == null || messageKey == null) {
        return { error: new errors.InvalidContractResponseError('Result does not have correct number of elements.') };
    }
    if (typeof curve !== 'string') {
        return { error: new errors.InvalidContractResponseError('Curve format must be string.') };
    }
    if (typeof messageKey !== 'string') {
        return { error: new errors.InvalidContractResponseError('Message key format must be string.') };
    }
    return { data: { messagingKey: crypto.publicKeyFromKind(curve, encoding.decodeHex(messageKey)) } };
}

exports.NearContractCallResolver = NearContractCallResolver;
