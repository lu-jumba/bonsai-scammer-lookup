'use strict';

var axios = require('axios');
var apiKeyToCryptoKey = require('@mailchain/api/helpers/apiKeyToCryptoKey');
var signatures = require('@mailchain/signatures');
var verify = require('../verify.js');
var errors = require('./errors.js');

class MailchainKeyRegContractCallResolver {
    constructor(messagingKeyVerifier, rpcEndpoint, axiosInstance) {
        Object.defineProperty(this, "messagingKeyVerifier", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKeyVerifier
        });
        Object.defineProperty(this, "rpcEndpoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: rpcEndpoint
        });
        Object.defineProperty(this, "axiosInstance", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: axiosInstance
        });
    }
    static create(configuration, axiosInstance = axios.create()) {
        return new this(verify.MessagingKeyVerifier.create(configuration), configuration.apiPath, axiosInstance);
    }
    async resolve(contract) {
        if (contract.path === '/identity-keys/0/messaging-key') {
            return { error: new errors.MessagingKeyNotFoundInContractError() };
        }
        const rpcResponse = await this.callGetMessagingKeyContract(contract);
        const messagingKey = apiKeyToCryptoKey.convertPublic(rpcResponse.messagingKey);
        const verified = await this.messagingKeyVerifier.verifyRegisteredKeyProof(rpcResponse.proof, messagingKey);
        if (!verified) {
            return { error: new signatures.MessagingKeyVerificationError() };
        }
        return {
            data: {
                messagingKey,
                protocol: contract.protocol,
            },
        };
    }
    async latestNonce(contract) {
        if (contract.path === '/identity-keys/0/nonce') {
            throw new errors.MessagingKeyNotFoundInContractError();
        }
        try {
            const { data } = await this.axiosInstance.request({
                method: contract.method,
                url: this.rpcEndpoint + contract.path,
            });
            const { nonce } = data;
            return nonce;
        }
        catch (error) {
            if (axios.isAxiosError(error) && error.response && error.response.status === 404) {
                throw new errors.MessagingKeyNotFoundInContractError();
            }
            throw error;
        }
    }
    async callGetMessagingKeyContract(contract) {
        const response = await this.axiosInstance.request({
            method: contract.method,
            url: this.rpcEndpoint + contract.path,
        });
        if (response.status !== 200) {
            throw new Error(`Failed to get messaging key from near, status: ${response.status}, response: ${response.data}`);
        }
        return response.data;
    }
}

exports.MailchainKeyRegContractCallResolver = MailchainKeyRegContractCallResolver;
