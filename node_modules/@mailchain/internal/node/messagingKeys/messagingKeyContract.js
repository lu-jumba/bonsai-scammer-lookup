'use strict';

var api = require('@mailchain/api');
var axios = require('axios');
var addressing = require('@mailchain/addressing');
var apiKeyToCryptoKey = require('@mailchain/api/helpers/apiKeyToCryptoKey');
var signatures = require('@mailchain/signatures');
var protocols = require('@mailchain/addressing/protocols');
var near = require('./contractResolvers/near.js');
var verify = require('./verify.js');
var mailchain = require('./contractResolvers/mailchain.js');
var errors = require('./contractResolvers/errors.js');
var errors$1 = require('./errors.js');

class MessagingKeyContractCall {
    constructor(resolvers, messagingKeysApi, messagingKeyVerifier) {
        Object.defineProperty(this, "resolvers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: resolvers
        });
        Object.defineProperty(this, "messagingKeysApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKeysApi
        });
        Object.defineProperty(this, "messagingKeyVerifier", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKeyVerifier
        });
    }
    static create(configuration, axiosInstance = axios.create()) {
        const mailchainKeyRegistryResolver = mailchain.MailchainKeyRegContractCallResolver.create(configuration, axiosInstance);
        return new MessagingKeyContractCall(new Map([
            [addressing.ETHEREUM, mailchainKeyRegistryResolver],
            [protocols.FILECOIN, mailchainKeyRegistryResolver],
            [protocols.MAILCHAIN, mailchainKeyRegistryResolver],
            [addressing.NEAR, near.NearContractCallResolver.create(configuration, axiosInstance)],
            [addressing.TEZOS, mailchainKeyRegistryResolver],
        ]), api.MessagingKeysApiFactory(api.createAxiosConfiguration(configuration.apiPath)), verify.MessagingKeyVerifier.create(configuration));
    }
    async resolve(protocol, contractCall, identityKey) {
        const resolver = this.resolvers.get(protocol);
        if (!resolver) {
            return { error: new protocols.ProtocolNotSupportedError(protocol) };
        }
        const { data, error } = await resolver.resolve(contractCall);
        if (error != null) {
            if (error instanceof errors.MessagingKeyNotFoundInContractError) {
                const vendedKeyResponse = await this.messagingKeysApi.getVendedPublicMessagingKey(contractCall.address, contractCall.protocol);
                const verified = await this.messagingKeyVerifier.verifyProvidedKeyProof(vendedKeyResponse.data.proof, apiKeyToCryptoKey.convertPublic(vendedKeyResponse.data.messagingKey));
                if (!verified) {
                    return { error: new signatures.MessagingKeyVerificationError() };
                }
                return {
                    data: {
                        messagingKey: apiKeyToCryptoKey.convertPublic(vendedKeyResponse.data.messagingKey),
                        identityKey,
                        protocol,
                        type: 'vended',
                        protocolAddress: contractCall.address,
                    },
                };
            }
            else if (error instanceof errors.InvalidContractResponseError) {
                return { error: new errors$1.MessagingKeyContactError(error) };
            }
            return {
                error: new errors$1.MessagingKeyContactError(error),
            };
        }
        const { messagingKey } = data;
        return {
            data: { type: 'registered', messagingKey, identityKey, protocol, protocolAddress: contractCall.address },
        };
    }
}

exports.MessagingKeyContractCall = MessagingKeyContractCall;
