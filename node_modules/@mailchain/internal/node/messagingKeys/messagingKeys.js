'use strict';

var encoding = require('@mailchain/encoding');
var addressing = require('@mailchain/addressing');
var crypto = require('@mailchain/crypto');
var api = require('@mailchain/api');
var apiKeyToCryptoKey = require('@mailchain/api/helpers/apiKeyToCryptoKey');
var axios = require('axios');
var errors = require('./errors.js');
var messagingKeyContract = require('./messagingKeyContract.js');
var mailchainResult = require('../mailchainResult.js');

class ResoleAddressesFailuresError extends Error {
    constructor(successes, failures) {
        super(`Not all addresses were resolved. Check the failed resolutions for more information.`);
        Object.defineProperty(this, "successes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: successes
        });
        Object.defineProperty(this, "failures", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: failures
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'resolve_addresses_failures'
        });
        Object.defineProperty(this, "docs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'https://docs.mailchain.com/developer/errors/codes#resolve_addresses_failures'
        });
    }
}
class MessagingKeys {
    constructor(addressApi, identityKeysApi, messagingKeyContractCall, mailchainAddressDomain) {
        Object.defineProperty(this, "addressApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: addressApi
        });
        Object.defineProperty(this, "identityKeysApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: identityKeysApi
        });
        Object.defineProperty(this, "messagingKeyContractCall", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKeyContractCall
        });
        Object.defineProperty(this, "mailchainAddressDomain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: mailchainAddressDomain
        });
    }
    static create(configuration) {
        return new MessagingKeys(api.AddressesApiFactory(api.createAxiosConfiguration(configuration.apiPath)), api.IdentityKeysApiFactory(api.createAxiosConfiguration(configuration.apiPath)), messagingKeyContract.MessagingKeyContractCall.create(configuration), configuration.mailchainAddressDomain);
    }
    /**
     * Resolve the messaging key for the given address.
     *
     * @param address Address to resolve.
     *
     * @returns A {@link ResolvedAddress resolved address} which may be a registered or vended.
     *
     * @example
     * import { messagingKeys } from '@mailchain/sdk';
     *
     * const resolvedAddress = await messagingKeys.resolve(address);
     * console.log(resolvedAddress);
     *
     */
    async resolve(address) {
        const validateAddressError = addressing.checkAddressForErrors(address, this.mailchainAddressDomain);
        if (validateAddressError != null) {
            return { error: validateAddressError };
        }
        const { data, error } = await this.getAddressMessagingKey(address);
        if (error != null) {
            return { error };
        }
        return this.messagingKeyContractCall.resolve(data.protocol, data.contractCall, data.identityKey ? apiKeyToCryptoKey.convertPublic(data.identityKey) : undefined);
    }
    async resolveMany(addresses) {
        const deduplicatedAddresses = [...new Set(addresses)];
        const resolvedAddresses = await Promise.all(deduplicatedAddresses.map(async (address) => {
            const resolvedAddress = await this.resolve(address);
            return { params: address, result: resolvedAddress };
        }));
        const { failures, successes } = mailchainResult.partitionMailchainResults(resolvedAddresses);
        if (failures.length > 0) {
            return { error: new ResoleAddressesFailuresError(successes, failures) };
        }
        return {
            data: new Map(successes.map((r) => [r.params, r.data])),
        };
    }
    async update(proof) {
        const encodedIdentityKey = encoding.encodeHexZeroX(crypto.publicKeyToBytes(proof.identityKey));
        const encodedAddress = addressing.encodeAddressByProtocol(proof.address, proof.protocol);
        await this.identityKeysApi.putMsgKeyByIDKey(encodedIdentityKey, {
            address: {
                encoding: api.encodingTypeToEncodingEnum(encodedAddress.encoding),
                value: encodedAddress.encoded,
                network: proof.network,
                protocol: proof.protocol,
            },
            locale: proof.locale,
            messageVariant: proof.messageVariant,
            messagingKey: api.CryptoKeyConvert.public(proof.messagingKey),
            nonce: proof.nonce,
            signature: encoding.encodeHexZeroX(proof.signature),
            signatureMethod: proof.signatureMethod,
        });
    }
    async getAddressMessagingKey(address) {
        try {
            const { data } = await this.addressApi.getAddressMessagingKey(address);
            const protocol = data.protocol;
            if (!addressing.ALL_PROTOCOLS.includes(protocol)) {
                return { error: new addressing.ProtocolNotSupportedError(protocol) };
            }
            return { data };
        }
        catch (e) {
            if (axios.isAxiosError(e)) {
                switch (e.response?.data?.code) {
                    case 'identity_provider_unsupported':
                        return {
                            error: new errors.IdentityProviderUnsupportedError(),
                        };
                    case 'identity_expired':
                        return {
                            error: new errors.IdentityExpiredError(),
                        };
                    case 'identity_provider_address_unsupported':
                        return {
                            error: new errors.IdentityProviderAddressUnsupportedError(),
                        };
                    case 'identity_not_found':
                        return {
                            error: new errors.IdentityNotFoundError(),
                        };
                    case 'address_format_invalid':
                    case 'tld_unknown':
                        return {
                            error: new addressing.BadlyFormattedAddressError(),
                        };
                    case 'identity_address_invalid':
                        return {
                            error: new addressing.IdentityProviderAddressInvalidError(),
                        };
                }
            }
            return {
                error: new errors.UnexpectedMailchainError(`Failed to resolve messaging key of address ${address}`, e),
            };
        }
    }
    async getAddressMessagingKeyStatus(address) {
        try {
            const { data } = await this.addressApi.getAddressMessagingKeyStatus(address);
            return { data: data.status };
        }
        catch (e) {
            return {
                error: new errors.IdentityProviderUnsupportedError(),
            };
        }
    }
}

exports.MessagingKeys = MessagingKeys;
exports.ResoleAddressesFailuresError = ResoleAddressesFailuresError;
