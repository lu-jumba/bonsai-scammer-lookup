'use strict';

var encoding = require('@mailchain/encoding');
var api = require('@mailchain/api');
var keyreg = require('@mailchain/signatures/keyreg');
var signatures = require('@mailchain/signatures');

class MessagingKeyVerifier {
    constructor(messagingKeysApi) {
        Object.defineProperty(this, "messagingKeysApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKeysApi
        });
    }
    static create(configuration) {
        return new MessagingKeyVerifier(api.MessagingKeysApiFactory(api.createAxiosConfiguration(configuration.apiPath)));
    }
    async verifyRegisteredKeyProof(registeredKeyProof, messagingKey) {
        if (!registeredKeyProof)
            throw new signatures.MessagingKeyVerificationError();
        if (registeredKeyProof.signature == null)
            throw new signatures.MessagingKeyVerificationError();
        const params = {
            AddressEncoding: registeredKeyProof.address.encoding,
            PublicKeyEncoding: registeredKeyProof.messagingKeyEncoding,
            Locale: registeredKeyProof.locale,
            Variant: registeredKeyProof.variant,
        };
        const message = keyreg.createProofMessage(params, api.getAddressFromApiResponse(registeredKeyProof.address), messagingKey, registeredKeyProof.nonce);
        // verify the proof with the correct signer
        const identityKey = api.ApiKeyConvert.public(registeredKeyProof.identityKey);
        const isVerified = await signatures.verify(registeredKeyProof.signingMethod, identityKey, message, encoding.decodeHexZeroX(registeredKeyProof.signature));
        return {
            identityKey,
            result: isVerified,
        };
    }
    async verifyProvidedKeyProof(providedKeyProof, messagingKey) {
        const mailchainPublicKeyResponse = await this.messagingKeysApi.getMailchainPublicKey();
        if (!mailchainPublicKeyResponse.data.key?.value)
            throw new signatures.PublicKeyNotFoundError();
        const mailchainPublicKey = api.ApiKeyConvert.public(mailchainPublicKeyResponse.data.key);
        if (!providedKeyProof.signature)
            throw new signatures.MessagingKeyVerificationError();
        return await signatures.verifyMailchainProvidedMessagingKey(mailchainPublicKey, messagingKey, encoding.decodeHexZeroX(providedKeyProof?.signature), providedKeyProof.address, providedKeyProof.protocol);
    }
}

exports.MessagingKeyVerifier = MessagingKeyVerifier;
