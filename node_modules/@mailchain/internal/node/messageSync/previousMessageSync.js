'use strict';

var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');
var protocols = require('@mailchain/addressing/protocols');
var functions = require('@mailchain/keyring/functions');
var api = require('@mailchain/api');
var uniqBy = require('lodash/uniqBy');
var addressing = require('@mailchain/addressing');
var identityKeys = require('../identityKeys/identityKeys.js');

class PreviousMessageSync {
    constructor(identityKeys, messagingKeysApiFactory, keyRing, messageSync) {
        Object.defineProperty(this, "identityKeys", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: identityKeys
        });
        Object.defineProperty(this, "messagingKeysApiFactory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKeysApiFactory
        });
        Object.defineProperty(this, "keyRing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: keyRing
        });
        Object.defineProperty(this, "messageSync", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messageSync
        });
    }
    static create(sdkConfig, keyRing, messageSync) {
        const axiosConfig = api.createAxiosConfiguration(sdkConfig.apiPath);
        return new PreviousMessageSync(identityKeys.IdentityKeys.create(sdkConfig), (messagingKey) => api.MessagingKeysApiFactory(axiosConfig, undefined, api.getAxiosWithSigner(messagingKey)), keyRing, messageSync);
    }
    async sync(mailbox) {
        const messagingKeysApi = this.messagingKeysApiFactory(this.keyRing.addressMessagingKey(addressing.encodeAddressByProtocol(mailbox.messagingKeyParams.address, mailbox.messagingKeyParams.protocol)
            .encoded, mailbox.messagingKeyParams.protocol, mailbox.messagingKeyParams.nonce));
        const encodedIdentityKey = encoding.encodeHexZeroX(crypto.publicKeyToBytes(mailbox.identityKey));
        const addresses = await this.identityKeys.reverse(mailbox.identityKey);
        // add all address found by identity key and also registered
        const allAddresses = uniqBy([
            ...addresses.map((x) => ({
                protocol: x.protocol,
                address: x.value,
            })),
            ...mailbox.aliases.map((x) => ({
                address: x.address.username,
                protocol: mailbox.messagingKeyParams.protocol,
            })),
        ], (x) => x.address + x.protocol);
        // type Address
        // const aliasMessagingKeyss: [Address, PrivateKey][] = [];
        const aliasMessagingKeys = await Promise.allSettled(allAddresses.map(async (x) => {
            if (!protocols.isBlockchainProtocolEnabled(x.protocol)) {
                throw new Error(`unsupported protocol of [${x.protocol}] for [${x.address}]`);
            }
            // TODO: https://github.com/mailchain/monorepo/issues/405, the private key should be invalidated at the end of the sync
            const { privateKey: apiPrivateKey } = await messagingKeysApi
                .getVendedPrivateMessagingKey(x.address, x.protocol, encodedIdentityKey)
                .then((r) => r.data);
            return { address: x, messagingKey: api.ApiKeyConvert.private(apiPrivateKey) };
        }));
        const filteredAliasMessagingKeys = [];
        aliasMessagingKeys.forEach((x) => {
            if (x.status === 'fulfilled') {
                filteredAliasMessagingKeys.push(x.value);
            }
        });
        const results = [];
        for (const x of filteredAliasMessagingKeys) {
            const { address, messagingKey } = x;
            const tmpResult = await this.messageSync.syncWithMessagingKey(mailbox, functions.ecdhKeyRingDecrypter(messagingKey));
            results.push({ ...tmpResult, address });
        }
        return results;
    }
}

exports.PreviousMessageSync = PreviousMessageSync;
