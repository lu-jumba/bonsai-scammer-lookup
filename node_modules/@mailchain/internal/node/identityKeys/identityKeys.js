'use strict';

var addressing = require('@mailchain/addressing');
var crypto = require('@mailchain/crypto');
var axios = require('axios');
var api = require('@mailchain/api');
var encoding = require('@mailchain/encoding');

class IdentityKeys {
    constructor(addressesApi, identityKeyApi) {
        Object.defineProperty(this, "addressesApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: addressesApi
        });
        Object.defineProperty(this, "identityKeyApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: identityKeyApi
        });
    }
    static create(config) {
        const axiosConfig = api.createAxiosConfiguration(config.apiPath);
        return new IdentityKeys(api.AddressesApiFactory(axiosConfig), api.IdentityKeysApiFactory(axiosConfig));
    }
    async getAddressIdentityKey(address) {
        return this.resolve(addressing.formatAddress(address, 'mail'));
    }
    async resolve(address) {
        return this.addressesApi
            .getAddressIdentityKey(address)
            .then(({ data }) => ({
            identityKey: crypto.publicKeyFromBytes(encoding.decodeHexZeroX(data.identityKey)),
            protocol: data.protocol,
        }))
            .catch((e) => {
            if (axios.isAxiosError(e)) {
                if (e.response?.data.code === 'identity_not_found') {
                    return null;
                }
                else if (e.response?.status === 404) {
                    return null;
                }
            }
            throw e;
        });
    }
    async reverse(identityKey) {
        const { addresses } = (await this.identityKeyApi.getIdentityKeyAddresses(encoding.encodeHexZeroX(crypto.publicKeyToBytes(identityKey)))).data;
        return addresses;
    }
}

exports.IdentityKeys = IdentityKeys;
