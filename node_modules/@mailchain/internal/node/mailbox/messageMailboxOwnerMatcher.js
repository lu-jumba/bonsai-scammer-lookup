'use strict';

var addressing = require('@mailchain/addressing');
var crypto = require('@mailchain/crypto');
var uniqBy = require('lodash/uniqBy');
var addressIdentityKeyResolver = require('./addressIdentityKeyResolver.js');
var identityKeys = require('../identityKeys/identityKeys.js');

class MessageMailboxOwnerMatcher {
    constructor(addressIdentityKeyResolvers) {
        Object.defineProperty(this, "addressIdentityKeyResolvers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: addressIdentityKeyResolvers
        });
    }
    /** Create {@link MessageMailboxOwnerMatcher} with {@link createMailchainApiAddressIdentityKeyResolver} as default resolver.  */
    static create(config) {
        const identityKeys$1 = identityKeys.IdentityKeys.create(config);
        return new MessageMailboxOwnerMatcher([
            ['mailchain-api', addressIdentityKeyResolver.createMailchainApiAddressIdentityKeyResolver(identityKeys$1)],
        ]);
    }
    /**
     * Build new {@link MessageMailboxOwnerMatcher} with an additional identity key resolver {@link createMessageHeaderIdentityKeyResolver}.
     *
     * Note: this doesn't modify the original {@link MessageMailboxOwnerMatcher}.
     */
    withMessageIdentityKeys(addressIdentityKeys) {
        const resolver = addressIdentityKeyResolver.createMessageHeaderIdentityKeyResolver(addressIdentityKeys);
        return new MessageMailboxOwnerMatcher([['message-header', resolver], ...this.addressIdentityKeyResolvers]);
    }
    /** Find the matching {@link Alias} from the provided `mailData` that match to the `userMailbox`. */
    async findMatches(mailData, userMailbox) {
        const allRecipients = uniqBy([...mailData.recipients, ...mailData.carbonCopyRecipients, ...mailData.blindCarbonCopyRecipients], (r) => r.address);
        const matches = [];
        for (const recipient of allRecipients) {
            const address = addressing.parseNameServiceAddress(recipient.address);
            for (const [matchBy, resolver] of this.addressIdentityKeyResolvers) {
                const result = await resolver(address);
                if (result != null && crypto.isPublicKeyEqual(result.identityKey, userMailbox.identityKey)) {
                    matches.push({ address: addressing.parseNameServiceAddress(recipient.address), matchBy });
                    break; // found a match for this recipient, break the resolvers loop
                }
            }
        }
        if (matches.length === 0) {
            return [{ address: userMailbox.aliases[0].address, matchBy: 'fallback' }];
        }
        return matches;
    }
}

exports.MessageMailboxOwnerMatcher = MessageMailboxOwnerMatcher;
