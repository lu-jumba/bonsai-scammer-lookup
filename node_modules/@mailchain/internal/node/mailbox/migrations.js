'use strict';

var crypto = require('@mailchain/crypto');
var ed25519 = require('@mailchain/crypto/ed25519');
var _public = require('@mailchain/crypto/secp256k1/public');
var addressing = require('@mailchain/addressing');
var inbox = require('../protobuf/inbox/inbox.js');
var migration = require('../migration.js');
var identityKeys = require('../identityKeys/identityKeys.js');

function getAllMessagePreviewMigrations(sdkConfig) {
    const identityKeys$1 = identityKeys.IdentityKeys.create(sdkConfig);
    return migration.combineMigrations(createV2IdentityKey(identityKeys$1), createV3EncodeIdentityKey());
}
function createV2IdentityKey(identityKeys) {
    return {
        shouldApply: (data) => Promise.resolve(data.version === 1),
        apply: async (data) => {
            const result = await identityKeys.getAddressIdentityKey(addressing.parseNameServiceAddress(data.messagePreview.owner));
            if (result == null)
                throw new Error(`no identity key found for [${data.messagePreview.owner}], failed message migration`);
            return {
                version: 2,
                messagePreview: inbox.preview.MessagePreview.create({
                    ...data.messagePreview,
                    mailbox: result.identityKey.bytes,
                }),
            };
        },
    };
}
function createV3EncodeIdentityKey() {
    return {
        shouldApply: (data) => Promise.resolve(data.version === 2),
        apply: async (data) => {
            const { messagePreview } = data;
            const owner = addressing.parseNameServiceAddress(messagePreview.owner);
            let mailboxIdentityKey = null;
            if (messagePreview.mailbox.length === ed25519.ED25519PublicKeyLen && addressing.isMailchainAccountAddress(owner)) {
                // ed25519 keys are only used for Mailchain accounts as of v2
                // should also check protocol
                mailboxIdentityKey = new ed25519.ED25519PublicKey(messagePreview.mailbox);
            }
            else if (messagePreview.mailbox.length === _public.SECP256K1PublicKeyLength) {
                mailboxIdentityKey = new _public.SECP256K1PublicKey(messagePreview.mailbox);
            }
            if (mailboxIdentityKey == null)
                throw new Error(`failed message migration, failed mailbox identity key resolution`);
            return {
                version: 3,
                messagePreview: inbox.preview.MessagePreview.create({
                    ...messagePreview,
                    mailbox: crypto.publicKeyToBytes(mailboxIdentityKey),
                }),
            };
        },
    };
}

exports.createV2IdentityKey = createV2IdentityKey;
exports.createV3EncodeIdentityKey = createV3EncodeIdentityKey;
exports.getAllMessagePreviewMigrations = getAllMessagePreviewMigrations;
