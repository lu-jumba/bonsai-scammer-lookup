'use strict';

var encoding = require('@mailchain/encoding');
var addressing = require('@mailchain/addressing');
var crypto = require('@mailchain/crypto');
var api = require('@mailchain/api');
var inbox = require('../protobuf/inbox/inbox.js');
var parse = require('../formatters/parse.js');
var addressHasher = require('./addressHasher.js');
var messageId = require('./messageId.js');
var messageCrypto = require('./messageCrypto.js');
var userMailboxHasher = require('./userMailboxHasher.js');
var messageMailboxOwnerMatcher = require('./messageMailboxOwnerMatcher.js');
var addressIdentityKeyResolver = require('./addressIdentityKeyResolver.js');
var migrations = require('./migrations.js');
var payload = require('./payload/payload.js');
var identityKeys = require('../identityKeys/identityKeys.js');

class MailchainMailboxOperations {
    constructor(inboxApi, messagePreviewCrypto, messageCrypto, messageMailboxOwnerMatcher, addressHasher, messageIdCreator, userMailboxHasher, messageDateOffset, migration) {
        Object.defineProperty(this, "inboxApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: inboxApi
        });
        Object.defineProperty(this, "messagePreviewCrypto", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagePreviewCrypto
        });
        Object.defineProperty(this, "messageCrypto", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messageCrypto
        });
        Object.defineProperty(this, "messageMailboxOwnerMatcher", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messageMailboxOwnerMatcher
        });
        Object.defineProperty(this, "addressHasher", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: addressHasher
        });
        Object.defineProperty(this, "messageIdCreator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messageIdCreator
        });
        Object.defineProperty(this, "userMailboxHasher", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: userMailboxHasher
        });
        Object.defineProperty(this, "messageDateOffset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messageDateOffset
        });
        Object.defineProperty(this, "migration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: migration
        });
    }
    static create(sdkConfig, keyRing) {
        const axiosConfig = api.createAxiosConfiguration(sdkConfig.apiPath);
        const axiosClient = api.getAxiosWithSigner(keyRing.accountMessagingKey());
        const inboxApi = api.InboxApiFactory(axiosConfig, undefined, axiosClient);
        const messagePreviewCrypto = keyRing.inboxKey();
        const messageMessageCrypto = messageCrypto.createMailchainMessageCrypto(keyRing);
        const messageMailboxOwnerMatcher$1 = messageMailboxOwnerMatcher.MessageMailboxOwnerMatcher.create(sdkConfig);
        const addressHasher$1 = addressHasher.mailchainAddressHasher(addressIdentityKeyResolver.createMailchainApiAddressIdentityKeyResolver(identityKeys.IdentityKeys.create(sdkConfig)), keyRing);
        const messageHasher = messageId.createMailchainMessageIdCreator(keyRing);
        const userMailboxHasher$1 = userMailboxHasher.createMailchainUserMailboxHasher(keyRing);
        return new MailchainMailboxOperations(inboxApi, messagePreviewCrypto, messageMessageCrypto, messageMailboxOwnerMatcher$1, addressHasher$1, messageHasher, userMailboxHasher$1, keyRing.inboxMessageDateOffset(), migrations.getAllMessagePreviewMigrations(sdkConfig));
    }
    async getMessage(messageId) {
        const message = await this.inboxApi.getMessage(messageId).then((res) => res.data.message);
        return this.handleMessagePreview(message);
    }
    async getInboxMessages() {
        const messages = await this.inboxApi.getMessagesInInboxView().then((res) => res.data.messages);
        return this.handleMessagePreviews(messages);
    }
    async getStarredMessages() {
        const messages = await this.inboxApi.getMessagesInStarredView().then((res) => res.data.messages);
        return this.handleMessagePreviews(messages);
    }
    async getTrashMessages() {
        const messages = await this.inboxApi.getMessagesInTrashView().then((res) => res.data.messages);
        return this.handleMessagePreviews(messages);
    }
    async getUnreadMessages() {
        const messages = await this.inboxApi.getMessagesInUnreadView().then((res) => res.data.messages);
        return this.handleMessagePreviews(messages);
    }
    async getSentMessages() {
        const messages = await this.inboxApi.getMessagesInSentView().then((res) => res.data.messages);
        return this.handleMessagePreviews(messages);
    }
    async getOutboxMessages() {
        const messages = await this.inboxApi.getMessagesInOutboxView().then((res) => res.data.messages);
        return this.handleMessagePreviews(messages);
    }
    async getArchivedMessages() {
        const messages = await this.inboxApi.getMessagesInArchivedView().then((res) => res.data.messages);
        return this.handleMessagePreviews(messages);
    }
    async searchMessages() {
        const messages = await this.inboxApi.getMessagesSearch().then((res) => res.data.messages);
        return this.handleMessagePreviews(messages);
    }
    async handleMessagePreviews(messages) {
        const messagePreviews = [];
        for (const message of messages) {
            try {
                messagePreviews.push(await this.handleMessagePreview(message));
            }
            catch (error) {
                // TODO: decide how to handle
                console.error(`failed to read message preview: version=${message.version};messageId=${message.messageId}`, error);
            }
        }
        return messagePreviews;
    }
    async handleMessagePreview(apiMessage) {
        const encryptedPreviewData = encoding.decodeBase64(apiMessage.encryptedPreview);
        // const previewData = await this.messagePreviewCrypto.decrypt(encryptedPreviewData);
        // const preview = protoInbox.preview.MessagePreview.decode(previewData);
        const originalPreviewData = {
            version: apiMessage.version,
            messagePreview: inbox.preview.MessagePreview.decode(await this.messagePreviewCrypto.decrypt(encryptedPreviewData)),
        };
        const message = (await this.migration.shouldApply(originalPreviewData))
            ? await this.migration.apply(originalPreviewData)
            : originalPreviewData;
        if (apiMessage.version !== message.version) {
            console.debug(`${apiMessage.messageId} migrated from v${apiMessage.version} to v${message.version}`);
            // TODO #750: save migrated message to Mailchain
        }
        const { messagePreview } = message;
        return {
            mailbox: crypto.publicKeyFromBytes(messagePreview.mailbox),
            messageId: apiMessage.messageId,
            owner: messagePreview.owner,
            to: messagePreview.to,
            bcc: messagePreview.bcc,
            cc: messagePreview.cc,
            from: messagePreview.from,
            subject: messagePreview.subject,
            snippet: messagePreview.snippet,
            hasAttachment: messagePreview.hasAttachment,
            timestamp: new Date(messagePreview.timestamp * 1000),
            isRead: !apiMessage.systemLabels.includes('unread'),
            systemLabels: apiMessage.systemLabels,
        };
    }
    async getFullMessage(messageId) {
        const encryptedMessage = await this.inboxApi
            .getEncryptedMessageBody(messageId, { responseType: 'arraybuffer' })
            .then((res) => res.data);
        const messageData = await this.messageCrypto.decrypt(new Uint8Array(encryptedMessage));
        const { mailData } = await parse.parseMimeText(messageData.Content);
        const to = mailData.recipients.map((r) => r.address);
        const cc = mailData.carbonCopyRecipients.map((r) => r.address);
        const bcc = mailData.blindCarbonCopyRecipients.map((r) => r.address);
        return {
            from: mailData.from.address,
            to,
            replyTo: mailData.replyTo ? mailData.replyTo.address : undefined,
            subject: mailData.subject,
            timestamp: mailData.date,
            body: mailData.message,
            cc,
            bcc,
        };
    }
    async saveSentMessage(params) {
        const messageId = await this.messageIdCreator({ type: 'sent', mailData: params.content });
        const owner = addressing.parseNameServiceAddress(params.content.from.address);
        return this.saveMessage(messageId, params.payload, params.content, params.userMailbox, owner, 'outbox');
    }
    async saveReceivedMessage({ userMailbox, receivedTransportPayload, }) {
        const payload$1 = payload.convertPayload(receivedTransportPayload);
        const { mailData, addressIdentityKeys } = await parse.parseMimeText(payload$1.Content);
        const owners = await this.messageMailboxOwnerMatcher
            .withMessageIdentityKeys(addressIdentityKeys)
            .findMatches(mailData, userMailbox);
        if (owners.length === 0)
            throw new Error('no owners found for message');
        const savedMessages = [];
        for (const { address: owner } of owners) {
            const messageId = await this.messageIdCreator({
                type: 'received',
                mailData,
                owner: addressing.formatAddress(owner, 'mail'),
                mailbox: userMailbox.identityKey,
            });
            const savedMessage = await this.saveMessage(messageId, payload$1, mailData, userMailbox, owner, 'inbox');
            savedMessages.push(savedMessage);
        }
        if (savedMessages.length === 0) {
            throw new Error(`no message was saved for message with ID [${mailData.id}]`);
        }
        return savedMessages;
    }
    async saveMessage(messageId, payload, content, userMailbox, owner, folder) {
        const ownerAddress = addressing.formatAddress(owner, 'mail');
        const messagePreview = createMessagePreview(userMailbox, owner, content);
        const encodedMessagePreview = inbox.preview.MessagePreview.encode(messagePreview).finish();
        const encryptedMessagePreview = await this.messagePreviewCrypto.encrypt(encodedMessagePreview);
        const encryptedMessage = await this.messageCrypto.encrypt(payload);
        const { recipients: to, carbonCopyRecipients: cc, blindCarbonCopyRecipients: bcc } = content;
        const addresses = [content.from, ...to, ...cc, ...bcc].map((a) => a.address);
        addresses.push(ownerAddress);
        const addressHashes = await this.addressHasher(addresses);
        const { resourceId } = await this.inboxApi.postEncryptedMessageBody(encryptedMessage).then((res) => res.data);
        await this.inboxApi.putEncryptedMessage(messageId, {
            version: 3,
            folder: folder === 'outbox'
                ? api.PutEncryptedMessageRequestBodyFolderEnum.Outbox
                : api.PutEncryptedMessageRequestBodyFolderEnum.Inbox,
            date: messagePreview.timestamp - this.messageDateOffset,
            mailbox: Array.from(await this.userMailboxHasher(userMailbox)),
            // Note: 'hashedOwner' is only 'username' hash because there is no need for 'identity-key' because that is covered by 'mailbox'
            hashedOwner: Array.from(addressHasher.getAddressHash(addressHashes, ownerAddress, 'username')),
            // Note: 'hashedFrom' takes only single type of hash because there is API type restriction, so 'identity-key' hash is proffered.
            hashedFrom: Array.from(addressHasher.getAddressHash(addressHashes, content.from.address, 'identity-key', 'username')),
            hashedTo: addressHasher.getMailAddressesHashes(addressHashes, to).map((h) => Array.from(h)),
            hashedCc: addressHasher.getMailAddressesHashes(addressHashes, cc).map((h) => Array.from(h)),
            hashedBcc: addressHasher.getMailAddressesHashes(addressHashes, bcc).map((h) => Array.from(h)),
            encryptedPreview: encoding.encodeBase64(encryptedMessagePreview),
            messageBodyResourceId: resourceId,
        });
        return {
            mailbox: userMailbox.identityKey,
            messageId,
            from: messagePreview.from,
            to: messagePreview.to,
            cc: messagePreview.cc,
            bcc: messagePreview.bcc,
            subject: messagePreview.subject,
            owner: messagePreview.owner,
            snippet: messagePreview.snippet,
            isRead: folder === 'outbox',
            systemLabels: folder === 'outbox' ? ['outbox'] : ['unread', 'inbox'],
            hasAttachment: false,
            timestamp: new Date(messagePreview.timestamp * 1000),
        };
    }
    async markOutboxMessageAsSent(messageId) {
        await this.modifySystemLabel(messageId, 'outbox', false);
        await this.modifySystemLabel(messageId, 'sent', true);
    }
    async modifyArchiveMessage(messageId, archived) {
        await this.modifySystemLabel(messageId, 'archive', archived);
    }
    async modifyIsReadMessage(messageId, isRead) {
        await this.modifySystemLabel(messageId, 'unread', !isRead);
    }
    async modifyTrashMessage(messageId, trash) {
        await this.modifySystemLabel(messageId, 'trash', trash);
    }
    async modifyStarredMessage(messageId, isStarred) {
        await this.modifySystemLabel(messageId, 'starred', isStarred);
    }
    async modifySystemLabel(messageId, systemLabel, include) {
        await this.modifyUserLabel(messageId, systemLabel, include);
    }
    async modifyUserLabel(messageId, userLabel, include) {
        if (include) {
            await this.inboxApi.putMessageLabel(messageId, userLabel);
        }
        else {
            await this.inboxApi.deleteMessageLabel(messageId, userLabel);
        }
    }
}
function createMessagePreview(userMailbox, owner, content, snippetLength = 100) {
    return inbox.preview.MessagePreview.create({
        owner: addressing.formatAddress(owner, 'mail'),
        mailbox: crypto.publicKeyToBytes(userMailbox.identityKey),
        to: content.recipients.map((it) => it.address),
        cc: content.carbonCopyRecipients.map((it) => it.address),
        bcc: content.blindCarbonCopyRecipients.map((it) => it.address),
        from: content.from.address,
        subject: content.subject,
        snippet: content.plainTextMessage.substring(0, snippetLength - 1).trim(),
        hasAttachment: false,
        timestamp: Math.round(content.date.getTime() / 1000),
    });
}

exports.MailchainMailboxOperations = MailchainMailboxOperations;
