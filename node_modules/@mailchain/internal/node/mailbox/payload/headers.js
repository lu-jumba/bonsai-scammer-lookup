'use strict';

var content = require('../../transport/mailer/content.js');
var headers = require('../../transport/serialization/headers.js');

const HEADER_CONTENT_ENCODING = 'Content-Encoding';
const HEADER_CONTENT_ENCRYPTION = 'Content-Encryption';
const HEADER_CONTENT_LENGTH = 'Content-Length';
const HEADER_CONTENT_SIGNATURE = 'Content-Signature';
const HEADER_CONTENT_TYPE = 'Content-Type';
const HEADER_CREATED = 'Created';
const HEADER_ORIGIN = 'Origin';
const HEADER_MAILER_CONTENT = 'Mailer-Content';
class SerializableMailPayloadHeaders {
    constructor(headers) {
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.headers = headers;
    }
    static FromEncryptedMailPayloadHeaders(headers) {
        return new this(headers);
    }
    static FromBuffer(buffer) {
        const { headers: headers$1 } = headers.headersMapFromBuffers(buffer, [
            HEADER_CONTENT_ENCODING,
            HEADER_CONTENT_ENCRYPTION,
            HEADER_CONTENT_LENGTH,
            HEADER_CONTENT_SIGNATURE,
            HEADER_CONTENT_TYPE,
            HEADER_CREATED,
            HEADER_ORIGIN,
        ]);
        const output = {
            ContentEncoding: headers$1.get(HEADER_CONTENT_ENCODING).toString(),
            ContentEncryption: headers$1.get(HEADER_CONTENT_ENCRYPTION).toString(),
            ContentLength: Number.parseInt(headers$1.get(HEADER_CONTENT_LENGTH).toString()),
            ContentSignature: headers.parseSignatureHeader(headers$1.get(HEADER_CONTENT_SIGNATURE).toString()),
            ContentType: headers$1.get(HEADER_CONTENT_TYPE).toString(),
            Created: new Date(headers$1.get(HEADER_CREATED).toString()),
            Origin: headers.parseOriginHeader(headers$1.get(HEADER_ORIGIN).toString()),
        };
        if (headers$1.get(HEADER_MAILER_CONTENT)) {
            output.MailerContent = content.parseMailerContentFromJSON(headers$1.get(HEADER_MAILER_CONTENT).toString());
        }
        return new this(output);
    }
    ToBuffer() {
        const headers$1 = [];
        headers$1.push(`${HEADER_CONTENT_ENCODING}: ${this.headers.ContentEncoding}`);
        headers$1.push(`${HEADER_CONTENT_ENCRYPTION}: ${this.headers.ContentEncryption}`);
        headers$1.push(`${HEADER_CONTENT_LENGTH}: ${this.headers.ContentLength}`);
        headers$1.push(`${HEADER_CONTENT_SIGNATURE}: ${headers.createSignatureHeader(this.headers.ContentSignature, this.headers.Origin)}`);
        headers$1.push(`${HEADER_CONTENT_TYPE}: ${this.headers.ContentType}`);
        headers$1.push(`${HEADER_CREATED}: ${this.headers.Created.toISOString()}`);
        headers$1.push(`${HEADER_ORIGIN}: ${headers.createOriginHeader(this.headers.Origin)}`);
        if (this.headers.MailerContent) {
            headers$1.push(`${HEADER_MAILER_CONTENT}:  ${content.createContentBuffer(this.headers.MailerContent)}`);
        }
        return Buffer.from(headers$1.join('\r\n'), 'utf8');
    }
}

exports.SerializableMailPayloadHeaders = SerializableMailPayloadHeaders;
