'use strict';

var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');
var addressing = require('@mailchain/addressing');
var nameservices = require('@mailchain/addressing/nameservices');
var api = require('@mailchain/api');
var identityKeys = require('../identityKeys/identityKeys.js');

const PROTOCOLS_SUPPORTING_NAMESERVICE = [addressing.ETHEREUM, addressing.TEZOS];
class Nameservices {
    constructor(identityKeysApi, identityKeysService, mailchainAddressDomain) {
        Object.defineProperty(this, "identityKeysApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: identityKeysApi
        });
        Object.defineProperty(this, "identityKeysService", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: identityKeysService
        });
        Object.defineProperty(this, "mailchainAddressDomain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: mailchainAddressDomain
        });
    }
    static create(config) {
        const identityKeysApi = api.IdentityKeysApiFactory(api.createAxiosConfiguration(config.apiPath));
        const identityKeysService = identityKeys.IdentityKeys.create(config);
        return new Nameservices(identityKeysApi, identityKeysService, config.mailchainAddressDomain);
    }
    async reverseResolveNames(identityKey) {
        return this.identityKeysApi.getIdentityKeyResolvableNames(encoding.encodeHexZeroX(crypto.publicKeyToBytes(identityKey))).then(({ data }) => data.resolvableNames?.map((resolved) => ({
            ...resolved,
            address: addressing.createNameServiceAddress(resolved.name, resolved.resolver, this.mailchainAddressDomain),
        })) ?? [], (e) => {
            console.error(e);
            return [];
        });
    }
    async nameResolvesToMailbox(nsName, mailboxIdentityKey) {
        for (const nsDesc of nameservices.NAMESERVICE_DESCRIPTIONS) {
            const nsAddress = addressing.createNameServiceAddress(nsName, nsDesc.name, this.mailchainAddressDomain);
            try {
                const addressIdentityKey = await this.identityKeysService.getAddressIdentityKey(nsAddress);
                if (addressIdentityKey != null &&
                    crypto.isPublicKeyEqual(addressIdentityKey.identityKey, mailboxIdentityKey)) {
                    return nsAddress;
                }
            }
            catch (e) {
                console.log(`failed to resolve address: ${e}`);
            }
        }
        return null;
    }
}

exports.Nameservices = Nameservices;
exports.PROTOCOLS_SUPPORTING_NAMESERVICE = PROTOCOLS_SUPPORTING_NAMESERVICE;
