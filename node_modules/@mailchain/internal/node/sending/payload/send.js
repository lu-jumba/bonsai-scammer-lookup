'use strict';

var crypto = require('@mailchain/crypto');
var api = require('@mailchain/api');
var errors = require('../../messagingKeys/errors.js');
var payload = require('../../transport/payload/payload.js');

class PayloadSender {
    constructor(transportApi) {
        Object.defineProperty(this, "transportApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: transportApi
        });
    }
    static create(configuration, accountKeySigner) {
        return new PayloadSender(api.TransportApiFactory(configuration, undefined, api.getAxiosWithSigner(accountKeySigner)));
    }
    /**
     * Encrypt the payload with ephemeral key and deliver it to the storage nodes.
     * @returns the URL to get the message from the and ephemeral key used for the encryption of it
     */
    async sendPayload(payload$1) {
        try {
            // create root encryption key that will be used to encrypt message content.
            const payloadRootEncryptionKey = crypto.ED25519ExtendedPrivateKey.fromPrivateKey(crypto.ED25519PrivateKey.generate());
            const serializedContent = await payload.serializeAndEncryptPayload(payload$1, payloadRootEncryptionKey);
            const { uri: payloadUri } = await this.transportApi
                .postEncryptedPayload(serializedContent)
                .then((r) => r.data);
            return {
                data: {
                    payloadUri,
                    payloadRootEncryptionKey,
                },
            };
        }
        catch (error) {
            return {
                error: new errors.UnexpectedMailchainError('failed to send payload', error),
            };
        }
    }
}

exports.PayloadSender = PayloadSender;
