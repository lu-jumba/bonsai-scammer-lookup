'use strict';

var signatures = require('@mailchain/signatures');
var errors = require('../errors.js');
var payloads = require('./payloads.js');
var messagingKeys = require('../../messagingKeys/messagingKeys.js');
var sender = require('../../transport/mail/sender.js');

class MailPreparer {
    constructor(messagingKeys, mailSenderVerifier) {
        Object.defineProperty(this, "messagingKeys", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: messagingKeys
        });
        Object.defineProperty(this, "mailSenderVerifier", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: mailSenderVerifier
        });
    }
    static create(configuration) {
        return new MailPreparer(messagingKeys.MessagingKeys.create(configuration), sender.MailSenderVerifier.create(configuration));
    }
    async prepareMail(params) {
        const { message, senderMessagingKey } = params;
        if (message.subject.length === 0) {
            return { error: new errors.PreflightCheckError('Subject must not be empty.') };
        }
        if (message.plainTextMessage.length === 0) {
            return { error: new errors.PreflightCheckError('Content text must not be empty.') };
        }
        if (message.message.length === 0) {
            return { error: new errors.PreflightCheckError('Content html must not be empty.') };
        }
        const allRecipients = [
            ...message.recipients,
            ...message.blindCarbonCopyRecipients,
            ...message.carbonCopyRecipients,
        ];
        if (allRecipients.length === 0) {
            return { error: new errors.PreflightCheckError('No recipients found.') };
        }
        const isSenderMatching = await this.mailSenderVerifier.verifySenderOwnsFromAddress(message.from, senderMessagingKey.publicKey);
        if (!isSenderMatching) {
            return { error: new signatures.SenderMessagingKeyIncorrect() };
        }
        // add at after checking if all recipients are empty
        const allParticipants = [...allRecipients, message.from];
        if (message.replyTo != null) {
            allParticipants.push(message.replyTo);
        }
        const { data: resolvedAddresses, error } = await this.messagingKeys.resolveMany(allParticipants.map((x) => x.address));
        if (error) {
            return { error };
        }
        const messagePayloads = await payloads.createMailPayloads(params.senderMessagingKey, resolvedAddresses, message);
        return {
            data: {
                distributions: messagePayloads.distributions,
                message: messagePayloads.original,
                resolvedAddresses,
            },
        };
    }
}

exports.MailPreparer = MailPreparer;
