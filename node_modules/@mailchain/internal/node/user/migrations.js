'use strict';

var addressing = require('@mailchain/addressing');
var nameservices = require('@mailchain/addressing/nameservices');
var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');
var user = require('../protobuf/user/user.js');

function createV2IdentityKey(identityKeys, mailchainAddressDomain) {
    return {
        shouldApply: (data) => Promise.resolve(data.version === 1),
        apply: async ({ protoMailbox }) => {
            const protocol = protoMailbox.protocol;
            const encodedAddress = addressing.encodeAddressByProtocol(protoMailbox.address, protocol).encoded;
            const result = await identityKeys.getAddressIdentityKey(addressing.createWalletAddress(encodedAddress, protocol, mailchainAddressDomain));
            // Note: Theoretically not possible not to find identity key for registered address, but lets handle it
            if (result == null)
                throw new Error(`no identity key fround for address [${encodedAddress}]`);
            return {
                version: 2,
                protoMailbox: user.user.Mailbox.create({
                    ...protoMailbox,
                    identityKey: crypto.publicKeyToBytes(result.identityKey),
                }),
            };
        },
    };
}
function createV3LabelMigration(_mailchainAddressDomain) {
    return {
        shouldApply: (data) => Promise.resolve(data.version === 2),
        apply: (data) => Promise.resolve({
            version: 3,
            protoMailbox: user.user.Mailbox.create({
                ...data.protoMailbox,
                label: null,
            }),
        }),
    };
}
function createV4AliasesMigration(mailchainAddressDomain) {
    return {
        shouldApply: (data) => Promise.resolve(data.version === 3),
        apply: (data) => {
            const { protoMailbox } = data;
            const protocol = protoMailbox.protocol;
            const encodedAddress = addressing.encodeAddressByProtocol(protoMailbox.address, protocol).encoded;
            const address = addressing.formatAddress(addressing.createWalletAddress(encodedAddress, protocol, mailchainAddressDomain), 'mail');
            return Promise.resolve({
                version: 4,
                protoMailbox: user.user.Mailbox.create({
                    ...protoMailbox,
                    aliases: [{ address, blockSending: false, blockReceiving: false }],
                }),
            });
        },
    };
}
function createV5NsMigration(nameservices) {
    return {
        shouldApply: (data) => Promise.resolve(data.version === 4),
        apply: async ({ protoMailbox }) => {
            const identityKey = crypto.publicKeyFromBytes(protoMailbox.identityKey);
            try {
                const foundNames = await nameservices.reverseResolveNames(identityKey);
                const aliases = [...protoMailbox.aliases];
                for (const { address } of foundNames) {
                    const aliasAddress = addressing.formatAddress(address, 'mail');
                    if (aliases.some((alias) => alias.address === aliasAddress))
                        continue;
                    const alias = user.user.Mailbox.Alias.create({
                        address: aliasAddress,
                        blockSending: false,
                        blockReceiving: false,
                    });
                    aliases.push(alias);
                }
                return { version: 5, protoMailbox: user.user.Mailbox.create({ ...protoMailbox, aliases }) };
            }
            catch (e) {
                console.warn(`failed reverse search for identity key ${encoding.encodeHexZeroX(protoMailbox.identityKey)}. Will bump version without storing NS aliases`);
                return { version: 5, protoMailbox };
            }
        },
    };
}
function createV6FixNsAliasFormatMigration(mailchainAddressDomain) {
    return {
        shouldApply: (data) => Promise.resolve(data.version === 5),
        apply: (data) => {
            const aliases = data.protoMailbox.aliases.map((a) => {
                // Shouldn't happen, mostly making TS happy
                if (a.address == null)
                    return a;
                const address = addressing.parseNameServiceAddress(a.address);
                // Ignore correct alias formatting like `alice.eth@ens.mailchain.com`
                if (address.domain !== mailchainAddressDomain)
                    return a;
                for (const nsDesc of nameservices.NAMESERVICE_DESCRIPTIONS) {
                    const nsAddress = addressing.createNameServiceAddress(address.username, nsDesc.name, address.domain);
                    const matchingDomain = nameservices.matchesNameservice(nsAddress, nsDesc);
                    if (matchingDomain != null) {
                        return user.user.Mailbox.Alias.create({ ...a, address: addressing.formatAddress(nsAddress, 'mail') });
                    }
                }
                // no match found, meaning no need for migration
                return a;
            });
            return Promise.resolve({
                version: 6,
                protoMailbox: user.user.Mailbox.create({ ...data.protoMailbox, aliases }),
            });
        },
    };
}

exports.createV2IdentityKey = createV2IdentityKey;
exports.createV3LabelMigration = createV3LabelMigration;
exports.createV4AliasesMigration = createV4AliasesMigration;
exports.createV5NsMigration = createV5NsMigration;
exports.createV6FixNsAliasFormatMigration = createV6FixNsAliasFormatMigration;
