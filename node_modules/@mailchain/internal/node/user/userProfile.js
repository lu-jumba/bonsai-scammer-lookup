'use strict';

var encoding = require('@mailchain/encoding');
var addressing = require('@mailchain/addressing');
var crypto = require('@mailchain/crypto');
var api = require('@mailchain/api');
var user = require('../protobuf/user/user.js');
var migration = require('../migration.js');
var migrations = require('./migrations.js');
var createAlias = require('./createAlias.js');
var consolidateMailbox = require('./consolidateMailbox.js');
var nameservices = require('../nameservices/nameservices.js');
var identityKeys = require('../identityKeys/identityKeys.js');

class UserNotFoundError extends Error {
    constructor() {
        super(`user not found for provided key`);
    }
}
const CURRENT_MAILBOX_VERSION = 6;
class MailchainUserProfile {
    constructor(mailchainAddressDomain, userApi, accountIdentityKey, mailboxCrypto, migration) {
        Object.defineProperty(this, "mailchainAddressDomain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: mailchainAddressDomain
        });
        Object.defineProperty(this, "userApi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: userApi
        });
        Object.defineProperty(this, "accountIdentityKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: accountIdentityKey
        });
        Object.defineProperty(this, "mailboxCrypto", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: mailboxCrypto
        });
        Object.defineProperty(this, "migration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: migration
        });
    }
    static create(config, accountIdentityKey, mailboxCrypto) {
        const axiosConfig = api.createAxiosConfiguration(config.apiPath);
        const identityKeys$1 = identityKeys.IdentityKeys.create(config);
        const userApi = api.UserApiFactory(axiosConfig, undefined, api.getAxiosWithSigner(accountIdentityKey));
        const nameservice = nameservices.Nameservices.create(config);
        const migrations$1 = migration.combineMigrations(migrations.createV2IdentityKey(identityKeys$1, config.mailchainAddressDomain), migrations.createV3LabelMigration(config.mailchainAddressDomain), migrations.createV4AliasesMigration(config.mailchainAddressDomain), migrations.createV5NsMigration(nameservice), migrations.createV6FixNsAliasFormatMigration(config.mailchainAddressDomain));
        return new MailchainUserProfile(config.mailchainAddressDomain, userApi, () => Promise.resolve(accountIdentityKey.publicKey), mailboxCrypto, migrations$1);
    }
    async getUsername() {
        return this.userApi
            .getUsername()
            .then((response) => {
            const { data } = response;
            return {
                address: data.address,
                username: data.username,
            };
        })
            .catch((e) => {
            if (e.response?.status === 404) {
                throw new UserNotFoundError();
            }
            throw e;
        });
    }
    async setSetting(key, value) {
        await this.userApi.putUserSetting(key, { value });
    }
    async getSettings() {
        const { data } = await this.userApi.getUserSettings();
        return data.settings ?? {};
    }
    async mailboxes() {
        const { mailboxes: apiMailboxes } = await this.userApi.getUserMailboxes().then((r) => r.data);
        const resultMailboxes = [];
        for (const apiMailbox of apiMailboxes) {
            try {
                const decryptedMailbox = await this.mailboxCrypto.decrypt(encoding.decodeBase64(apiMailbox.encryptedMailboxInformation));
                const originalMailboxData = {
                    version: apiMailbox.version,
                    protoMailbox: user.user.Mailbox.decode(decryptedMailbox),
                };
                const mailboxData = (await this.migration.shouldApply(originalMailboxData))
                    ? await this.migration.apply(originalMailboxData)
                    : originalMailboxData;
                if (apiMailbox.version !== mailboxData.version) {
                    console.debug(`${apiMailbox.mailboxId} migrated from v${apiMailbox.version} to v${mailboxData.version}`);
                    this.internalUpdateMailbox(apiMailbox.mailboxId, mailboxData.protoMailbox, mailboxData.version).then(() => console.debug(`successfully stored migrated mailbox ${apiMailbox.mailboxId}`), (e) => console.warn(`failed storing migrated mailbox ${apiMailbox.mailboxId}`, e));
                }
                const { protoMailbox } = mailboxData;
                const protocol = protoMailbox.protocol;
                const encodedAddress = addressing.encodeAddressByProtocol(protoMailbox.address, protocol).encoded;
                const fallbackAlias = createAlias.createMailboxAlias(addressing.createWalletAddress(encodedAddress, protocol, this.mailchainAddressDomain));
                const mailboxAliases = protoMailbox.aliases.map(user.user.Mailbox.Alias.create).map((protoAlias) => {
                    return createAlias.createMailboxAlias(addressing.parseNameServiceAddress(protoAlias.address), {
                        allowSending: !protoAlias.blockSending,
                        allowReceiving: !protoAlias.blockReceiving,
                    });
                });
                resultMailboxes.push({
                    type: 'wallet',
                    id: apiMailbox.mailboxId,
                    identityKey: crypto.publicKeyFromBytes(protoMailbox.identityKey),
                    label: protoMailbox.label ?? null,
                    aliases: mailboxAliases.length > 0 ? mailboxAliases : [fallbackAlias],
                    messagingKeyParams: {
                        address: protoMailbox.address,
                        protocol,
                        network: protoMailbox.network,
                        nonce: protoMailbox.nonce,
                    },
                });
            }
            catch (e) {
                console.error(`failed processing mailbox ${apiMailbox.mailboxId}`, e);
            }
        }
        return [await this.accountMailbox(), ...resultMailboxes];
    }
    async accountMailbox() {
        const { username, address } = await this.getUsername();
        const addressAlias = createAlias.createMailboxAlias(addressing.createWalletAddress(username, addressing.MAILCHAIN, this.mailchainAddressDomain));
        return {
            type: 'account',
            id: address,
            identityKey: await this.accountIdentityKey(),
            label: null,
            aliases: [addressAlias],
            messagingKeyParams: {
                address: addressing.decodeAddressByProtocol(username, addressing.MAILCHAIN).decoded,
                protocol: addressing.MAILCHAIN,
                network: this.mailchainAddressDomain,
                nonce: 1,
            },
        };
    }
    async addMailbox(mailbox) {
        const consolidatedMailbox = consolidateMailbox.consolidateMailbox(mailbox);
        const protoMailbox = createProtoUserMailbox(consolidatedMailbox);
        const encrypted = await this.mailboxCrypto.encrypt(user.user.Mailbox.encode(protoMailbox).finish());
        const { mailboxId } = await this.userApi
            .postUserMailbox({ encryptedMailboxInformation: encoding.encodeBase64(encrypted), version: CURRENT_MAILBOX_VERSION })
            .then((res) => res.data);
        return { ...consolidatedMailbox, type: 'wallet', id: mailboxId };
    }
    async updateMailbox(mailboxId, mailbox) {
        const consolidatedMailbox = consolidateMailbox.consolidateMailbox(mailbox);
        const protoMailbox = createProtoUserMailbox(consolidatedMailbox);
        await this.internalUpdateMailbox(mailboxId, protoMailbox, CURRENT_MAILBOX_VERSION);
        return { id: mailboxId, type: 'wallet', ...consolidatedMailbox };
    }
    async removeMailbox(mailboxId) {
        await this.userApi.deleteUserMailbox(mailboxId);
        return;
    }
    async internalUpdateMailbox(addressId, protoMailbox, version) {
        const encrypted = await this.mailboxCrypto.encrypt(user.user.Mailbox.encode(protoMailbox).finish());
        await this.userApi.putUserMailbox(addressId, { encryptedMailboxInformation: encoding.encodeBase64(encrypted), version });
        return protoMailbox;
    }
}
function createProtoUserMailbox(mailbox) {
    return user.user.Mailbox.create({
        identityKey: crypto.publicKeyToBytes(mailbox.identityKey),
        address: mailbox.messagingKeyParams.address,
        protocol: mailbox.messagingKeyParams.protocol,
        network: mailbox.messagingKeyParams.network,
        nonce: mailbox.messagingKeyParams.nonce,
        label: mailbox.label,
        aliases: mailbox.aliases.map(createProtoAlias),
    });
}
function createProtoAlias(alias) {
    return user.user.Mailbox.Alias.create({
        address: addressing.formatAddress(alias.address, 'mail'),
        blockSending: !alias.allowSending,
        blockReceiving: !alias.allowReceiving,
    });
}

exports.MailchainUserProfile = MailchainUserProfile;
exports.UserNotFoundError = UserNotFoundError;
