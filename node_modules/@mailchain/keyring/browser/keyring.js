import { deriveHardenedKey, ED25519ExtendedPrivateKey, ED25519PrivateKey, PrivateKeyDecrypter, PrivateKeyEncrypter } from '@mailchain/crypto';
import { encodeHexZeroX, encodeHex } from '@mailchain/encoding';
import { decodeAddressByProtocol, MAILCHAIN } from '@mailchain/addressing';
import { DERIVATION_PATH_IDENTITY_KEY_ROOT, DERIVATION_PATH_MESSAGING_KEY_ROOT, DERIVATION_PATH_ENCRYPTION_KEY_ROOT, DERIVATION_PATH_USER_PROFILE, DERIVATION_PATH_INBOX_ROOT, DERIVATION_PATH_DATE_OFFSET } from './constants.js';
import { ecdhKeyRingDecrypter } from './functions.js';

class KeyRing {
    /**
     *
     * @param accountKey This key is never stored in the key chain only used to derive other keys.
     */
    constructor(accountKey) {
        Object.defineProperty(this, "_accountIdentityKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_rootEncryptionKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_userProfileEncryptionKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_rootInboxKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // used to derive messaging keys for all protocol addresses
        Object.defineProperty(this, "_protocolAddressRootMessagingKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_accountMessagingKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._accountIdentityKey = deriveHardenedKey(ED25519ExtendedPrivateKey.fromPrivateKey(accountKey), DERIVATION_PATH_IDENTITY_KEY_ROOT);
        // used to derive all messaging keys
        const rootMessagingKey = deriveHardenedKey(ED25519ExtendedPrivateKey.fromPrivateKey(accountKey), DERIVATION_PATH_MESSAGING_KEY_ROOT);
        this._protocolAddressRootMessagingKey = deriveHardenedKey(ED25519ExtendedPrivateKey.fromPrivateKey(rootMessagingKey.privateKey), 1);
        // e.g. bob@mailchain
        const rootAccountMessagingKey = deriveHardenedKey(ED25519ExtendedPrivateKey.fromPrivateKey(rootMessagingKey.privateKey), 'protocol=mailchain');
        // default to nonce of 1 for now
        this._accountMessagingKey = deriveHardenedKey(ED25519ExtendedPrivateKey.fromPrivateKey(rootAccountMessagingKey.privateKey), 1);
        this._rootEncryptionKey = deriveHardenedKey(ED25519ExtendedPrivateKey.fromPrivateKey(accountKey), DERIVATION_PATH_ENCRYPTION_KEY_ROOT);
        this._userProfileEncryptionKey = deriveHardenedKey(ED25519ExtendedPrivateKey.fromPrivateKey(this._rootEncryptionKey.privateKey), DERIVATION_PATH_USER_PROFILE);
        this._rootInboxKey = deriveHardenedKey(ED25519ExtendedPrivateKey.fromPrivateKey(this._rootEncryptionKey.privateKey), DERIVATION_PATH_INBOX_ROOT);
    }
    /**
     * Use your Secret Recovery Phrase to authenticate your keyring.
     * @param secretRecoveryPhrase a 24 word [BIP 39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) compatible mnemonic phrase.
     */
    static fromSecretRecoveryPhrase(secretRecoveryPhrase, password) {
        return new this(ED25519PrivateKey.fromMnemonicPhrase(secretRecoveryPhrase, password));
    }
    static fromPrivateKey(key) {
        return new this(key);
    }
    rootEncryptionPublicKey() {
        return this._rootEncryptionKey.privateKey.publicKey;
    }
    rootInboxKey() {
        return this._rootInboxKey.privateKey;
    }
    inboxMessageDateOffset() {
        const year2000 = 946684800;
        const offsetKey = deriveHardenedKey(ED25519ExtendedPrivateKey.fromPrivateKey(this._rootInboxKey.privateKey), DERIVATION_PATH_DATE_OFFSET);
        const offset = Number(BigInt(encodeHexZeroX(offsetKey.bytes)) % BigInt(year2000));
        return offset;
    }
    inboxKey() {
        const inboxKey = this._rootInboxKey.privateKey;
        const decrypter = PrivateKeyDecrypter.fromPrivateKey(inboxKey);
        const encrypter = PrivateKeyEncrypter.fromPrivateKey(inboxKey);
        return { encrypt: (input) => encrypter.encrypt(input), decrypt: (input) => decrypter.decrypt(input) };
    }
    userProfileCrypto() {
        const inboxKey = this._userProfileEncryptionKey.privateKey;
        const decrypter = PrivateKeyDecrypter.fromPrivateKey(inboxKey);
        const encrypter = PrivateKeyEncrypter.fromPrivateKey(inboxKey);
        return { encrypt: (input) => encrypter.encrypt(input), decrypt: (input) => decrypter.decrypt(input) };
    }
    /**
     * Gets messaging key that can be used for signing and decrypting for a specific protocol address.
     * @param address protocol address e.g. 0x1234.... for ethereum.
     * @param protocol a {@link ProtocolType}
     * @param nonce in most cases you will want to use the latest nonce.
     * @returns
     */
    addressMessagingKey(address, protocol, nonce) {
        const decodedAddress = decodeAddressByProtocol(address, protocol).decoded;
        return this.addressBytesMessagingKey(decodedAddress, protocol, nonce);
    }
    /**
     * Gets messaging key that can be exported for a specific protocol address.
     * @param address protocol address e.g. 0x1234.... for ethereum
     * @param protocol a {@link ProtocolType}
     * @param nonce in most cases you will want to use the latest nonce.
     * @returns
     */
    addressExportableMessagingKey(address, protocol, nonce) {
        const decodedAddress = decodeAddressByProtocol(address, protocol).decoded;
        return this.addressBytesExportableMessagingKey(decodedAddress, protocol, nonce);
    }
    addressBytesMessagingKey(address, protocol, nonce) {
        // specific for the nonce
        const addressKey = this.addressBytesExportableMessagingKey(address, protocol, nonce);
        return ecdhKeyRingDecrypter(addressKey);
    }
    addressBytesExportableMessagingKey(address, protocol, nonce) {
        if (protocol === MAILCHAIN) {
            return this.accountExportableMessagingKey();
        }
        // all addresses are encoded with hex regardless of protocol to ensure consistency
        const addressKeyRoot = deriveHardenedKey(this._protocolAddressRootMessagingKey, `protocol=${protocol},address=${encodeHex(address)}`);
        // specific for the nonce
        return deriveHardenedKey(addressKeyRoot, nonce).privateKey;
    }
    accountExportableMessagingKey() {
        return this._accountMessagingKey.privateKey;
    }
    accountMessagingKey() {
        const key = this.accountExportableMessagingKey();
        return ecdhKeyRingDecrypter(key);
    }
    accountIdentityKey() {
        const key = this._accountIdentityKey.privateKey;
        return {
            curve: key.curve,
            sign: (input) => key.sign(input),
            publicKey: key.publicKey,
        };
    }
}

export { KeyRing };
