'use strict';

var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');
var addressing = require('@mailchain/addressing');
var constants = require('./constants.js');
var functions = require('./functions.js');

class KeyRing {
    /**
     *
     * @param accountKey This key is never stored in the key chain only used to derive other keys.
     */
    constructor(accountKey) {
        Object.defineProperty(this, "_accountIdentityKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_rootEncryptionKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_userProfileEncryptionKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_rootInboxKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // used to derive messaging keys for all protocol addresses
        Object.defineProperty(this, "_protocolAddressRootMessagingKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_accountMessagingKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._accountIdentityKey = crypto.deriveHardenedKey(crypto.ED25519ExtendedPrivateKey.fromPrivateKey(accountKey), constants.DERIVATION_PATH_IDENTITY_KEY_ROOT);
        // used to derive all messaging keys
        const rootMessagingKey = crypto.deriveHardenedKey(crypto.ED25519ExtendedPrivateKey.fromPrivateKey(accountKey), constants.DERIVATION_PATH_MESSAGING_KEY_ROOT);
        this._protocolAddressRootMessagingKey = crypto.deriveHardenedKey(crypto.ED25519ExtendedPrivateKey.fromPrivateKey(rootMessagingKey.privateKey), 1);
        // e.g. bob@mailchain
        const rootAccountMessagingKey = crypto.deriveHardenedKey(crypto.ED25519ExtendedPrivateKey.fromPrivateKey(rootMessagingKey.privateKey), 'protocol=mailchain');
        // default to nonce of 1 for now
        this._accountMessagingKey = crypto.deriveHardenedKey(crypto.ED25519ExtendedPrivateKey.fromPrivateKey(rootAccountMessagingKey.privateKey), 1);
        this._rootEncryptionKey = crypto.deriveHardenedKey(crypto.ED25519ExtendedPrivateKey.fromPrivateKey(accountKey), constants.DERIVATION_PATH_ENCRYPTION_KEY_ROOT);
        this._userProfileEncryptionKey = crypto.deriveHardenedKey(crypto.ED25519ExtendedPrivateKey.fromPrivateKey(this._rootEncryptionKey.privateKey), constants.DERIVATION_PATH_USER_PROFILE);
        this._rootInboxKey = crypto.deriveHardenedKey(crypto.ED25519ExtendedPrivateKey.fromPrivateKey(this._rootEncryptionKey.privateKey), constants.DERIVATION_PATH_INBOX_ROOT);
    }
    /**
     * Use your Secret Recovery Phrase to authenticate your keyring.
     * @param secretRecoveryPhrase a 24 word [BIP 39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) compatible mnemonic phrase.
     */
    static fromSecretRecoveryPhrase(secretRecoveryPhrase, password) {
        return new this(crypto.ED25519PrivateKey.fromMnemonicPhrase(secretRecoveryPhrase, password));
    }
    static fromPrivateKey(key) {
        return new this(key);
    }
    rootEncryptionPublicKey() {
        return this._rootEncryptionKey.privateKey.publicKey;
    }
    rootInboxKey() {
        return this._rootInboxKey.privateKey;
    }
    inboxMessageDateOffset() {
        const year2000 = 946684800;
        const offsetKey = crypto.deriveHardenedKey(crypto.ED25519ExtendedPrivateKey.fromPrivateKey(this._rootInboxKey.privateKey), constants.DERIVATION_PATH_DATE_OFFSET);
        const offset = Number(BigInt(encoding.encodeHexZeroX(offsetKey.bytes)) % BigInt(year2000));
        return offset;
    }
    inboxKey() {
        const inboxKey = this._rootInboxKey.privateKey;
        const decrypter = crypto.PrivateKeyDecrypter.fromPrivateKey(inboxKey);
        const encrypter = crypto.PrivateKeyEncrypter.fromPrivateKey(inboxKey);
        return { encrypt: (input) => encrypter.encrypt(input), decrypt: (input) => decrypter.decrypt(input) };
    }
    userProfileCrypto() {
        const inboxKey = this._userProfileEncryptionKey.privateKey;
        const decrypter = crypto.PrivateKeyDecrypter.fromPrivateKey(inboxKey);
        const encrypter = crypto.PrivateKeyEncrypter.fromPrivateKey(inboxKey);
        return { encrypt: (input) => encrypter.encrypt(input), decrypt: (input) => decrypter.decrypt(input) };
    }
    /**
     * Gets messaging key that can be used for signing and decrypting for a specific protocol address.
     * @param address protocol address e.g. 0x1234.... for ethereum.
     * @param protocol a {@link ProtocolType}
     * @param nonce in most cases you will want to use the latest nonce.
     * @returns
     */
    addressMessagingKey(address, protocol, nonce) {
        const decodedAddress = addressing.decodeAddressByProtocol(address, protocol).decoded;
        return this.addressBytesMessagingKey(decodedAddress, protocol, nonce);
    }
    /**
     * Gets messaging key that can be exported for a specific protocol address.
     * @param address protocol address e.g. 0x1234.... for ethereum
     * @param protocol a {@link ProtocolType}
     * @param nonce in most cases you will want to use the latest nonce.
     * @returns
     */
    addressExportableMessagingKey(address, protocol, nonce) {
        const decodedAddress = addressing.decodeAddressByProtocol(address, protocol).decoded;
        return this.addressBytesExportableMessagingKey(decodedAddress, protocol, nonce);
    }
    addressBytesMessagingKey(address, protocol, nonce) {
        // specific for the nonce
        const addressKey = this.addressBytesExportableMessagingKey(address, protocol, nonce);
        return functions.ecdhKeyRingDecrypter(addressKey);
    }
    addressBytesExportableMessagingKey(address, protocol, nonce) {
        if (protocol === addressing.MAILCHAIN) {
            return this.accountExportableMessagingKey();
        }
        // all addresses are encoded with hex regardless of protocol to ensure consistency
        const addressKeyRoot = crypto.deriveHardenedKey(this._protocolAddressRootMessagingKey, `protocol=${protocol},address=${encoding.encodeHex(address)}`);
        // specific for the nonce
        return crypto.deriveHardenedKey(addressKeyRoot, nonce).privateKey;
    }
    accountExportableMessagingKey() {
        return this._accountMessagingKey.privateKey;
    }
    accountMessagingKey() {
        const key = this.accountExportableMessagingKey();
        return functions.ecdhKeyRingDecrypter(key);
    }
    accountIdentityKey() {
        const key = this._accountIdentityKey.privateKey;
        return {
            curve: key.curve,
            sign: (input) => key.sign(input),
            publicKey: key.publicKey,
        };
    }
}

exports.KeyRing = KeyRing;
