'use strict';

var keyring = require('@mailchain/keyring');
var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');
var mail = require('@mailchain/internal/sending/mail');
var messagingKeys = require('@mailchain/internal/messagingKeys');
var convertSendMailParams = require('@mailchain/internal/sending/mail/convertSendMailParams');
var user = require('@mailchain/internal/user');
var mailbox = require('@mailchain/internal/mailbox');
var configuration = require('@mailchain/internal/configuration');

class Mailchain {
    constructor(keyRing, config) {
        Object.defineProperty(this, "keyRing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: keyRing
        });
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: config
        });
        Object.defineProperty(this, "_userProfile", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_mailboxOperations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._userProfile = user.MailchainUserProfile.create(config, keyRing.accountIdentityKey(), keyRing.userProfileCrypto());
        this._mailboxOperations = mailbox.MailchainMailboxOperations.create(config, keyRing);
    }
    static fromAccountSeed(seed, config = configuration.defaultConfiguration) {
        const identityKey = crypto.ED25519PrivateKey.fromSeed(encoding.ensureDecoded(seed, encoding.EncodingTypes.HexAny));
        const keyRing = keyring.KeyRing.fromPrivateKey(identityKey);
        return Mailchain.fromKeyRing(keyRing, config);
    }
    /**
     * Use your Secret Recovery Phrase to authenticate with the SDK.
     * You can get your Secret Recovery Phrases when registering an account or via the [settings page](https://app.mailchain.com/settings) in the application.
     * @param secretRecoveryPhrase a 24 word [BIP 39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) compatible mnemonic phrase.
     * @returns an authenticated {@link Mailchain} SDK. Use {@link Mailchain.user()} to get the currently authenticate used details
     */
    static fromSecretRecoveryPhrase(secretRecoveryPhrase, password, config = configuration.defaultConfiguration) {
        const keyRing = keyring.KeyRing.fromSecretRecoveryPhrase(secretRecoveryPhrase, password);
        return Mailchain.fromKeyRing(keyRing, config);
    }
    /**
     * @deprecated use {@link fromSecretRecoveryPhrase} instead.
     */
    static fromMnemonicPhrase(mnemonic, password, config = configuration.defaultConfiguration) {
        return Mailchain.fromSecretRecoveryPhrase(mnemonic, password, config);
    }
    static fromKeyRing(keyRing, config = configuration.defaultConfiguration) {
        return new this(keyRing, config);
    }
    /**
     * Send a mail to any blockchain or Mailchain address using any wallet registered in your Mailchain account.
     *
     * @param params {@link SendMailParams} information about message to send.
     * Required:
     * - `from` the address that the mail is being sent from.
     * - At least one of `to`, `cc`, or `bcc`, who will receive the mail.
     * - `subject` of the mail.
     * - `content` both `html` and `text`.
     * @param options {@link SendMailOptions} additional options for sending mail.
     *
     * @example
     * import { Mailchain } from '@mailchain/sdk';
     *
     * const secretRecoveryPhrase = process.env.SECRET_RECOVERY_PHRASE!; // 24 word mnemonicPhrase
     *
     * const mailchain = Mailchain.fromSecretRecoveryPhrase(secretRecoveryPhrase);
     *
     * const result = await mailchain.sendMail({
     * 		from: `yoursername@mailchain.com`, // sender address
     * 		to: [`0xbb56FbD7A2caC3e4C17936027102344127b7a112@ethereum.mailchain.com`], // list of recipients (blockchain or mailchain addresses)
     * 		subject: 'My first message', // subject line
     * 		content: {
     * 			text: 'Hello Mailchain ðŸ‘‹', // plain text body
     * 			html: '<p>Hello Mailchain ðŸ‘‹</p>', // html body
     * 		},
     * });
     *
     * if (error) {
     *   // handle error
     *   console.warn('Mailchain error', error);
     *   return;
     * }
     * // handle success send mail result
     * console.log(data);
     *
     * @returns Status of the messaging sending request. {@link SentMail} contains different data
     * depending on the status of the request.
     */
    async sendMail(params, options = defaultSendMailOptions) {
        const senderMailbox = await this.getSenderMailbox(params.from, {
            messagingKeys: messagingKeys.MessagingKeys.create(this.config),
            userProfile: this._userProfile,
        });
        const senderMessagingKey = this.keyRing.addressBytesMessagingKey(senderMailbox.messagingKeyParams.address, senderMailbox.messagingKeyParams.protocol, senderMailbox.messagingKeyParams.nonce);
        const preparer = mail.MailPreparer.create(this.config);
        // prepare message
        const mailData = convertSendMailParams.toMailData(params);
        const { data: preparedMail, error: preparedMailError } = await preparer.prepareMail({
            message: mailData,
            senderMessagingKey,
        });
        if (preparedMailError) {
            return { error: preparedMailError };
        }
        const savedMessageId = await this.saveSentMessage(senderMailbox, preparedMail.message, mailData, options.saveToSentFolder);
        const distributor = mail.MailDistributor.create(this.config, senderMessagingKey);
        const { data: distributedMail, error: distributedMailError } = await distributor.distributeMail({
            distributions: preparedMail.distributions,
            resolvedAddresses: preparedMail.resolvedAddresses,
        });
        if (distributedMailError) {
            return { error: distributedMailError };
        }
        if (options.saveToSentFolder && savedMessageId) {
            await this._mailboxOperations.markOutboxMessageAsSent(savedMessageId);
        }
        return {
            data: {
                savedMessageId,
                sentMailDeliveryRequests: distributedMail,
            },
        };
    }
    /**
     * Gets the username and mail address corresponding to the authenticated user.
     *
     * @throws a {@link UserNotFoundError} error if the mnemonic phrase or seed does not have a user registered.
     * A user must be registered via {@link https://app.mailchain.com/register}.
     * Check the mnemonic phrase or seed is correct.
     *
     * @returns a promise containing the username and the mail address of the logged in user.
     *
     * @example
     *
     * import { Mailchain } from "@mailchain/sdk";
     *
     * const secretRecoveryPhrase = process.env.SECRET_RECOVERY_PHRASE!; // 24 word mnemonicPhrase
     *
     * const mailchain = Mailchain.fromSecretRecoveryPhrase(secretRecoveryPhrase);
     *
     * const user = await mailchain.user();
     *
     * console.log(`username: ${user.username}, address: ${user.address}`);
     * // username: alice, address: alice@mailchain.com
     */
    async user() {
        return this._userProfile.getUsername();
    }
    async getSenderMailbox(fromAddress, config) {
        const mailboxes = await config.userProfile.mailboxes();
        const { data, error } = await config.messagingKeys.resolve(fromAddress);
        if (error) {
            throw error;
        }
        const { identityKey } = data;
        if (identityKey == null) {
            throw Error(`${fromAddress} is not registered with Mailchain services`);
        }
        const foundMailbox = mailboxes.find((mailbox) => {
            // comparing raw address is case sensitive
            return crypto.isPublicKeyEqual(mailbox.identityKey, identityKey);
        });
        if (foundMailbox == null) {
            throw Error(`${fromAddress} is not registered by this account`);
        }
        return foundMailbox;
    }
    async saveSentMessage(senderMailbox, payload, content, saveToSentFolder) {
        if (saveToSentFolder) {
            const { messageId } = await this._mailboxOperations.saveSentMessage({
                userMailbox: senderMailbox,
                payload,
                content,
            });
            return messageId;
        }
        // no message id to return as not saved
        return;
    }
}
const defaultSendMailOptions = {
    saveToSentFolder: true,
};

exports.Mailchain = Mailchain;
