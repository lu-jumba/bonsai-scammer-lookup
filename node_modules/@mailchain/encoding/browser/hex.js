// EncodeHexZeroX encodes src into "0x"+hex.Encode. As a convenience, it returns the encoding type used,
// but this value is always TypeHex0XPrefix.
// EncodeHexZeroX uses hexadecimal encoding prefixed with "0x".
function encodeHexZeroX(input) {
    return '0x' + encodeHex(input);
}
// DecodeHexZeroX returns the bytes represented by the hexadecimal string src.
function decodeHexZeroX(input) {
    if (input === '') {
        throw new RangeError('empty hex string');
    }
    if (!input.startsWith('0x')) {
        throw new RangeError("must start with '0x'");
    }
    return decodeHex(input.slice(2));
}
// EncodeHex returns the hexadecimal encoding of src.
function encodeHex(input) {
    return Buffer.from(input).toString('hex');
}
// DecodeHex returns the bytes represented by the hexadecimal string s.
function decodeHex(input) {
    const output = new Uint8Array(Buffer.from(input, 'hex'));
    if (output.length === 0 || input.length === 0) {
        throw RangeError('invalid hex encoding');
    }
    return output;
}
function isHex(input) {
    return new RegExp('^[a-fA-F0-9]+$').test(input);
}
function isHexZeroX(input) {
    return new RegExp('^0x[a-fA-F0-9]+$').test(input);
}
function isAnyHex(input) {
    if (input.startsWith('0x')) {
        input = input.substring(2);
    }
    return isHex(input);
}
function decodeHexAny(input) {
    if (input.startsWith('0x')) {
        input = input.substring(2);
    }
    return decodeHex(input);
}

export { decodeHex, decodeHexAny, decodeHexZeroX, encodeHex, encodeHexZeroX, isAnyHex, isHex, isHexZeroX };
