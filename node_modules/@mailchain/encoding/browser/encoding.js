import { decodeBase32, encodeBase32 } from './base32.js';
import { decodeBase58, encodeBase58 } from './base58.js';
import { encodeBase64UrlSafe } from './base64.js';
import { EncodingTypes } from './consts.js';
import { decodeHexAny, decodeHexZeroX, decodeHex, encodeHexZeroX, encodeHex } from './hex.js';
import { decodeUtf8, encodeUtf8 } from './utf8.js';

class UnsupportedEncodingError extends Error {
    constructor(encoding) {
        super(`Encoding [${encoding}] not supported`);
    }
}
/**
 * Decode returns the bytes represented by the decoded string src.
 * Decode uses the decode method mapped to kind parameter.
 *
 * If the input is kind is unknown or the input is malformed for the decode method it returns an error.
 * @param encoding
 * @param src
 * @returns
 */
function decode(encoding, src) {
    switch (encoding.toLowerCase()) {
        case EncodingTypes.Base58:
            return decodeBase58(src);
        case EncodingTypes.Hex:
            return decodeHex(src);
        case EncodingTypes.Hex0xPrefix:
            return decodeHexZeroX(src);
        case EncodingTypes.Utf8:
            return decodeUtf8(src);
        case EncodingTypes.Base32:
            return decodeBase32(src);
        case EncodingTypes.HexAny:
            return decodeHexAny(src);
        default:
            throw new UnsupportedEncodingError(encoding);
    }
}
/**
 * Encode returns the bytes encoded as requested by the encoding parameter.
 * @param encoding
 * @param src
 * @returns encoded value
 */
function encode(encoding, src) {
    switch (encoding.toLowerCase()) {
        case EncodingTypes.Base58:
            return encodeBase58(src);
        case EncodingTypes.Hex:
            return encodeHex(src);
        case EncodingTypes.Hex0xPrefix:
            return encodeHexZeroX(src);
        case EncodingTypes.Base64:
            return encodeBase64UrlSafe(src);
        case EncodingTypes.Utf8:
            return encodeUtf8(src);
        case EncodingTypes.Base32:
            return encodeBase32(src);
        default:
            throw new UnsupportedEncodingError(encoding);
    }
}

export { decode, encode };
