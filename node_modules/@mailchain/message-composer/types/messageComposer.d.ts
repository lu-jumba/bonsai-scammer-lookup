/// <reference types="node" />
import { HEADER_LABELS } from './consts';
import { MessageComposerContext } from './messageComposerContext';
import { Address, Attachment, HeaderAttribute } from './types';
/** The result from {@link MessageComposer#build}. */
export type ComposedMessage = {
    /**
     * Built string message meant to be received (saved to Sent folder) by the sender.
     *
     * Warning: contains the 'Bcc' recipients and might be inappropriate to show this message to others.
     */
    forSender: string;
    /**
     * Built message meant to be sent to all the visible recipients such as 'To' and 'Cc'.
     */
    forVisibleRecipients: string;
    /**
     * Built message meant to be sent to each 'Bcc' individually. In the 'Bcc' header only their mailbox is shown.
     *
     * If you don't with to send these individually and opt to have one delivery for all the 'Bcc', it is ok to send the
     * message from {@link ComposedMessage#forVisibleRecipients}, with the note of that might get marked as spam by mail clients.
     */
    forBlindedRecipients: [Address, string][];
};
export declare class MessageComposer {
    private readonly _ctx;
    private readonly _headers;
    private readonly _overrideHeaders;
    private readonly _messages;
    private readonly _attachments;
    constructor(_ctx: MessageComposerContext);
    /** Set the `Message-ID` field for the message. If not set, random one would be generated. */
    id(value: string): MessageComposer;
    /** Set the `Subject` filed for the message. If it consists of non US-ASCII characters, it will get encoded. */
    subject(value: string): MessageComposer;
    /** Set the `From` filed for the message. This is required field and must be set. */
    from(from: Address): MessageComposer;
    /**
     * Set the recipients for the message based on the `type` parameter.
     *
     * Note: will override any pre-existing recipients for the given `type` when reinvoked with the same `type`.
     */
    recipients(type: (typeof HEADER_LABELS)['To' | 'Cc' | 'Bcc'], ...recipients: Address[]): MessageComposer;
    /**
     * Set the address that the reply message should be sent to when you want the reply to go to an address that is different than the `From:` address.
     */
    replyTo(address: Address): MessageComposer;
    /** Set the Date field for the message. If not set, timestamp of the time invoking `build` will set. */
    date(value: Date): MessageComposer;
    /**
     * Set your own header with its own value.
     *
     * @param label the label for the header, can be any string containing just US-ASCII printable characters (without white space characters).
     * @param value the value for the header, can be any `string` or {@link Date} or {@link Address} array. Providing other type values will fail.
     * @param attrs custom set of attributes that will be applied to the header.
     */
    customHeader<T extends string | Date | Address[]>(label: string, value: T, ...attrs: HeaderAttribute[]): MessageComposer;
    /**
     * Set (override any existing) custom header that will be applied to the message of the referenced `address`. The bcc recipient is provided via {@link MessageComposer.recipients}.
     *
     * This method is useful if there are custom header private value that only the Bcc recipient should be able to access.
     *
     * @param address the {@link Address.address} of the `Bcc` recipient
     * @param label see `label` docs in {@link MessageComposer.customHeader}.
     * @param value see `value` docs in {@link MessageComposer.customHeader}.
     * @param attrs see `attrs` docs in {@link MessageComposer.customHeader}.
     */
    overrideBccHeader<T extends string | Date | Address[]>(address: string, label: string, value: T, ...attrs: HeaderAttribute[]): MessageComposer;
    /**
     * Set (override any existing) custom header that will be applied to the message of the sender {@link ComposedMessage.forSender}.
     *
     * This method is useful if there is some header value only meant for the sender of the message.
     *
     * @param label see `label` docs in {@link MessageComposer.customHeader}.
     * @param value see `value` docs in {@link MessageComposer.customHeader}.
     * @param attrs see `attrs` docs in {@link MessageComposer.customHeader}.
     */
    overrideSenderHeader<T extends string | Date | Address[]>(label: string, value: T, ...attrs: HeaderAttribute[]): MessageComposer;
    private internalCustomHeader;
    /**
     * Set the content of the message for the defined type.
     *
     * @param type `"html"` will set the content for `text/html` and `"plain"` for `text/plain`
     * @param content the content of the message. If `string` is provided, it needs to be already base64 encoded. If it is {@link Buffer} it will be encoded by the library.
     */
    message(type: 'html' | 'plain', content: string | Buffer): MessageComposer;
    /**
     * Add new attachment to the message.
     */
    attachment(attachment: Attachment): MessageComposer;
    /**
     * Build the MIME message of the composed message.
     */
    build(): Promise<ComposedMessage>;
}
/**
 * Create new instance of {@ink MessageComposer}.
 *
 * @param customCtx inject your own context (dependencies) into the composer. Useful when one does not want to depend on the `@mailchain/encoding` package.
 */
export declare function createMessageComposer(customCtx?: MessageComposerContext): MessageComposer;
