'use strict';

var consts = require('./consts.js');
var headerFactories = require('./headerFactories.js');

async function concludeHeaders(headers, ctx) {
    const finalHeaders = new Map(headers);
    const fromHeader = finalHeaders.get(consts.HEADER_LABELS.From);
    if (fromHeader == null)
        throw new Error('defining FROM is required, more info https://www.rfc-editor.org/rfc/rfc5322#section-3.6');
    finalHeaders.set(consts.HEADER_LABELS.MimeVersion, headerFactories.createHeader(consts.HEADER_LABELS.MimeVersion, '1.0'));
    if (!finalHeaders.has(consts.HEADER_LABELS.MessageId)) {
        finalHeaders.set(consts.HEADER_LABELS.MessageId, await fallbackMessageId(fromHeader.value[0], ctx));
    }
    if (!finalHeaders.has(consts.HEADER_LABELS.Date)) {
        finalHeaders.set(consts.HEADER_LABELS.Date, await fallbackDate());
    }
    return finalHeaders;
}
async function fallbackMessageId(from, ctx) {
    const senderDomain = from.address.split('@')[1];
    const idValue = await ctx.encodeBase64(await ctx.random(32));
    return headerFactories.createMessageIdHeader(consts.HEADER_LABELS.MessageId, [`${idValue}@${senderDomain}`]);
}
async function fallbackDate(_ctx) {
    return headerFactories.createHeader(consts.HEADER_LABELS.Date, new Date());
}

exports.concludeHeaders = concludeHeaders;
exports.fallbackDate = fallbackDate;
exports.fallbackMessageId = fallbackMessageId;
