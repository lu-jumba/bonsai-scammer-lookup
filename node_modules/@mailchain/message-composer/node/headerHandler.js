'use strict';

var formatDate = require('date-fns/format');
var enUS = require('date-fns/locale/en-US');
var hasOnlyAscii = require('./hasOnlyAscii.js');
var folding = require('./folding.js');
var types = require('./types.js');
var consts = require('./consts.js');

/**
 * Processes all the headers and outputs single `string` chunk that represents the headers into MIME format.
 *
 * Note: there isn't leading/trailing CRLF of the output, you need to add your own if you want one.
 */
async function buildHeaders(headers, ctx) {
    const exportedHeaders = new Array();
    for (const header of headers) {
        const exportedHeader = await exportHeader(header, ctx);
        exportedHeaders.push(exportedHeader);
    }
    return exportedHeaders.join(consts.CRLF);
}
/**
 * Export single {@link Header} into it's MIME format. May contain multiple lines if the contents have been folded.
 *
 * Example: `"Subject: This is the subject of the message"`
 */
async function exportHeader(header, ctx) {
    const headerValue = await exportHeaderValue(header, ctx);
    if (header.attrs == null || header.attrs.length === 0)
        return `${header.label}: ${headerValue}`;
    const headerAttrs = await exportHeaderAttributes(header.attrs, ctx);
    return `${header.label}: ${folding.contentAppendWithFolding(headerValue, headerAttrs, consts.LINE_LENGTH_FOLD)}`;
}
/** Export just the {@link Header#value} part of the header. The {@link Header#label} is not exported. */
async function exportHeaderValue(header, ctx) {
    if (types.isStringHeader(header))
        return exportStringHeader(header, ctx);
    if (types.isDateHeader(header))
        return exportDateHeader(header);
    if (types.isAddressHeader(header))
        return exportAddressHeader(header);
    if (types.isMessageIdHeader(header))
        return exportMessageIdHeader(header);
    throw new Error(`cannot export value for header [${header.label}]`);
}
/** Export the {@link Header#attrs} part of the header as separate element in the resulting `string[]` array. */
async function exportHeaderAttributes(attrs, ctx) {
    // TODO: Not taking line length limit into consideration
    return await Promise.all(attrs.map(async ([attrKey, attrValue]) => {
        const value = hasOnlyAscii.hasOnlyPrintableUsAscii(attrValue)
            ? attrValue
            : `=?UTF-8?B?${await ctx.encodeBase64(await ctx.decodeUtf8(attrValue))}?=`;
        if (attrKey != null)
            return `${attrKey}="${value}"`;
        return `"${value}"`;
    }));
}
/** Export the `string` value out of {@link StringHeader}. It takes into consideration length of the value and the encoding of it. */
async function exportStringHeader(header, ctx) {
    if (hasOnlyAscii.hasOnlyPrintableUsAscii(header.value)) {
        return folding.semanticLineFold(header.value, consts.LINE_LENGTH_FOLD);
    }
    const utf8Array = await ctx.decodeUtf8(header.value);
    const base64Encoded = await ctx.encodeBase64(utf8Array);
    return folding.simpleHardFold(base64Encoded, {
        lineLength: consts.LINE_LENGTH_FOLD,
        prefix: '=?UTF-8?B?',
        suffix: '?=',
        padNewLines: true,
        encodingConsideration: 'base64',
    });
}
/**
 * Export the `Date` value out of {@link DateHeader}.
 *
 * Example: Wed, 17 Aug 2022 10:01:56 +0000
 */
async function exportDateHeader(header, _ctx) {
    return formatDate(header.value, 'EEE, dd MMM yyyy HH:mm:ss xxxx', { locale: enUS });
}
/**
 * Export the addresses out of the {@link AddressHeader}.
 * It joins every address into new line divided with `",CRLF "`, ready to be appended to the header label.
 *
 * Example:
 * ```
 * "Alice Lastname" <alice@mailchain.com>,
 * "Bob Lastname" <bob@mailchain.com>
 * ```
 */
async function exportAddressHeader(header, _ctx) {
    // TODO: Check for other ASCII characters that need to be escaped
    // TODO: Check for non ASCII characters (base64 encode)
    // TODO: check for length (going optimistically for now, splitting on each recipient)
    return header.value
        .map((r) => {
        return r.name?.length ? `"${r.name}" <${r.address}>` : `<${r.address}>`;
    })
        .join(`,${consts.CRLF}${consts.HTAB}`);
}
async function exportMessageIdHeader(header, _ctx) {
    return header.value.ids
        .map((id) => (id.startsWith('<') && id.endsWith('>') ? id : `<${id}>`))
        .join(`${consts.CRLF}${consts.HTAB}`);
}

exports.buildHeaders = buildHeaders;
exports.exportAddressHeader = exportAddressHeader;
exports.exportDateHeader = exportDateHeader;
exports.exportHeader = exportHeader;
exports.exportHeaderAttributes = exportHeaderAttributes;
exports.exportHeaderValue = exportHeaderValue;
exports.exportMessageIdHeader = exportMessageIdHeader;
exports.exportStringHeader = exportStringHeader;
