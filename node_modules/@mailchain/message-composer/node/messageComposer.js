'use strict';

var consts = require('./consts.js');
var contentHandler = require('./contentHandler.js');
var fallback = require('./fallback.js');
var hasOnlyAscii = require('./hasOnlyAscii.js');
var headerFactories = require('./headerFactories.js');
var headerHandler = require('./headerHandler.js');
var headerOrder = require('./headerOrder.js');
var messageComposerContext = require('./messageComposerContext.js');
var types = require('./types.js');

class MessageComposer {
    constructor(_ctx) {
        Object.defineProperty(this, "_ctx", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _ctx
        });
        Object.defineProperty(this, "_headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "_overrideHeaders", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "_messages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "_attachments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
    /** Set the `Message-ID` field for the message. If not set, random one would be generated. */
    id(value) {
        this._headers.set(consts.HEADER_LABELS.MessageId, headerFactories.createMessageIdHeader(consts.HEADER_LABELS.MessageId, [value]));
        return this;
    }
    /** Set the `Subject` filed for the message. If it consists of non US-ASCII characters, it will get encoded. */
    subject(value) {
        this._headers.set(consts.HEADER_LABELS.Subject, headerFactories.createHeader(consts.HEADER_LABELS.Subject, value));
        return this;
    }
    /** Set the `From` filed for the message. This is required field and must be set. */
    from(from) {
        this._headers.set(consts.HEADER_LABELS.From, headerFactories.createHeader(consts.HEADER_LABELS.From, [from]));
        return this;
    }
    /**
     * Set the recipients for the message based on the `type` parameter.
     *
     * Note: will override any pre-existing recipients for the given `type` when reinvoked with the same `type`.
     */
    recipients(type, ...recipients) {
        this._headers.set(type, headerFactories.createHeader(type, [...recipients]));
        return this;
    }
    /**
     * Set the address that the reply message should be sent to when you want the reply to go to an address that is different than the `From:` address.
     */
    replyTo(address) {
        this._headers.set(consts.HEADER_LABELS.ReplyTo, headerFactories.createHeader(consts.HEADER_LABELS.ReplyTo, [address]));
        return this;
    }
    /** Set the Date field for the message. If not set, timestamp of the time invoking `build` will set. */
    date(value) {
        this._headers.set(consts.HEADER_LABELS.Date, headerFactories.createHeader(consts.HEADER_LABELS.Date, value));
        return this;
    }
    /**
     * Set your own header with its own value.
     *
     * @param label the label for the header, can be any string containing just US-ASCII printable characters (without white space characters).
     * @param value the value for the header, can be any `string` or {@link Date} or {@link Address} array. Providing other type values will fail.
     * @param attrs custom set of attributes that will be applied to the header.
     */
    customHeader(label, value, ...attrs) {
        return this.internalCustomHeader(this._headers, label, value, ...attrs);
    }
    /**
     * Set (override any existing) custom header that will be applied to the message of the referenced `address`. The bcc recipient is provided via {@link MessageComposer.recipients}.
     *
     * This method is useful if there are custom header private value that only the Bcc recipient should be able to access.
     *
     * @param address the {@link Address.address} of the `Bcc` recipient
     * @param label see `label` docs in {@link MessageComposer.customHeader}.
     * @param value see `value` docs in {@link MessageComposer.customHeader}.
     * @param attrs see `attrs` docs in {@link MessageComposer.customHeader}.
     */
    overrideBccHeader(address, label, value, ...attrs) {
        if (!this._overrideHeaders.has(address)) {
            this._overrideHeaders.set(address, new Map());
        }
        return this.internalCustomHeader(this._overrideHeaders.get(address), label, value, ...attrs);
    }
    /**
     * Set (override any existing) custom header that will be applied to the message of the sender {@link ComposedMessage.forSender}.
     *
     * This method is useful if there is some header value only meant for the sender of the message.
     *
     * @param label see `label` docs in {@link MessageComposer.customHeader}.
     * @param value see `value` docs in {@link MessageComposer.customHeader}.
     * @param attrs see `attrs` docs in {@link MessageComposer.customHeader}.
     */
    overrideSenderHeader(label, value, ...attrs) {
        if (!this._overrideHeaders.has(consts.HEADER_LABELS.From)) {
            this._overrideHeaders.set(consts.HEADER_LABELS.From, new Map());
        }
        return this.internalCustomHeader(this._overrideHeaders.get(consts.HEADER_LABELS.From), label, value, ...attrs);
    }
    internalCustomHeader(headerStore, label, value, ...attrs) {
        if (!hasOnlyAscii.hasOnlyPrintableUsAscii(label, false)) {
            throw new Error(`invalid header label [${label}]. Header label should be composed only of printable US-ASCII characters without WSC.`);
        }
        headerStore.set(`custom-${label}`, headerFactories.createHeader(label, value, ...attrs));
        return this;
    }
    /**
     * Set the content of the message for the defined type.
     *
     * @param type `"html"` will set the content for `text/html` and `"plain"` for `text/plain`
     * @param content the content of the message. If `string` is provided, it needs to be already base64 encoded. If it is {@link Buffer} it will be encoded by the library.
     */
    message(type, content) {
        this._messages.set(type, {
            headers: [
                headerFactories.createHeader(consts.HEADER_LABELS.ContentType, `text/${type}`, ['charset', 'UTF-8']),
                headerFactories.createHeader(consts.HEADER_LABELS.ContentTransferEncoding, `base64`),
            ],
            content,
        });
        return this;
    }
    /**
     * Add new attachment to the message.
     */
    attachment(attachment) {
        this._attachments.push({
            headers: [
                headerFactories.createHeader(consts.HEADER_LABELS.ContentType, attachment.contentType),
                headerFactories.createHeader(consts.HEADER_LABELS.ContentDisposition, 'attachment', ['filename', attachment.filename]),
                headerFactories.createHeader(consts.HEADER_LABELS.ContentTransferEncoding, 'base64'),
                headerFactories.createHeader(consts.HEADER_LABELS.ContentId, `<${attachment.cid}>`),
            ],
            content: attachment.content,
        });
        return this;
    }
    /**
     * Build the MIME message of the composed message.
     */
    async build() {
        const finalHeaders = await fallback.concludeHeaders(this._headers, this._ctx);
        const contentPart = await contentHandler.buildMessageAndAttachments([...this._messages.values()], this._attachments, this._ctx);
        if (typeof contentPart !== 'string') {
            finalHeaders.set(consts.HEADER_LABELS.ContentType, contentPart.boundaryHeader);
        }
        const finalHeadersForSender = new Map(finalHeaders);
        if (this._overrideHeaders.has(consts.HEADER_LABELS.From)) {
            const overrideHeaders = this._overrideHeaders.get(consts.HEADER_LABELS.From);
            overrideHeaders.forEach((value, key) => finalHeadersForSender.set(key, value));
        }
        const builtHeadersForSender = await headerHandler.buildHeaders([...finalHeadersForSender.values()].sort(headerOrder.byHeaderOrder), this._ctx);
        const finalHeadersVisibleRecipients = new Map(finalHeaders);
        finalHeadersVisibleRecipients.delete(consts.HEADER_LABELS.Bcc);
        const builtHeadersForToAndCc = await headerHandler.buildHeaders([...finalHeadersVisibleRecipients.values()].sort(headerOrder.byHeaderOrder), this._ctx);
        const builtHeadersForBcc = [];
        const bccHeader = finalHeaders.get(consts.HEADER_LABELS.Bcc);
        if (bccHeader && types.isAddressHeader(bccHeader)) {
            for (const bccAddress of bccHeader.value) {
                const finalBccHeaders = new Map(finalHeaders);
                if (this._overrideHeaders.has(bccAddress.address)) {
                    const overrideHeaders = this._overrideHeaders.get(bccAddress.address);
                    overrideHeaders.forEach((value, key) => finalBccHeaders.set(key, value));
                }
                finalBccHeaders.set(consts.HEADER_LABELS.Bcc, headerFactories.createHeader(consts.HEADER_LABELS.Bcc, [bccAddress]));
                const builtHeaders = await headerHandler.buildHeaders([...finalBccHeaders.values()].sort(headerOrder.byHeaderOrder), this._ctx);
                builtHeadersForBcc.push([bccAddress, concatParts(builtHeaders, contentPart)]);
            }
        }
        return {
            forSender: concatParts(builtHeadersForSender, contentPart),
            forVisibleRecipients: concatParts(builtHeadersForToAndCc, contentPart),
            forBlindedRecipients: builtHeadersForBcc,
        };
    }
}
function concatParts(headers, contents) {
    return headers + consts.CRLF + (typeof contents === 'string' ? contents : consts.CRLF + contents.content);
}
/**
 * Create new instance of {@ink MessageComposer}.
 *
 * @param customCtx inject your own context (dependencies) into the composer. Useful when one does not want to depend on the `@mailchain/encoding` package.
 */
function createMessageComposer(customCtx) {
    return new MessageComposer(customCtx ?? messageComposerContext.defaultMessageComposerContext());
}

exports.MessageComposer = MessageComposer;
exports.createMessageComposer = createMessageComposer;
