'use strict';

var consts = require('./consts.js');
var folding = require('./folding.js');
var headerFactories = require('./headerFactories.js');
var headerHandler = require('./headerHandler.js');
var headerOrder = require('./headerOrder.js');

async function buildMessageAndAttachments(messageParts, attachmentParts, ctx) {
    const builtMessageParts = await buildContentParts(messageParts, false, ctx);
    // No attachments, exporting just as as string or 'multipart/alternative'
    if (attachmentParts.length === 0) {
        if (typeof builtMessageParts === 'string')
            return builtMessageParts;
        return {
            boundaryHeader: headerFactories.contentTypeBoundaryHeader('alternative', builtMessageParts.boundary),
            content: builtMessageParts.parts,
        };
    }
    const builtAttachmentParts = await buildContentParts(attachmentParts, true, ctx);
    const mixedBoundaryLine = `--${builtAttachmentParts.boundary}`;
    let content = mixedBoundaryLine + consts.CRLF;
    if (typeof builtMessageParts === 'string') {
        content += builtMessageParts + consts.CRLF;
    }
    else {
        const altHeader = headerFactories.contentTypeBoundaryHeader('alternative', builtMessageParts.boundary);
        content += (await headerHandler.exportHeader(altHeader, ctx)) + consts.CRLF + consts.CRLF;
        content += builtMessageParts.parts + consts.CRLF;
    }
    content += builtAttachmentParts.parts;
    return { boundaryHeader: headerFactories.contentTypeBoundaryHeader('mixed', builtAttachmentParts.boundary), content };
}
async function buildContentParts(parts, forceMultipart, ctx) {
    const builtParts = await Promise.all(parts.map((p) => buildContentPart(p, ctx)));
    if (builtParts.length === 1 && !forceMultipart)
        return builtParts[0];
    const boundary = (await ctx.encodeBase64(await ctx.random(9))).toUpperCase();
    const boundaryLine = `--${boundary}`;
    const builtPartsStr = builtParts.reduce((acc, curr, i) => {
        acc += boundaryLine + consts.CRLF; // Append boundaryLine before each part
        acc += curr + consts.CRLF;
        if (i === builtParts.length - 1) {
            // Append boundaryLine only on the last part
            acc += boundaryLine;
        }
        return acc;
    }, '');
    return {
        boundary,
        parts: builtPartsStr,
    };
}
async function buildContentPart({ content, headers }, ctx) {
    let result = await headerHandler.buildHeaders(headers.sort(headerOrder.byHeaderOrder), ctx);
    result += consts.CRLF + consts.CRLF; // leave out blank line
    const encodedContent = typeof content === 'string' ? content : await ctx.encodeBase64(Uint8Array.from(content));
    result += folding.simpleHardFold(encodedContent, { lineLength: consts.LINE_LENGTH_FOLD, encodingConsideration: 'base64' });
    return result;
}

exports.buildContentPart = buildContentPart;
exports.buildContentParts = buildContentParts;
exports.buildMessageAndAttachments = buildMessageAndAttachments;
