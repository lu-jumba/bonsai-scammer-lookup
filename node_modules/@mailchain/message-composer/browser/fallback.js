import { HEADER_LABELS } from './consts.js';
import { createHeader, createMessageIdHeader } from './headerFactories.js';

async function concludeHeaders(headers, ctx) {
    const finalHeaders = new Map(headers);
    const fromHeader = finalHeaders.get(HEADER_LABELS.From);
    if (fromHeader == null)
        throw new Error('defining FROM is required, more info https://www.rfc-editor.org/rfc/rfc5322#section-3.6');
    finalHeaders.set(HEADER_LABELS.MimeVersion, createHeader(HEADER_LABELS.MimeVersion, '1.0'));
    if (!finalHeaders.has(HEADER_LABELS.MessageId)) {
        finalHeaders.set(HEADER_LABELS.MessageId, await fallbackMessageId(fromHeader.value[0], ctx));
    }
    if (!finalHeaders.has(HEADER_LABELS.Date)) {
        finalHeaders.set(HEADER_LABELS.Date, await fallbackDate());
    }
    return finalHeaders;
}
async function fallbackMessageId(from, ctx) {
    const senderDomain = from.address.split('@')[1];
    const idValue = await ctx.encodeBase64(await ctx.random(32));
    return createMessageIdHeader(HEADER_LABELS.MessageId, [`${idValue}@${senderDomain}`]);
}
async function fallbackDate(_ctx) {
    return createHeader(HEADER_LABELS.Date, new Date());
}

export { concludeHeaders, fallbackDate, fallbackMessageId };
