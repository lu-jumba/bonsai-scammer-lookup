import { privateKeyVerify, publicKeyCreate, ecdsaSign } from 'secp256k1';
import { secureRandom } from '../rand.js';
import { KindSECP256K1 } from '../keys.js';
import { SECP256K1PublicKey } from './public.js';

const PrivateKeyLen = 32;
class SECP256K1PrivateKey {
    constructor(bytes) {
        Object.defineProperty(this, "bytes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "publicKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "curve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: KindSECP256K1
        });
        this.bytes = bytes;
        if (!privateKeyVerify(this.bytes)) {
            throw RangeError('bytes are not a i9valid ECDSA private key');
        }
        this.publicKey = new SECP256K1PublicKey(publicKeyCreate(this.bytes));
    }
    static generate(rand = secureRandom) {
        return new this(rand(PrivateKeyLen));
    }
    async sign(message) {
        const sigObj = ecdsaSign(message, this.bytes);
        const ret = new Uint8Array(65);
        ret.set(sigObj.signature, 0);
        ret.set(new Uint8Array([sigObj.recid]), 64);
        return ret;
    }
}

export { PrivateKeyLen, SECP256K1PrivateKey };
