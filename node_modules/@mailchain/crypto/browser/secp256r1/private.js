import { secp256r1 } from '@noble/curves/p256';
import { secureRandom } from '../rand.js';
import { KindSECP256R1 } from '../keys.js';
import { SECP256R1PublicKey } from './public.js';

const SECP256R1PrivateKeyLen = 32;
class SECP256R1PrivateKey {
    constructor(bytes, rand = secureRandom) {
        Object.defineProperty(this, "bytes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: bytes
        });
        Object.defineProperty(this, "rand", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: rand
        });
        Object.defineProperty(this, "publicKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "curve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: KindSECP256R1
        });
        if (this.bytes.length !== SECP256R1PrivateKeyLen || !secp256r1.utils.isValidPrivateKey(this.bytes)) {
            throw RangeError('bytes are not a valid secp256r1 private key');
        }
        this.publicKey = new SECP256R1PublicKey(secp256r1.getPublicKey(this.bytes));
        this.curve = KindSECP256R1;
    }
    static generate(rand = secureRandom) {
        return new SECP256R1PrivateKey(rand(), rand);
    }
    async sign(message) {
        const sig = secp256r1.sign(message, this.bytes, { lowS: true, extraEntropy: this.rand() });
        return sig.toCompactRawBytes();
    }
}

export { SECP256R1PrivateKey, SECP256R1PrivateKeyLen };
