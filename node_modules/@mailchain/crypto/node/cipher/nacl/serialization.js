'use strict';

var keys = require('../../keys.js');
var cipher = require('../cipher.js');
var _public$1 = require('../../secp256k1/public.js');
var _public = require('../../ed25519/public.js');
var ids = require('../../multikey/ids.js');

function serializePublicKeyEncryptedContent(sealedBox, pubKey) {
    const out = new Uint8Array(sealedBox.length + pubKey.bytes.length + 2);
    out.set(new Uint8Array([cipher.NACLECDH]), 0);
    out.set(new Uint8Array([ids.idFromPublicKey(pubKey)]), 1);
    out.set(pubKey.bytes, 2);
    out.set(sealedBox, 2 + pubKey.bytes.length);
    return out;
}
function serializePrivateKeyEncryptedContent(sealedBox, keyId) {
    const out = new Uint8Array(sealedBox.length + 2);
    out.set(new Uint8Array([cipher.NACLSK]), 0);
    out.set(new Uint8Array([keyId]), 1);
    out.set(sealedBox, 2);
    return out;
}
function deserializePublicKeyEncryptedContent(input) {
    if (input[0] !== cipher.NACLECDH) {
        throw new Error('can not deserialize NaCl ECDH encrypted content');
    }
    if (input.length < 35) {
        throw new RangeError('cipher is too short'); // will result in error is less than this
    }
    const start = 2;
    let pubKeyEnd = 0;
    switch (input[1]) {
        case keys.IdSECP256K1:
            pubKeyEnd = start + 33;
            return {
                pubKey: new _public$1.SECP256K1PublicKey(input.slice(start, pubKeyEnd)),
                encryptedContent: input.slice(pubKeyEnd),
            };
        case keys.IdED25519:
            pubKeyEnd = start + _public.ED25519PublicKeyLen;
            return {
                pubKey: new _public.ED25519PublicKey(input.slice(start, pubKeyEnd)),
                encryptedContent: input.slice(pubKeyEnd),
            };
        default:
            throw Error('unrecognized pubKeyID');
    }
}
function deserializePrivateKeyEncryptedContent(input) {
    if (input[0] !== cipher.NACLSK) {
        throw new Error('can not deserialize NaCl secret key encrypted content');
    }
    if (input.length < 3) {
        throw new RangeError('cipher is too short'); // will result in error is less than this
    }
    if (![keys.IdSECP256K1, keys.IdSR25519, keys.IdED25519, keys.IdNonSpecified].includes(input[1])) {
        throw new RangeError('unknown key type');
    }
    return { encryptedContent: input.slice(2), keyId: input[1] };
}

exports.deserializePrivateKeyEncryptedContent = deserializePrivateKeyEncryptedContent;
exports.deserializePublicKeyEncryptedContent = deserializePublicKeyEncryptedContent;
exports.serializePrivateKeyEncryptedContent = serializePrivateKeyEncryptedContent;
exports.serializePublicKeyEncryptedContent = serializePublicKeyEncryptedContent;
