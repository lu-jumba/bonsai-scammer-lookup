'use strict';

var secp256k1 = require('secp256k1');
var rand = require('../rand.js');
var keys = require('../keys.js');
var _public = require('./public.js');

const PrivateKeyLen = 32;
class SECP256K1PrivateKey {
    constructor(bytes) {
        Object.defineProperty(this, "bytes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "publicKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "curve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: keys.KindSECP256K1
        });
        this.bytes = bytes;
        if (!secp256k1.privateKeyVerify(this.bytes)) {
            throw RangeError('bytes are not a i9valid ECDSA private key');
        }
        this.publicKey = new _public.SECP256K1PublicKey(secp256k1.publicKeyCreate(this.bytes));
    }
    static generate(rand$1 = rand.secureRandom) {
        return new this(rand$1(PrivateKeyLen));
    }
    async sign(message) {
        const sigObj = secp256k1.ecdsaSign(message, this.bytes);
        const ret = new Uint8Array(65);
        ret.set(sigObj.signature, 0);
        ret.set(new Uint8Array([sigObj.recid]), 64);
        return ret;
    }
}

exports.PrivateKeyLen = PrivateKeyLen;
exports.SECP256K1PrivateKey = SECP256K1PrivateKey;
