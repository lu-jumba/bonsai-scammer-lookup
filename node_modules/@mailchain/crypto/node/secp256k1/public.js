'use strict';

var secp256k1 = require('secp256k1');
var keys = require('../keys.js');

const SECP256K1PublicKeyLength = 33;
class SECP256K1PublicKey {
    constructor(bytes) {
        Object.defineProperty(this, "bytes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "curve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: keys.KindSECP256K1
        });
        this.bytes = new Uint8Array();
        switch (bytes.length) {
            case 65:
                this.bytes = secp256k1.publicKeyConvert(bytes, true);
                break;
            case SECP256K1PublicKeyLength:
                this.bytes = bytes;
                break;
            default:
                throw RangeError('invalid public key length');
        }
        if (!secp256k1.publicKeyVerify(this.bytes)) {
            throw RangeError('bytes are not a valid ECDSA public key');
        }
    }
    /**
     * fromSignature will return a public key from the message and signature. The returned key
     * will validate the hash. Meaning message and signature pairs will return a public key.
     * Additionally checks should be performed to ensure the public key is as expected.
     * @param message
     * @param signature
     * @returns
     */
    static async fromSignature(message, signature) {
        // abort if recId is not present
        if (signature.length !== 65) {
            throw Error('signature is missing recovery id');
        }
        const { recoverPublicKey } = await import('@ethersproject/signing-key');
        const recoveredKeyBytes = recoverPublicKey(message, signature);
        // TODO: this always returns a public key even if the recovered key does not match
        // the private key it was signed with. This should not be performed without knowing the address.
        // Need to include method to calculate address
        const pubKey = new SECP256K1PublicKey(Uint8Array.from(Buffer.from(recoveredKeyBytes.replace('0x', ''), 'hex')));
        return pubKey;
    }
    async verify(message, sig) {
        // remove rec id if present
        if (sig.length === 65) {
            sig = sig.slice(0, -1);
        }
        return secp256k1.ecdsaVerify(sig, message, this.bytes);
    }
}

exports.SECP256K1PublicKey = SECP256K1PublicKey;
exports.SECP256K1PublicKeyLength = SECP256K1PublicKeyLength;
