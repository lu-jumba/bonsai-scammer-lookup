'use strict';

var p256 = require('@noble/curves/p256');
var rand = require('../rand.js');
var keys = require('../keys.js');
var _public = require('./public.js');

const SECP256R1PrivateKeyLen = 32;
class SECP256R1PrivateKey {
    constructor(bytes, rand$1 = rand.secureRandom) {
        Object.defineProperty(this, "bytes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: bytes
        });
        Object.defineProperty(this, "rand", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: rand$1
        });
        Object.defineProperty(this, "publicKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "curve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: keys.KindSECP256R1
        });
        if (this.bytes.length !== SECP256R1PrivateKeyLen || !p256.secp256r1.utils.isValidPrivateKey(this.bytes)) {
            throw RangeError('bytes are not a valid secp256r1 private key');
        }
        this.publicKey = new _public.SECP256R1PublicKey(p256.secp256r1.getPublicKey(this.bytes));
        this.curve = keys.KindSECP256R1;
    }
    static generate(rand$1 = rand.secureRandom) {
        return new SECP256R1PrivateKey(rand$1(), rand$1);
    }
    async sign(message) {
        const sig = p256.secp256r1.sign(message, this.bytes, { lowS: true, extraEntropy: this.rand() });
        return sig.toCompactRawBytes();
    }
}

exports.SECP256R1PrivateKey = SECP256R1PrivateKey;
exports.SECP256R1PrivateKeyLen = SECP256R1PrivateKeyLen;
