import { SECP256K1PublicKey, ED25519PublicKey, SECP256K1PrivateKey, ED25519PrivateKey } from '@mailchain/crypto';
import { decode } from '@mailchain/encoding';
import { SECP256R1PublicKey, SECP256R1PrivateKey } from '@mailchain/crypto/secp256r1';
import { PublicKeyCurveEnum, PrivateKeyCurveEnum } from '../api/api.js';
import { ErrorUnsupportedKey } from './errors.js';

/** Convert {@link ApiPublicKey} to {@link PublicKey} */
function convertPublic(key) {
    switch (key.curve) {
        case PublicKeyCurveEnum.Ed25519:
            return new ED25519PublicKey(decode(key.encoding, key.value));
        case PublicKeyCurveEnum.Secp256k1:
            return new SECP256K1PublicKey(decode(key.encoding, key.value));
        case PublicKeyCurveEnum.Secp256r1:
            return new SECP256R1PublicKey(decode(key.encoding, key.value));
        default:
            throw new ErrorUnsupportedKey(key.curve);
    }
}
/** Convert {@link ApiPrivateKey} to {@link PrivateKey} */
function convertPrivate(key) {
    switch (key.curve) {
        case PrivateKeyCurveEnum.Ed25519:
            return ED25519PrivateKey.fromSecretKey(decode(key.encoding, key.value));
        case PrivateKeyCurveEnum.Secp256k1:
            return new SECP256K1PrivateKey(decode(key.encoding, key.value));
        case PrivateKeyCurveEnum.Secp256r1:
            return new SECP256R1PrivateKey(decode(key.encoding, key.value));
        default:
            throw new ErrorUnsupportedKey(key.curve);
    }
}

export { convertPrivate, convertPublic };
