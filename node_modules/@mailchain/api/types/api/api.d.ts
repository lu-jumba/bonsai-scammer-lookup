/**
 * Mailchain API
 * All the information needed to talk to the API.  To raise see anything wrong? Raise an [issue](https://github.com/mailchain/mailchain/issues)
 *
 * The version of the OpenAPI document: ~mailchain-version~
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import type { RequestArgs } from './base';
import { BaseAPI } from './base';
/**
 *
 * @export
 * @interface AccountAuthFinalizeRequestBody
 */
export interface AccountAuthFinalizeRequestBody {
    /**
     *
     * @type {string}
     * @memberof AccountAuthFinalizeRequestBody
     */
    'authState': string;
    /**
     * Create a new session cookie during this request. Session cookies are used to private an key to securely store secrets by the application.
     * @type {boolean}
     * @memberof AccountAuthFinalizeRequestBody
     */
    'createSessionCookie'?: boolean;
    /**
     *
     * @type {string}
     * @memberof AccountAuthFinalizeRequestBody
     */
    'params': string;
}
/**
 *
 * @export
 * @interface AccountAuthFinalizeResponseBody
 */
export interface AccountAuthFinalizeResponseBody {
    /**
     *
     * @type {EncryptedAccountSecret}
     * @memberof AccountAuthFinalizeResponseBody
     */
    'encryptedAccountSecret': EncryptedAccountSecret;
    /**
     *
     * @type {string}
     * @memberof AccountAuthFinalizeResponseBody
     */
    'session': string;
}
/**
 *
 * @export
 * @interface AccountAuthInitRequestBody
 */
export interface AccountAuthInitRequestBody {
    /**
     * Response from the proof of humanity challenge. Captcha\'s are used to prevent accounts from attempting to login form suspicious requests.
     * @type {string}
     * @memberof AccountAuthInitRequestBody
     */
    'captchaResponse': string;
    /**
     *
     * @type {string}
     * @memberof AccountAuthInitRequestBody
     */
    'params': string;
    /**
     * Username to register. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @type {string}
     * @memberof AccountAuthInitRequestBody
     */
    'username': string;
}
/**
 *
 * @export
 * @interface AccountAuthInitResponseBody
 */
export interface AccountAuthInitResponseBody {
    /**
     *
     * @type {string}
     * @memberof AccountAuthInitResponseBody
     */
    'authStartResponse': string;
    /**
     *
     * @type {string}
     * @memberof AccountAuthInitResponseBody
     */
    'state': string;
}
/**
 *
 * @export
 * @interface AccountRegisterCreateRequestBody
 */
export interface AccountRegisterCreateRequestBody {
    /**
     * Opaque authentication initialize parameters.
     * @type {string}
     * @memberof AccountRegisterCreateRequestBody
     */
    'authInitParams': string;
    /**
     * Opaque registration finalize parameters.
     * @type {string}
     * @memberof AccountRegisterCreateRequestBody
     */
    'registerFinalizeParams': string;
    /**
     * Username to register. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @type {string}
     * @memberof AccountRegisterCreateRequestBody
     */
    'username': string;
}
/**
 *
 * @export
 * @interface AccountRegisterCreateResponseBody
 */
export interface AccountRegisterCreateResponseBody {
    /**
     *
     * @type {string}
     * @memberof AccountRegisterCreateResponseBody
     */
    'authStartResponse': string;
    /**
     *
     * @type {string}
     * @memberof AccountRegisterCreateResponseBody
     */
    'state': string;
}
/**
 *
 * @export
 * @interface AccountRegisterFinalizeRequestBody
 */
export interface AccountRegisterFinalizeRequestBody {
    /**
     * Opaque authentication finalize parameters.
     * @type {string}
     * @memberof AccountRegisterFinalizeRequestBody
     */
    'authFinalizeParams': string;
    /**
     * Authentication state
     * @type {string}
     * @memberof AccountRegisterFinalizeRequestBody
     */
    'authState': string;
    /**
     * EncryptedMnemonicEntropy contains mnemonic phrase converted to entropy this is encrypt by the client using opaque client secret key.
     * @type {string}
     * @memberof AccountRegisterFinalizeRequestBody
     */
    'encryptedMnemonicEntropy': string;
    /**
     *
     * @type {MessagingKey}
     * @memberof AccountRegisterFinalizeRequestBody
     */
    'messagingKey'?: MessagingKey;
    /**
     * Session generated by opaque client after login.finish is completed
     * @type {string}
     * @memberof AccountRegisterFinalizeRequestBody
     */
    'session': string;
    /**
     * Registration session provided by the server in initial registration response is signed by the account key.
     * @type {string}
     * @memberof AccountRegisterFinalizeRequestBody
     */
    'signedRegistrationSession': string;
    /**
     * Username to register. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @type {string}
     * @memberof AccountRegisterFinalizeRequestBody
     */
    'username': string;
}
/**
 *
 * @export
 * @interface AccountRegisterFinalizeResponseBody
 */
export interface AccountRegisterFinalizeResponseBody {
    /**
     *
     * @type {string}
     * @memberof AccountRegisterFinalizeResponseBody
     */
    'session': string;
}
/**
 *
 * @export
 * @interface AccountRegisterInitRequestBody
 */
export interface AccountRegisterInitRequestBody {
    /**
     * Response from the proof of humanity challenge. Captcha\'s are used to prevent bots from registering accounts.
     * @type {string}
     * @memberof AccountRegisterInitRequestBody
     */
    'captchaResponse': string;
    /**
     * Primary public key to identify this account. Mailchain account keys are always based on the ed25519 elliptic curve.
     * @type {string}
     * @memberof AccountRegisterInitRequestBody
     */
    'identityKey': string;
    /**
     * Opaque registration request parameters.
     * @type {string}
     * @memberof AccountRegisterInitRequestBody
     */
    'registerInitParams': string;
    /**
     * Signature for registering reserved names
     * @type {string}
     * @memberof AccountRegisterInitRequestBody
     */
    'reservedNameSignature'?: string;
    /**
     * Signature proves the link between the account and identity key.
     * @type {string}
     * @memberof AccountRegisterInitRequestBody
     */
    'signature': string;
    /**
     * Username to register. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @type {string}
     * @memberof AccountRegisterInitRequestBody
     */
    'username': string;
}
/**
 *
 * @export
 * @interface AccountRegisterInitResponseBody
 */
export interface AccountRegisterInitResponseBody {
    /**
     *
     * @type {string}
     * @memberof AccountRegisterInitResponseBody
     */
    'registrationResponse': string;
    /**
     * RegistrationSession is random set of bytes that is used to identify the registration session. This must be signed with the idenitity key and sent back to the server to finalize the registration. The resigsration session is used to prevent replay attacks and ensure that account is not changed later in the process.
     * @type {string}
     * @memberof AccountRegisterInitResponseBody
     */
    'registrationSession': string;
}
/**
 *
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * Encoding used to read address bytes
     * @type {string}
     * @memberof Address
     */
    'encoding': AddressEncodingEnum;
    /**
     * Network
     * @type {string}
     * @memberof Address
     */
    'network': string;
    /**
     * Protocol
     * @type {string}
     * @memberof Address
     */
    'protocol': string;
    /**
     * Encoded address bytes.
     * @type {string}
     * @memberof Address
     */
    'value': string;
}
export declare const AddressEncodingEnum: {
    readonly Hex0xPrefix: "hex/0x-prefix";
    readonly HexPlain: "hex/plain";
    readonly TextUtf8: "text/utf-8";
    readonly Base58Plain: "base58/plain";
};
export type AddressEncodingEnum = typeof AddressEncodingEnum[keyof typeof AddressEncodingEnum];
/**
 *
 * @export
 * @interface ContractCall
 */
export interface ContractCall {
    /**
     *
     * @type {string}
     * @memberof ContractCall
     */
    'address': string;
    /**
     *
     * @type {string}
     * @memberof ContractCall
     */
    'body': string;
    /**
     *
     * @type {string}
     * @memberof ContractCall
     */
    'endpoint': string;
    /**
     * HTTP method used to call the contract, e.g. POST
     * @type {string}
     * @memberof ContractCall
     */
    'method': ContractCallMethodEnum;
    /**
     * Path of the end point
     * @type {string}
     * @memberof ContractCall
     */
    'path': string;
    /**
     *
     * @type {string}
     * @memberof ContractCall
     */
    'protocol': string;
}
export declare const ContractCallMethodEnum: {
    readonly Post: "POST";
    readonly Get: "GET";
};
export type ContractCallMethodEnum = typeof ContractCallMethodEnum[keyof typeof ContractCallMethodEnum];
/**
 *
 * @export
 * @interface DeliveryRequest
 */
export interface DeliveryRequest {
    /**
     *
     * @type {string}
     * @memberof DeliveryRequest
     */
    'data': string;
    /**
     * Hash of delivery request that can be used to validate request
     * @type {string}
     * @memberof DeliveryRequest
     */
    'hash': string;
}
/**
 *
 * @export
 * @interface EncryptedAccountSecret
 */
export interface EncryptedAccountSecret {
    /**
     * Encrypted account secret. Either entropy to create a mnemonic phrase or seed. Type of secret is indicated by `secretKind` field.
     * @type {string}
     * @memberof EncryptedAccountSecret
     */
    'encryptedAccountSecret': string;
    /**
     * Encryption type that was used to encrypt the account key
     * @type {string}
     * @memberof EncryptedAccountSecret
     */
    'encryptionKind': EncryptedAccountSecretEncryptionKindEnum;
    /**
     * What version of the encryption type was used. Versioning allows for backward compatablity.
     * @type {number}
     * @memberof EncryptedAccountSecret
     */
    'encryptionVersion': number;
    /**
     * Identifier to distinguish between different type of encrypted secrets.
     * @type {string}
     * @memberof EncryptedAccountSecret
     */
    'secretKind': EncryptedAccountSecretSecretKindEnum;
}
export declare const EncryptedAccountSecretEncryptionKindEnum: {
    readonly Opaque: "opaque";
    readonly Metamask: "metamask";
};
export type EncryptedAccountSecretEncryptionKindEnum = typeof EncryptedAccountSecretEncryptionKindEnum[keyof typeof EncryptedAccountSecretEncryptionKindEnum];
export declare const EncryptedAccountSecretSecretKindEnum: {
    readonly Account: "account";
    readonly Mnemonic: "mnemonic";
};
export type EncryptedAccountSecretSecretKindEnum = typeof EncryptedAccountSecretSecretKindEnum[keyof typeof EncryptedAccountSecretSecretKindEnum];
/**
 *
 * @export
 * @interface GetAddressMessagingKeyResponseBody
 */
export interface GetAddressMessagingKeyResponseBody {
    /**
     *
     * @type {ContractCall}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'contractCall': ContractCall;
    /**
     *
     * @type {string}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'domainPart': string;
    /**
     *
     * @type {string}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'fullAddress': string;
    /**
     *
     * @type {PublicKey}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'identityKey'?: PublicKey;
    /**
     *
     * @type {string}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'localPart': string;
    /**
     *
     * @type {PublicKey}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'messagingKey': PublicKey;
    /**
     *
     * @type {string}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'protocol': string;
    /**
     *
     * @type {ProvidedKeyProof}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'providedKeyProof'?: ProvidedKeyProof;
    /**
     *
     * @type {RegisteredKeyProof}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'registeredKeyProof'?: RegisteredKeyProof;
    /**
     *
     * @type {string}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'rootDomain': string;
}
/**
 *
 * @export
 * @interface GetDeliveryRequestsResponseBody
 */
export interface GetDeliveryRequestsResponseBody {
    /**
     * List of delivery requests
     * @type {Array<DeliveryRequest>}
     * @memberof GetDeliveryRequestsResponseBody
     */
    'deliveryRequests': Array<DeliveryRequest>;
}
/**
 *
 * @export
 * @interface GetIdentityKeyAddressesResponseBody
 */
export interface GetIdentityKeyAddressesResponseBody {
    /**
     * Addresses that have been vended for the identity key.
     * @type {Array<Address>}
     * @memberof GetIdentityKeyAddressesResponseBody
     */
    'addresses': Array<Address>;
}
/**
 *
 * @export
 * @interface GetIdentityKeyNonceResponseBody
 */
export interface GetIdentityKeyNonceResponseBody {
    /**
     *
     * @type {number}
     * @memberof GetIdentityKeyNonceResponseBody
     */
    'nonce': number;
}
/**
 *
 * @export
 * @interface GetIdentityKeyResolvableNamesResponseBody
 */
export interface GetIdentityKeyResolvableNamesResponseBody {
    /**
     *
     * @type {Array<ResolvableName>}
     * @memberof GetIdentityKeyResolvableNamesResponseBody
     */
    'resolvableNames'?: Array<ResolvableName>;
}
/**
 *
 * @export
 * @interface GetIdentityKeyResponseBody
 */
export interface GetIdentityKeyResponseBody {
    /**
     * Identity key in descriptive public key format.
     * @type {string}
     * @memberof GetIdentityKeyResponseBody
     */
    'identityKey': string;
    /**
     * Protocol this key was found on.
     * @type {string}
     * @memberof GetIdentityKeyResponseBody
     */
    'protocol': string;
}
/**
 *
 * @export
 * @interface GetMailchainPublicKeyResponseBody
 */
export interface GetMailchainPublicKeyResponseBody {
    /**
     *
     * @type {PublicKey}
     * @memberof GetMailchainPublicKeyResponseBody
     */
    'key': PublicKey;
}
/**
 *
 * @export
 * @interface GetMessageResponseBody
 */
export interface GetMessageResponseBody {
    /**
     *
     * @type {Message}
     * @memberof GetMessageResponseBody
     */
    'message': Message;
}
/**
 *
 * @export
 * @interface GetMessagesInViewResponseBody
 */
export interface GetMessagesInViewResponseBody {
    /**
     *
     * @type {Array<Message>}
     * @memberof GetMessagesInViewResponseBody
     */
    'messages': Array<Message>;
}
/**
 *
 * @export
 * @interface GetMessagesSearchResponseBody
 */
export interface GetMessagesSearchResponseBody {
    /**
     *
     * @type {Array<Message>}
     * @memberof GetMessagesSearchResponseBody
     */
    'messages': Array<Message>;
}
/**
 *
 * @export
 * @interface GetMessagingKeyResponseBody
 */
export interface GetMessagingKeyResponseBody {
    /**
     *
     * @type {PublicKey}
     * @memberof GetMessagingKeyResponseBody
     */
    'messagingKey': PublicKey;
    /**
     *
     * @type {ProvidedKeyProof}
     * @memberof GetMessagingKeyResponseBody
     */
    'proof': ProvidedKeyProof;
}
/**
 *
 * @export
 * @interface GetMsgKeyResponseBody
 */
export interface GetMsgKeyResponseBody {
    /**
     *
     * @type {PublicKey}
     * @memberof GetMsgKeyResponseBody
     */
    'messagingKey': PublicKey;
    /**
     *
     * @type {RegisteredKeyProof}
     * @memberof GetMsgKeyResponseBody
     */
    'proof': RegisteredKeyProof;
}
/**
 *
 * @export
 * @interface GetProtocolAddressNonceResponseBody
 */
export interface GetProtocolAddressNonceResponseBody {
    /**
     *
     * @type {ContractCall}
     * @memberof GetProtocolAddressNonceResponseBody
     */
    'contractCall': ContractCall;
}
/**
 *
 * @export
 * @interface GetSessionCookieResponseBody
 */
export interface GetSessionCookieResponseBody {
    /**
     * Used by the client to encrypt contents locally.
     * @type {string}
     * @memberof GetSessionCookieResponseBody
     */
    'localStorageSessionKey': string;
}
/**
 *
 * @export
 * @interface GetStatusResponseBody
 */
export interface GetStatusResponseBody {
    /**
     *
     * @type {string}
     * @memberof GetStatusResponseBody
     */
    'status': string;
}
/**
 *
 * @export
 * @interface GetUserIdentityKeyResponseBody
 */
export interface GetUserIdentityKeyResponseBody {
    /**
     * Identity key in descriptive public key format.
     * @type {string}
     * @memberof GetUserIdentityKeyResponseBody
     */
    'identityKey'?: string;
    /**
     * Proof of the username represents the identity key.
     * @type {string}
     * @memberof GetUserIdentityKeyResponseBody
     */
    'proof'?: string;
}
/**
 *
 * @export
 * @interface GetUserMailboxesResponseBody
 */
export interface GetUserMailboxesResponseBody {
    /**
     *
     * @type {Array<MailboxItem>}
     * @memberof GetUserMailboxesResponseBody
     */
    'mailboxes': Array<MailboxItem>;
}
/**
 *
 * @export
 * @interface GetUserSettingsResponseBody
 */
export interface GetUserSettingsResponseBody {
    /**
     *
     * @type {{ [key: string]: Setting; }}
     * @memberof GetUserSettingsResponseBody
     */
    'settings': {
        [key: string]: Setting;
    };
}
/**
 *
 * @export
 * @interface GetUsernameAvailableResponseBody
 */
export interface GetUsernameAvailableResponseBody {
    /**
     *
     * @type {boolean}
     * @memberof GetUsernameAvailableResponseBody
     */
    'isAvailable': boolean;
    /**
     *
     * @type {string}
     * @memberof GetUsernameAvailableResponseBody
     */
    'reason': GetUsernameAvailableResponseBodyReasonEnum;
}
export declare const GetUsernameAvailableResponseBodyReasonEnum: {
    readonly Reserved: "reserved";
    readonly Invalid: "invalid";
    readonly Taken: "taken";
    readonly Available: "available";
    readonly Unavailable: "unavailable";
};
export type GetUsernameAvailableResponseBodyReasonEnum = typeof GetUsernameAvailableResponseBodyReasonEnum[keyof typeof GetUsernameAvailableResponseBodyReasonEnum];
/**
 *
 * @export
 * @interface GetUsernameResponseBody
 */
export interface GetUsernameResponseBody {
    /**
     * Mailchain address
     * @type {string}
     * @memberof GetUsernameResponseBody
     */
    'address': string;
    /**
     * Username
     * @type {string}
     * @memberof GetUsernameResponseBody
     */
    'username': string;
}
/**
 *
 * @export
 * @interface GetVendedPrivateMessagingKeyResponseBody
 */
export interface GetVendedPrivateMessagingKeyResponseBody {
    /**
     *
     * @type {Address}
     * @memberof GetVendedPrivateMessagingKeyResponseBody
     */
    'address': Address;
    /**
     *
     * @type {PrivateKey}
     * @memberof GetVendedPrivateMessagingKeyResponseBody
     */
    'privateKey': PrivateKey;
}
/**
 * GetVersionResponseBody response
 * @export
 * @interface GetVersionResponseBody
 */
export interface GetVersionResponseBody {
    /**
     * The resolved version commit
     * @type {string}
     * @memberof GetVersionResponseBody
     */
    'commit': string;
    /**
     * The resolved version release date
     * @type {string}
     * @memberof GetVersionResponseBody
     */
    'time': string;
}
/**
 *
 * @export
 * @interface MailboxItem
 */
export interface MailboxItem {
    /**
     *
     * @type {string}
     * @memberof MailboxItem
     */
    'encryptedMailboxInformation': string;
    /**
     * ID of the mailbox to update, plain hex encoded.
     * @type {string}
     * @memberof MailboxItem
     */
    'mailboxId': string;
    /**
     *
     * @type {number}
     * @memberof MailboxItem
     */
    'version': number;
}
/**
 *
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * Encrypted preview of message base 64 encoded
     * @type {string}
     * @memberof Message
     */
    'encryptedPreview': string;
    /**
     * Message body resource id
     * @type {string}
     * @memberof Message
     */
    'messageBodyResourceId': string;
    /**
     * Unique identifier of the message. This used to perform actions on the message. Plain hex encoded string.
     * @type {string}
     * @memberof Message
     */
    'messageId': string;
    /**
     * Where message has been starred by the user
     * @type {boolean}
     * @memberof Message
     */
    'starred': boolean;
    /**
     * Mailchain labels
     * @type {Array<string>}
     * @memberof Message
     */
    'systemLabels': Array<string>;
    /**
     * Where message has been read by the user
     * @type {boolean}
     * @memberof Message
     */
    'unread': boolean;
    /**
     *
     * @type {number}
     * @memberof Message
     */
    'version': number;
}
/**
 *
 * @export
 * @interface MessagingKey
 */
export interface MessagingKey {
    /**
     * Messaging key to use for this account.
     * @type {string}
     * @memberof MessagingKey
     */
    'key'?: string;
    /**
     * Signature that proves the messaging key is valid
     * @type {string}
     * @memberof MessagingKey
     */
    'signature'?: string;
}
/**
 *
 * @export
 * @interface PasswordResetCreateRequestBody
 */
export interface PasswordResetCreateRequestBody {
    /**
     * Opaque authentication initialize parameters.
     * @type {string}
     * @memberof PasswordResetCreateRequestBody
     */
    'authInitParams': string;
    /**
     * Opaque registration finalize parameters.
     * @type {string}
     * @memberof PasswordResetCreateRequestBody
     */
    'registerFinalizeParams': string;
    /**
     * Username to reset password. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @type {string}
     * @memberof PasswordResetCreateRequestBody
     */
    'username': string;
}
/**
 *
 * @export
 * @interface PasswordResetCreateResponseBody
 */
export interface PasswordResetCreateResponseBody {
    /**
     *
     * @type {string}
     * @memberof PasswordResetCreateResponseBody
     */
    'authStartResponse': string;
    /**
     *
     * @type {string}
     * @memberof PasswordResetCreateResponseBody
     */
    'state': string;
}
/**
 *
 * @export
 * @interface PasswordResetFinalizeRequestBody
 */
export interface PasswordResetFinalizeRequestBody {
    /**
     * Opaque authentication finalize parameters.
     * @type {string}
     * @memberof PasswordResetFinalizeRequestBody
     */
    'authFinalizeParams': string;
    /**
     * Authentication state
     * @type {string}
     * @memberof PasswordResetFinalizeRequestBody
     */
    'authState': string;
    /**
     * EncryptedMnemonicEntropy contains mnemonic phrase converted to entropy this is encrypt by the client using opaque client secret key.
     * @type {string}
     * @memberof PasswordResetFinalizeRequestBody
     */
    'encryptedMnemonicEntropy': string;
    /**
     * Session generated by opaque client after login.finish is completed
     * @type {string}
     * @memberof PasswordResetFinalizeRequestBody
     */
    'session': string;
    /**
     * Reset session provided by the server in initial reset response is signed by the account key.
     * @type {string}
     * @memberof PasswordResetFinalizeRequestBody
     */
    'signedResetSession': string;
    /**
     * Username to reset. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @type {string}
     * @memberof PasswordResetFinalizeRequestBody
     */
    'username': string;
}
/**
 *
 * @export
 * @interface PasswordResetFinalizeResponseBody
 */
export interface PasswordResetFinalizeResponseBody {
    /**
     *
     * @type {string}
     * @memberof PasswordResetFinalizeResponseBody
     */
    'session': string;
}
/**
 *
 * @export
 * @interface PasswordResetInitRequestBody
 */
export interface PasswordResetInitRequestBody {
    /**
     * Response from the proof of humanity challenge. Captcha\'s are used to prevent bots from resetting passwords.
     * @type {string}
     * @memberof PasswordResetInitRequestBody
     */
    'captchaResponse': string;
    /**
     * Expires is the time the registration request expires.
     * @type {number}
     * @memberof PasswordResetInitRequestBody
     */
    'expires': number;
    /**
     * Primary public key to identify this account. Mailchain account keys are always based on the ed25519 elliptic curve.
     * @type {string}
     * @memberof PasswordResetInitRequestBody
     */
    'identityKey': string;
    /**
     * Opaque registration request parameters.
     * @type {string}
     * @memberof PasswordResetInitRequestBody
     */
    'registerInitParams': string;
    /**
     * Signature proves the link between the account and identity key.
     * @type {string}
     * @memberof PasswordResetInitRequestBody
     */
    'signature': string;
    /**
     * Username to reset password. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @type {string}
     * @memberof PasswordResetInitRequestBody
     */
    'username': string;
}
/**
 *
 * @export
 * @interface PasswordResetInitResponseBody
 */
export interface PasswordResetInitResponseBody {
    /**
     *
     * @type {string}
     * @memberof PasswordResetInitResponseBody
     */
    'registrationResponse': string;
    /**
     * resetSession is random set of bytes that is used to identify the registration session. This must be signed with the identity key and sent back to the server to finalize the registration. The registration session is used to prevent replay attacks and ensure that account is not changed later in the process.
     * @type {string}
     * @memberof PasswordResetInitResponseBody
     */
    'resetSession': string;
}
/**
 *
 * @export
 * @interface PostDeliveryRequestRequestBody
 */
export interface PostDeliveryRequestRequestBody {
    /**
     * Encrypted delivery request that contains the complete delivery request encrypted by the sender.
     * @type {string}
     * @memberof PostDeliveryRequestRequestBody
     */
    'encryptedDeliveryRequest': string;
    /**
     * Destination messaging key
     * @type {string}
     * @memberof PostDeliveryRequestRequestBody
     */
    'recipientMessagingKey': string;
}
/**
 *
 * @export
 * @interface PostDeliveryRequestResponseBody
 */
export interface PostDeliveryRequestResponseBody {
    /**
     * Delivery request id. Used to look up delivery request status.
     * @type {string}
     * @memberof PostDeliveryRequestResponseBody
     */
    'deliveryRequestID': string;
}
/**
 *
 * @export
 * @interface PostPayloadResponseBody
 */
export interface PostPayloadResponseBody {
    /**
     * Resource ID
     * @type {string}
     * @memberof PostPayloadResponseBody
     */
    'resourceId': string;
    /**
     * Where the response body is located
     * @type {string}
     * @memberof PostPayloadResponseBody
     */
    'uri': string;
}
/**
 *
 * @export
 * @interface PostUserMailboxRequestBody
 */
export interface PostUserMailboxRequestBody {
    /**
     *
     * @type {string}
     * @memberof PostUserMailboxRequestBody
     */
    'encryptedMailboxInformation': string;
    /**
     *
     * @type {number}
     * @memberof PostUserMailboxRequestBody
     */
    'version': number;
}
/**
 *
 * @export
 * @interface PostUserMailboxResponseBody
 */
export interface PostUserMailboxResponseBody {
    /**
     * Mailbox ID plain hex encoded.
     * @type {string}
     * @memberof PostUserMailboxResponseBody
     */
    'mailboxId': string;
}
/**
 *
 * @export
 * @interface PrivateKey
 */
export interface PrivateKey {
    /**
     * Curve of private key
     * @type {string}
     * @memberof PrivateKey
     */
    'curve': PrivateKeyCurveEnum;
    /**
     * Encoding used to read private key bytes
     * @type {string}
     * @memberof PrivateKey
     */
    'encoding': PrivateKeyEncodingEnum;
    /**
     * Private key bytes encoded as specified by encoding field
     * @type {string}
     * @memberof PrivateKey
     */
    'value': string;
}
export declare const PrivateKeyCurveEnum: {
    readonly Secp256k1: "secp256k1";
    readonly Ed25519: "ed25519";
    readonly Secp256r1: "secp256r1";
};
export type PrivateKeyCurveEnum = typeof PrivateKeyCurveEnum[keyof typeof PrivateKeyCurveEnum];
export declare const PrivateKeyEncodingEnum: {
    readonly _0xPrefix: "hex/0x-prefix";
    readonly Plain: "hex/plain";
};
export type PrivateKeyEncodingEnum = typeof PrivateKeyEncodingEnum[keyof typeof PrivateKeyEncodingEnum];
/**
 *
 * @export
 * @interface ProvidedKeyProof
 */
export interface ProvidedKeyProof {
    /**
     *
     * @type {string}
     * @memberof ProvidedKeyProof
     */
    'address'?: string;
    /**
     *
     * @type {string}
     * @memberof ProvidedKeyProof
     */
    'protocol'?: string;
    /**
     * Signature proving Mailchain provided the messaging key.
     * @type {string}
     * @memberof ProvidedKeyProof
     */
    'signature'?: string;
}
/**
 *
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
    /**
     * Curve of public key
     * @type {string}
     * @memberof PublicKey
     */
    'curve': PublicKeyCurveEnum;
    /**
     * Encoding used to read public key bytes
     * @type {string}
     * @memberof PublicKey
     */
    'encoding': PublicKeyEncodingEnum;
    /**
     * Public key bytes encoded as specified by encoding field
     * @type {string}
     * @memberof PublicKey
     */
    'value': string;
}
export declare const PublicKeyCurveEnum: {
    readonly Secp256k1: "secp256k1";
    readonly Ed25519: "ed25519";
    readonly Secp256r1: "secp256r1";
};
export type PublicKeyCurveEnum = typeof PublicKeyCurveEnum[keyof typeof PublicKeyCurveEnum];
export declare const PublicKeyEncodingEnum: {
    readonly _0xPrefix: "hex/0x-prefix";
    readonly Plain: "hex/plain";
};
export type PublicKeyEncodingEnum = typeof PublicKeyEncodingEnum[keyof typeof PublicKeyEncodingEnum];
/**
 *
 * @export
 * @interface PutDeliveryRequestConfirmationRequestBody
 */
export interface PutDeliveryRequestConfirmationRequestBody {
    /**
     * Signature proving address proof is valid. Hex encoded
     * @type {string}
     * @memberof PutDeliveryRequestConfirmationRequestBody
     */
    'signature': string;
}
/**
 *
 * @export
 * @interface PutEncryptedMessageRequestBody
 */
export interface PutEncryptedMessageRequestBody {
    /**
     * Date is not directly stored but rather an offset from the time of the message. The offset is derived from the users key ring making it unique and only knowable to the user.
     * @type {number}
     * @memberof PutEncryptedMessageRequestBody
     */
    'date': number;
    /**
     * Encrypted preview contains a summary of the message to support list views. User\'s client must encrypt the preview with their inbox private key.
     * @type {string}
     * @memberof PutEncryptedMessageRequestBody
     */
    'encryptedPreview': string;
    /**
     * Destination folder
     * @type {string}
     * @memberof PutEncryptedMessageRequestBody
     */
    'folder': PutEncryptedMessageRequestBodyFolderEnum;
    /**
     * Hashed messaging key of BCC recipient(s). User\'s client must hash each recipient identity key, address protocol, and their inbox public key. This will create a deterministic value that can be used for filtering but does not reveal who the message was sent to.
     * @type {Array<Array<number>>}
     * @memberof PutEncryptedMessageRequestBody
     */
    'hashedBcc'?: Array<Array<number>>;
    /**
     * Hashed messaging key of CC recipient(s). User\'s client must hash each recipient identity key, address protocol, and their inbox public key. This will create a deterministic value that can be used for filtering but does not reveal who the message was sent to.
     * @type {Array<Array<number>>}
     * @memberof PutEncryptedMessageRequestBody
     */
    'hashedCc'?: Array<Array<number>>;
    /**
     * Hashed messaging key of the sender. User\'s client must hash the sender identity key, address protocol, and their inbox public key. This will create a deterministic value that can be used for filtering but does not reveal the sender.
     * @type {Array<number>}
     * @memberof PutEncryptedMessageRequestBody
     */
    'hashedFrom': Array<number>;
    /**
     * Hashed owner of the mailbox message. User\'s client must hash the owner of the message. This distinguishes what address in the mailbox this message belongs to. This will create a deterministic value that can be used for filtering but does not reveal the sender.
     * @type {Array<number>}
     * @memberof PutEncryptedMessageRequestBody
     */
    'hashedOwner': Array<number>;
    /**
     * Hashed messaging key of each recipient. User\'s client must hash each recipient identity key, address protocol, and their inbox public key. This will create a deterministic value that can be used for filtering but does not reveal who the message was sent to.
     * @type {Array<Array<number>>}
     * @memberof PutEncryptedMessageRequestBody
     */
    'hashedTo': Array<Array<number>>;
    /**
     * Encrypted mailbox of the message. User\'s Mailbox public key is hashed before being sent.
     * @type {Array<number>}
     * @memberof PutEncryptedMessageRequestBody
     */
    'mailbox': Array<number>;
    /**
     * Resource ID of where message body is saved. This is only used when storing messages in the Mailchain inbox.
     * @type {string}
     * @memberof PutEncryptedMessageRequestBody
     */
    'messageBodyResourceId'?: string;
    /**
     *
     * @type {number}
     * @memberof PutEncryptedMessageRequestBody
     */
    'version': number;
}
export declare const PutEncryptedMessageRequestBodyFolderEnum: {
    readonly Outbox: "outbox";
    readonly Inbox: "inbox";
};
export type PutEncryptedMessageRequestBodyFolderEnum = typeof PutEncryptedMessageRequestBodyFolderEnum[keyof typeof PutEncryptedMessageRequestBodyFolderEnum];
/**
 *
 * @export
 * @interface PutMsgKeyByIDKeyRequestBody
 */
export interface PutMsgKeyByIDKeyRequestBody {
    /**
     *
     * @type {Address}
     * @memberof PutMsgKeyByIDKeyRequestBody
     */
    'address': Address;
    /**
     * Registration message locale
     * @type {string}
     * @memberof PutMsgKeyByIDKeyRequestBody
     */
    'locale': string;
    /**
     * Message for to indicate what message format was used to sign the message.
     * @type {string}
     * @memberof PutMsgKeyByIDKeyRequestBody
     */
    'messageVariant': string;
    /**
     *
     * @type {PublicKey}
     * @memberof PutMsgKeyByIDKeyRequestBody
     */
    'messagingKey': PublicKey;
    /**
     * Nonce to confirm this is the most update proof and prevent replay attacks.
     * @type {number}
     * @memberof PutMsgKeyByIDKeyRequestBody
     */
    'nonce': number;
    /**
     * Signature proving address proof is valid. Hex encoded with 0x prefix
     * @type {string}
     * @memberof PutMsgKeyByIDKeyRequestBody
     */
    'signature': string;
    /**
     * What method was used to create the signature
     * @type {string}
     * @memberof PutMsgKeyByIDKeyRequestBody
     */
    'signatureMethod': string;
}
/**
 *
 * @export
 * @interface PutUserMailboxRequestBody
 */
export interface PutUserMailboxRequestBody {
    /**
     *
     * @type {string}
     * @memberof PutUserMailboxRequestBody
     */
    'encryptedMailboxInformation': string;
    /**
     *
     * @type {number}
     * @memberof PutUserMailboxRequestBody
     */
    'version': number;
}
/**
 *
 * @export
 * @interface PutUserSettingRequestBody
 */
export interface PutUserSettingRequestBody {
    /**
     * Setting
     * @type {string}
     * @memberof PutUserSettingRequestBody
     */
    'value'?: string;
}
/**
 *
 * @export
 * @interface RegisteredKeyProof
 */
export interface RegisteredKeyProof {
    /**
     *
     * @type {Address}
     * @memberof RegisteredKeyProof
     */
    'address': Address;
    /**
     *
     * @type {PublicKey}
     * @memberof RegisteredKeyProof
     */
    'identityKey': PublicKey;
    /**
     *
     * @type {string}
     * @memberof RegisteredKeyProof
     */
    'locale'?: string;
    /**
     *
     * @type {string}
     * @memberof RegisteredKeyProof
     */
    'messagingKeyEncoding'?: string;
    /**
     *
     * @type {number}
     * @memberof RegisteredKeyProof
     */
    'nonce': number;
    /**
     * Signature that was signed by the identity key
     * @type {string}
     * @memberof RegisteredKeyProof
     */
    'signature'?: string;
    /**
     * Signing method used
     * @type {string}
     * @memberof RegisteredKeyProof
     */
    'signingMethod': RegisteredKeyProofSigningMethodEnum;
    /**
     *
     * @type {string}
     * @memberof RegisteredKeyProof
     */
    'variant'?: string;
}
export declare const RegisteredKeyProofSigningMethodEnum: {
    readonly EthereumPersonalMessage: "ethereum_personal_message";
    readonly RawEd25519: "raw_ed25519";
    readonly TezosSignedMessageMicheline: "tezos_signed_message_micheline";
};
export type RegisteredKeyProofSigningMethodEnum = typeof RegisteredKeyProofSigningMethodEnum[keyof typeof RegisteredKeyProofSigningMethodEnum];
/**
 *
 * @export
 * @interface ResolvableName
 */
export interface ResolvableName {
    /**
     * Name that can be resolved
     * @type {string}
     * @memberof ResolvableName
     */
    'name': string;
    /**
     * Resolver used to resolve name
     * @type {string}
     * @memberof ResolvableName
     */
    'resolver': string;
}
/**
 *
 * @export
 * @interface Setting
 */
export interface Setting {
    /**
     *
     * @type {boolean}
     * @memberof Setting
     */
    'isSet'?: boolean;
    /**
     *
     * @type {string}
     * @memberof Setting
     */
    'value'?: string;
}
/**
 * AddressesApi - axios parameter creator
 * @export
 */
export declare const AddressesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Get identity for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressIdentityKey: (Address: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get messaging key for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMessagingKey: (Address: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get status for messaging key for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMessagingKeyStatus: (Address: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AddressesApi - functional programming interface
 * @export
 */
export declare const AddressesApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Get identity for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressIdentityKey(Address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentityKeyResponseBody>>;
    /**
     *
     * @summary Get messaging key for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMessagingKey(Address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAddressMessagingKeyResponseBody>>;
    /**
     *
     * @summary Get status for messaging key for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMessagingKeyStatus(Address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatusResponseBody>>;
};
/**
 * AddressesApi - factory interface
 * @export
 */
export declare const AddressesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Get identity for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressIdentityKey(Address: string, options?: any): AxiosPromise<GetIdentityKeyResponseBody>;
    /**
     *
     * @summary Get messaging key for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMessagingKey(Address: string, options?: any): AxiosPromise<GetAddressMessagingKeyResponseBody>;
    /**
     *
     * @summary Get status for messaging key for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMessagingKeyStatus(Address: string, options?: any): AxiosPromise<GetStatusResponseBody>;
};
/**
 * AddressesApi - interface
 * @export
 * @interface AddressesApi
 */
export interface AddressesApiInterface {
    /**
     *
     * @summary Get identity for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getAddressIdentityKey(Address: string, options?: AxiosRequestConfig): AxiosPromise<GetIdentityKeyResponseBody>;
    /**
     *
     * @summary Get messaging key for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getAddressMessagingKey(Address: string, options?: AxiosRequestConfig): AxiosPromise<GetAddressMessagingKeyResponseBody>;
    /**
     *
     * @summary Get status for messaging key for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getAddressMessagingKeyStatus(Address: string, options?: AxiosRequestConfig): AxiosPromise<GetStatusResponseBody>;
}
/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export declare class AddressesApi extends BaseAPI implements AddressesApiInterface {
    /**
     *
     * @summary Get identity for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    getAddressIdentityKey(Address: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetIdentityKeyResponseBody, any>>;
    /**
     *
     * @summary Get messaging key for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    getAddressMessagingKey(Address: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetAddressMessagingKeyResponseBody, any>>;
    /**
     *
     * @summary Get status for messaging key for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    getAddressMessagingKeyStatus(Address: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetStatusResponseBody, any>>;
}
/**
 * AuthApi - axios parameter creator
 * @export
 */
export declare const AuthApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Finalize authentication.
     * @param {AccountAuthFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAuthFinalize: (Body?: AccountAuthFinalizeRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Start authentication.
     * @param {AccountAuthInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAuthInit: (Body?: AccountAuthInitRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Complete opaque registration flow.
     * @param {AccountRegisterCreateRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterCreate: (Body?: AccountRegisterCreateRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Finalize registration.
     * @param {AccountRegisterFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterFinalize: (Body?: AccountRegisterFinalizeRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Start registration process.
     * @param {AccountRegisterInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterInit: (Body?: AccountRegisterInitRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Complete opaque reset flow.
     * @param {PasswordResetCreateRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetCreate: (Body?: PasswordResetCreateRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Finalize reset password.
     * @param {PasswordResetFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetFinalize: (Body?: PasswordResetFinalizeRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Start reset password process.
     * @param {PasswordResetInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetInit: (Body?: PasswordResetInitRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AuthApi - functional programming interface
 * @export
 */
export declare const AuthApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Finalize authentication.
     * @param {AccountAuthFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAuthFinalize(Body?: AccountAuthFinalizeRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountAuthFinalizeResponseBody>>;
    /**
     *
     * @summary Start authentication.
     * @param {AccountAuthInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAuthInit(Body?: AccountAuthInitRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountAuthInitResponseBody>>;
    /**
     *
     * @summary Complete opaque registration flow.
     * @param {AccountRegisterCreateRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterCreate(Body?: AccountRegisterCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountRegisterCreateResponseBody>>;
    /**
     *
     * @summary Finalize registration.
     * @param {AccountRegisterFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterFinalize(Body?: AccountRegisterFinalizeRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountRegisterFinalizeResponseBody>>;
    /**
     *
     * @summary Start registration process.
     * @param {AccountRegisterInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterInit(Body?: AccountRegisterInitRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountRegisterInitResponseBody>>;
    /**
     *
     * @summary Complete opaque reset flow.
     * @param {PasswordResetCreateRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetCreate(Body?: PasswordResetCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordResetCreateResponseBody>>;
    /**
     *
     * @summary Finalize reset password.
     * @param {PasswordResetFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetFinalize(Body?: PasswordResetFinalizeRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordResetFinalizeResponseBody>>;
    /**
     *
     * @summary Start reset password process.
     * @param {PasswordResetInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetInit(Body?: PasswordResetInitRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordResetInitResponseBody>>;
};
/**
 * AuthApi - factory interface
 * @export
 */
export declare const AuthApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Finalize authentication.
     * @param {AccountAuthFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAuthFinalize(Body?: AccountAuthFinalizeRequestBody, options?: any): AxiosPromise<AccountAuthFinalizeResponseBody>;
    /**
     *
     * @summary Start authentication.
     * @param {AccountAuthInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAuthInit(Body?: AccountAuthInitRequestBody, options?: any): AxiosPromise<AccountAuthInitResponseBody>;
    /**
     *
     * @summary Complete opaque registration flow.
     * @param {AccountRegisterCreateRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterCreate(Body?: AccountRegisterCreateRequestBody, options?: any): AxiosPromise<AccountRegisterCreateResponseBody>;
    /**
     *
     * @summary Finalize registration.
     * @param {AccountRegisterFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterFinalize(Body?: AccountRegisterFinalizeRequestBody, options?: any): AxiosPromise<AccountRegisterFinalizeResponseBody>;
    /**
     *
     * @summary Start registration process.
     * @param {AccountRegisterInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterInit(Body?: AccountRegisterInitRequestBody, options?: any): AxiosPromise<AccountRegisterInitResponseBody>;
    /**
     *
     * @summary Complete opaque reset flow.
     * @param {PasswordResetCreateRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetCreate(Body?: PasswordResetCreateRequestBody, options?: any): AxiosPromise<PasswordResetCreateResponseBody>;
    /**
     *
     * @summary Finalize reset password.
     * @param {PasswordResetFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetFinalize(Body?: PasswordResetFinalizeRequestBody, options?: any): AxiosPromise<PasswordResetFinalizeResponseBody>;
    /**
     *
     * @summary Start reset password process.
     * @param {PasswordResetInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetInit(Body?: PasswordResetInitRequestBody, options?: any): AxiosPromise<PasswordResetInitResponseBody>;
};
/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     *
     * @summary Finalize authentication.
     * @param {AccountAuthFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    accountAuthFinalize(Body?: AccountAuthFinalizeRequestBody, options?: AxiosRequestConfig): AxiosPromise<AccountAuthFinalizeResponseBody>;
    /**
     *
     * @summary Start authentication.
     * @param {AccountAuthInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    accountAuthInit(Body?: AccountAuthInitRequestBody, options?: AxiosRequestConfig): AxiosPromise<AccountAuthInitResponseBody>;
    /**
     *
     * @summary Complete opaque registration flow.
     * @param {AccountRegisterCreateRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    accountRegisterCreate(Body?: AccountRegisterCreateRequestBody, options?: AxiosRequestConfig): AxiosPromise<AccountRegisterCreateResponseBody>;
    /**
     *
     * @summary Finalize registration.
     * @param {AccountRegisterFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    accountRegisterFinalize(Body?: AccountRegisterFinalizeRequestBody, options?: AxiosRequestConfig): AxiosPromise<AccountRegisterFinalizeResponseBody>;
    /**
     *
     * @summary Start registration process.
     * @param {AccountRegisterInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    accountRegisterInit(Body?: AccountRegisterInitRequestBody, options?: AxiosRequestConfig): AxiosPromise<AccountRegisterInitResponseBody>;
    /**
     *
     * @summary Complete opaque reset flow.
     * @param {PasswordResetCreateRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    passwordResetCreate(Body?: PasswordResetCreateRequestBody, options?: AxiosRequestConfig): AxiosPromise<PasswordResetCreateResponseBody>;
    /**
     *
     * @summary Finalize reset password.
     * @param {PasswordResetFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    passwordResetFinalize(Body?: PasswordResetFinalizeRequestBody, options?: AxiosRequestConfig): AxiosPromise<PasswordResetFinalizeResponseBody>;
    /**
     *
     * @summary Start reset password process.
     * @param {PasswordResetInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    passwordResetInit(Body?: PasswordResetInitRequestBody, options?: AxiosRequestConfig): AxiosPromise<PasswordResetInitResponseBody>;
}
/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export declare class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     *
     * @summary Finalize authentication.
     * @param {AccountAuthFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    accountAuthFinalize(Body?: AccountAuthFinalizeRequestBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AccountAuthFinalizeResponseBody, any>>;
    /**
     *
     * @summary Start authentication.
     * @param {AccountAuthInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    accountAuthInit(Body?: AccountAuthInitRequestBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AccountAuthInitResponseBody, any>>;
    /**
     *
     * @summary Complete opaque registration flow.
     * @param {AccountRegisterCreateRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    accountRegisterCreate(Body?: AccountRegisterCreateRequestBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AccountRegisterCreateResponseBody, any>>;
    /**
     *
     * @summary Finalize registration.
     * @param {AccountRegisterFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    accountRegisterFinalize(Body?: AccountRegisterFinalizeRequestBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AccountRegisterFinalizeResponseBody, any>>;
    /**
     *
     * @summary Start registration process.
     * @param {AccountRegisterInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    accountRegisterInit(Body?: AccountRegisterInitRequestBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<AccountRegisterInitResponseBody, any>>;
    /**
     *
     * @summary Complete opaque reset flow.
     * @param {PasswordResetCreateRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    passwordResetCreate(Body?: PasswordResetCreateRequestBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PasswordResetCreateResponseBody, any>>;
    /**
     *
     * @summary Finalize reset password.
     * @param {PasswordResetFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    passwordResetFinalize(Body?: PasswordResetFinalizeRequestBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PasswordResetFinalizeResponseBody, any>>;
    /**
     *
     * @summary Start reset password process.
     * @param {PasswordResetInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    passwordResetInit(Body?: PasswordResetInitRequestBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PasswordResetInitResponseBody, any>>;
}
/**
 * IdentityKeysApi - axios parameter creator
 * @export
 */
export declare const IdentityKeysApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
     * @summary Identity key from blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKey: (Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyAddresses: (IdentityKey: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
     * @summary Get all linked names for a resolver
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyResolvableNames: (IdentityKey: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMsgKey: (IdentityKey: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
     * @summary Store address identity key.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {string} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putAddressIdentityKey: (Address: string, IdentityKey: string, Protocol: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMsgKeyByIDKey: (IdentityKey: string, Body: PutMsgKeyByIDKeyRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * IdentityKeysApi - functional programming interface
 * @export
 */
export declare const IdentityKeysApiFp: (configuration?: Configuration) => {
    /**
     * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
     * @summary Identity key from blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKey(Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentityKeyResponseBody>>;
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyAddresses(IdentityKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentityKeyAddressesResponseBody>>;
    /**
     * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
     * @summary Get all linked names for a resolver
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyResolvableNames(IdentityKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentityKeyResolvableNamesResponseBody>>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMsgKey(IdentityKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMsgKeyResponseBody>>;
    /**
     * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
     * @summary Store address identity key.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {string} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putAddressIdentityKey(Address: string, IdentityKey: string, Protocol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMsgKeyByIDKey(IdentityKey: string, Body: PutMsgKeyByIDKeyRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * IdentityKeysApi - factory interface
 * @export
 */
export declare const IdentityKeysApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
     * @summary Identity key from blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKey(Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', options?: any): AxiosPromise<GetIdentityKeyResponseBody>;
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyAddresses(IdentityKey: string, options?: any): AxiosPromise<GetIdentityKeyAddressesResponseBody>;
    /**
     * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
     * @summary Get all linked names for a resolver
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyResolvableNames(IdentityKey: string, options?: any): AxiosPromise<GetIdentityKeyResolvableNamesResponseBody>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMsgKey(IdentityKey: string, options?: any): AxiosPromise<GetMsgKeyResponseBody>;
    /**
     * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
     * @summary Store address identity key.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {string} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putAddressIdentityKey(Address: string, IdentityKey: string, Protocol: string, options?: any): AxiosPromise<void>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMsgKeyByIDKey(IdentityKey: string, Body: PutMsgKeyByIDKeyRequestBody, options?: any): AxiosPromise<void>;
};
/**
 * IdentityKeysApi - interface
 * @export
 * @interface IdentityKeysApi
 */
export interface IdentityKeysApiInterface {
    /**
     * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
     * @summary Identity key from blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApiInterface
     */
    getIdentityKey(Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', options?: AxiosRequestConfig): AxiosPromise<GetIdentityKeyResponseBody>;
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApiInterface
     */
    getIdentityKeyAddresses(IdentityKey: string, options?: AxiosRequestConfig): AxiosPromise<GetIdentityKeyAddressesResponseBody>;
    /**
     * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
     * @summary Get all linked names for a resolver
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApiInterface
     */
    getIdentityKeyResolvableNames(IdentityKey: string, options?: AxiosRequestConfig): AxiosPromise<GetIdentityKeyResolvableNamesResponseBody>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApiInterface
     */
    getMsgKey(IdentityKey: string, options?: AxiosRequestConfig): AxiosPromise<GetMsgKeyResponseBody>;
    /**
     * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
     * @summary Store address identity key.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {string} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApiInterface
     */
    putAddressIdentityKey(Address: string, IdentityKey: string, Protocol: string, options?: AxiosRequestConfig): AxiosPromise<void>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApiInterface
     */
    putMsgKeyByIDKey(IdentityKey: string, Body: PutMsgKeyByIDKeyRequestBody, options?: AxiosRequestConfig): AxiosPromise<void>;
}
/**
 * IdentityKeysApi - object-oriented interface
 * @export
 * @class IdentityKeysApi
 * @extends {BaseAPI}
 */
export declare class IdentityKeysApi extends BaseAPI implements IdentityKeysApiInterface {
    /**
     * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
     * @summary Identity key from blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    getIdentityKey(Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetIdentityKeyResponseBody, any>>;
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    getIdentityKeyAddresses(IdentityKey: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetIdentityKeyAddressesResponseBody, any>>;
    /**
     * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
     * @summary Get all linked names for a resolver
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    getIdentityKeyResolvableNames(IdentityKey: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetIdentityKeyResolvableNamesResponseBody, any>>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    getMsgKey(IdentityKey: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMsgKeyResponseBody, any>>;
    /**
     * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
     * @summary Store address identity key.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {string} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    putAddressIdentityKey(Address: string, IdentityKey: string, Protocol: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    putMsgKeyByIDKey(IdentityKey: string, Body: PutMsgKeyByIDKeyRequestBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * InboxApi - axios parameter creator
 * @export
 */
export declare const InboxApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Remove label from message.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} Label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMessageLabel: (MessageId: string, Label: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get encrypted payload message body
     * @param {string} MessageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEncryptedMessageBody: (MessageId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get message item
     * @param {string} MessageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessage: (MessageId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get messages that have been archived
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInArchivedView: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get messages in inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInInboxView: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get messages that have not sent yet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInOutboxView: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get messages in sent folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInSentView: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get messages marked as starred by the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInStarredView: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get messages in trash folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInTrashView: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get messages that have not been read by the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInUnreadView: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get messages
     * @param {Array<string>} [Labels] Labels to search for.
     * @param {string} [From] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [To] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesSearch: (Labels?: Array<string>, From?: string, To?: Array<string>, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Store a message body for later retrieval
     * @param {object} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postEncryptedMessageBody: (Body: object, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
     * @summary Add message to inbox.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {PutEncryptedMessageRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putEncryptedMessage: (MessageId: string, Body: PutEncryptedMessageRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Add label to message.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} Label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMessageLabel: (MessageId: string, Label: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * InboxApi - functional programming interface
 * @export
 */
export declare const InboxApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Remove label from message.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} Label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMessageLabel(MessageId: string, Label: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Get encrypted payload message body
     * @param {string} MessageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEncryptedMessageBody(MessageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>>;
    /**
     * Get message item
     * @param {string} MessageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessage(MessageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessageResponseBody>>;
    /**
     * Get messages that have been archived
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInArchivedView(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesInViewResponseBody>>;
    /**
     * Get messages in inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInInboxView(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesInViewResponseBody>>;
    /**
     *
     * @summary Get messages that have not sent yet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInOutboxView(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesInViewResponseBody>>;
    /**
     * Get messages in sent folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInSentView(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesInViewResponseBody>>;
    /**
     *
     * @summary Get messages marked as starred by the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInStarredView(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesInViewResponseBody>>;
    /**
     * Get messages in trash folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInTrashView(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesInViewResponseBody>>;
    /**
     *
     * @summary Get messages that have not been read by the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInUnreadView(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesInViewResponseBody>>;
    /**
     * Get messages
     * @param {Array<string>} [Labels] Labels to search for.
     * @param {string} [From] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [To] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesSearch(Labels?: Array<string>, From?: string, To?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesSearchResponseBody>>;
    /**
     * Store a message body for later retrieval
     * @param {object} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postEncryptedMessageBody(Body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostPayloadResponseBody>>;
    /**
     * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
     * @summary Add message to inbox.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {PutEncryptedMessageRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putEncryptedMessage(MessageId: string, Body: PutEncryptedMessageRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Add label to message.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} Label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMessageLabel(MessageId: string, Label: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * InboxApi - factory interface
 * @export
 */
export declare const InboxApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Remove label from message.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} Label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMessageLabel(MessageId: string, Label: string, options?: any): AxiosPromise<void>;
    /**
     * Get encrypted payload message body
     * @param {string} MessageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEncryptedMessageBody(MessageId: string, options?: any): AxiosPromise<object>;
    /**
     * Get message item
     * @param {string} MessageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessage(MessageId: string, options?: any): AxiosPromise<GetMessageResponseBody>;
    /**
     * Get messages that have been archived
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInArchivedView(options?: any): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Get messages in inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInInboxView(options?: any): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     *
     * @summary Get messages that have not sent yet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInOutboxView(options?: any): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Get messages in sent folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInSentView(options?: any): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     *
     * @summary Get messages marked as starred by the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInStarredView(options?: any): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Get messages in trash folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInTrashView(options?: any): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     *
     * @summary Get messages that have not been read by the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInUnreadView(options?: any): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Get messages
     * @param {Array<string>} [Labels] Labels to search for.
     * @param {string} [From] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [To] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesSearch(Labels?: Array<string>, From?: string, To?: Array<string>, options?: any): AxiosPromise<GetMessagesSearchResponseBody>;
    /**
     * Store a message body for later retrieval
     * @param {object} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postEncryptedMessageBody(Body: object, options?: any): AxiosPromise<PostPayloadResponseBody>;
    /**
     * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
     * @summary Add message to inbox.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {PutEncryptedMessageRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putEncryptedMessage(MessageId: string, Body: PutEncryptedMessageRequestBody, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Add label to message.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} Label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMessageLabel(MessageId: string, Label: string, options?: any): AxiosPromise<void>;
};
/**
 * InboxApi - interface
 * @export
 * @interface InboxApi
 */
export interface InboxApiInterface {
    /**
     *
     * @summary Remove label from message.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} Label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    deleteMessageLabel(MessageId: string, Label: string, options?: AxiosRequestConfig): AxiosPromise<void>;
    /**
     * Get encrypted payload message body
     * @param {string} MessageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getEncryptedMessageBody(MessageId: string, options?: AxiosRequestConfig): AxiosPromise<object>;
    /**
     * Get message item
     * @param {string} MessageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessage(MessageId: string, options?: AxiosRequestConfig): AxiosPromise<GetMessageResponseBody>;
    /**
     * Get messages that have been archived
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessagesInArchivedView(options?: AxiosRequestConfig): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Get messages in inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessagesInInboxView(options?: AxiosRequestConfig): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     *
     * @summary Get messages that have not sent yet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessagesInOutboxView(options?: AxiosRequestConfig): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Get messages in sent folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessagesInSentView(options?: AxiosRequestConfig): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     *
     * @summary Get messages marked as starred by the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessagesInStarredView(options?: AxiosRequestConfig): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Get messages in trash folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessagesInTrashView(options?: AxiosRequestConfig): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     *
     * @summary Get messages that have not been read by the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessagesInUnreadView(options?: AxiosRequestConfig): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Get messages
     * @param {Array<string>} [Labels] Labels to search for.
     * @param {string} [From] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [To] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessagesSearch(Labels?: Array<string>, From?: string, To?: Array<string>, options?: AxiosRequestConfig): AxiosPromise<GetMessagesSearchResponseBody>;
    /**
     * Store a message body for later retrieval
     * @param {object} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    postEncryptedMessageBody(Body: object, options?: AxiosRequestConfig): AxiosPromise<PostPayloadResponseBody>;
    /**
     * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
     * @summary Add message to inbox.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {PutEncryptedMessageRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    putEncryptedMessage(MessageId: string, Body: PutEncryptedMessageRequestBody, options?: AxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Add label to message.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} Label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    putMessageLabel(MessageId: string, Label: string, options?: AxiosRequestConfig): AxiosPromise<void>;
}
/**
 * InboxApi - object-oriented interface
 * @export
 * @class InboxApi
 * @extends {BaseAPI}
 */
export declare class InboxApi extends BaseAPI implements InboxApiInterface {
    /**
     *
     * @summary Remove label from message.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} Label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    deleteMessageLabel(MessageId: string, Label: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Get encrypted payload message body
     * @param {string} MessageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getEncryptedMessageBody(MessageId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<object, any>>;
    /**
     * Get message item
     * @param {string} MessageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessage(MessageId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMessageResponseBody, any>>;
    /**
     * Get messages that have been archived
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInArchivedView(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMessagesInViewResponseBody, any>>;
    /**
     * Get messages in inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInInboxView(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMessagesInViewResponseBody, any>>;
    /**
     *
     * @summary Get messages that have not sent yet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInOutboxView(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMessagesInViewResponseBody, any>>;
    /**
     * Get messages in sent folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInSentView(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMessagesInViewResponseBody, any>>;
    /**
     *
     * @summary Get messages marked as starred by the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInStarredView(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMessagesInViewResponseBody, any>>;
    /**
     * Get messages in trash folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInTrashView(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMessagesInViewResponseBody, any>>;
    /**
     *
     * @summary Get messages that have not been read by the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInUnreadView(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMessagesInViewResponseBody, any>>;
    /**
     * Get messages
     * @param {Array<string>} [Labels] Labels to search for.
     * @param {string} [From] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [To] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesSearch(Labels?: Array<string>, From?: string, To?: Array<string>, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMessagesSearchResponseBody, any>>;
    /**
     * Store a message body for later retrieval
     * @param {object} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    postEncryptedMessageBody(Body: object, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PostPayloadResponseBody, any>>;
    /**
     * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
     * @summary Add message to inbox.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {PutEncryptedMessageRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    putEncryptedMessage(MessageId: string, Body: PutEncryptedMessageRequestBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Add label to message.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} Label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    putMessageLabel(MessageId: string, Label: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * MessagingKeysApi - axios parameter creator
 * @export
 */
export declare const MessagingKeysApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyAddresses: (IdentityKey: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get identity key nonce
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyNonce: (IdentityKey: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMailchainPublicKey: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMsgKey: (IdentityKey: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get protocol address nonce
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProtocolAddressNonce: (Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
     * @summary Get\'s the private messaging key for a blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendedPrivateMessagingKey: (Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', IdentityKey: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
     * @summary Get\'s the public messaging key for a blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendedPublicMessagingKey: (Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMsgKeyByIDKey: (IdentityKey: string, Body: PutMsgKeyByIDKeyRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * MessagingKeysApi - functional programming interface
 * @export
 */
export declare const MessagingKeysApiFp: (configuration?: Configuration) => {
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyAddresses(IdentityKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentityKeyAddressesResponseBody>>;
    /**
     * Get identity key nonce
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyNonce(IdentityKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentityKeyNonceResponseBody>>;
    /**
     *
     * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMailchainPublicKey(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMailchainPublicKeyResponseBody>>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMsgKey(IdentityKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMsgKeyResponseBody>>;
    /**
     * Get protocol address nonce
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProtocolAddressNonce(Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProtocolAddressNonceResponseBody>>;
    /**
     * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
     * @summary Get\'s the private messaging key for a blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendedPrivateMessagingKey(Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', IdentityKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVendedPrivateMessagingKeyResponseBody>>;
    /**
     * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
     * @summary Get\'s the public messaging key for a blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendedPublicMessagingKey(Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagingKeyResponseBody>>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMsgKeyByIDKey(IdentityKey: string, Body: PutMsgKeyByIDKeyRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * MessagingKeysApi - factory interface
 * @export
 */
export declare const MessagingKeysApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyAddresses(IdentityKey: string, options?: any): AxiosPromise<GetIdentityKeyAddressesResponseBody>;
    /**
     * Get identity key nonce
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyNonce(IdentityKey: string, options?: any): AxiosPromise<GetIdentityKeyNonceResponseBody>;
    /**
     *
     * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMailchainPublicKey(options?: any): AxiosPromise<GetMailchainPublicKeyResponseBody>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMsgKey(IdentityKey: string, options?: any): AxiosPromise<GetMsgKeyResponseBody>;
    /**
     * Get protocol address nonce
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProtocolAddressNonce(Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', options?: any): AxiosPromise<GetProtocolAddressNonceResponseBody>;
    /**
     * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
     * @summary Get\'s the private messaging key for a blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendedPrivateMessagingKey(Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', IdentityKey: string, options?: any): AxiosPromise<GetVendedPrivateMessagingKeyResponseBody>;
    /**
     * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
     * @summary Get\'s the public messaging key for a blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendedPublicMessagingKey(Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', options?: any): AxiosPromise<GetMessagingKeyResponseBody>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMsgKeyByIDKey(IdentityKey: string, Body: PutMsgKeyByIDKeyRequestBody, options?: any): AxiosPromise<void>;
};
/**
 * MessagingKeysApi - interface
 * @export
 * @interface MessagingKeysApi
 */
export interface MessagingKeysApiInterface {
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApiInterface
     */
    getIdentityKeyAddresses(IdentityKey: string, options?: AxiosRequestConfig): AxiosPromise<GetIdentityKeyAddressesResponseBody>;
    /**
     * Get identity key nonce
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApiInterface
     */
    getIdentityKeyNonce(IdentityKey: string, options?: AxiosRequestConfig): AxiosPromise<GetIdentityKeyNonceResponseBody>;
    /**
     *
     * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApiInterface
     */
    getMailchainPublicKey(options?: AxiosRequestConfig): AxiosPromise<GetMailchainPublicKeyResponseBody>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApiInterface
     */
    getMsgKey(IdentityKey: string, options?: AxiosRequestConfig): AxiosPromise<GetMsgKeyResponseBody>;
    /**
     * Get protocol address nonce
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApiInterface
     */
    getProtocolAddressNonce(Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', options?: AxiosRequestConfig): AxiosPromise<GetProtocolAddressNonceResponseBody>;
    /**
     * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
     * @summary Get\'s the private messaging key for a blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApiInterface
     */
    getVendedPrivateMessagingKey(Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', IdentityKey: string, options?: AxiosRequestConfig): AxiosPromise<GetVendedPrivateMessagingKeyResponseBody>;
    /**
     * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
     * @summary Get\'s the public messaging key for a blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApiInterface
     */
    getVendedPublicMessagingKey(Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', options?: AxiosRequestConfig): AxiosPromise<GetMessagingKeyResponseBody>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApiInterface
     */
    putMsgKeyByIDKey(IdentityKey: string, Body: PutMsgKeyByIDKeyRequestBody, options?: AxiosRequestConfig): AxiosPromise<void>;
}
/**
 * MessagingKeysApi - object-oriented interface
 * @export
 * @class MessagingKeysApi
 * @extends {BaseAPI}
 */
export declare class MessagingKeysApi extends BaseAPI implements MessagingKeysApiInterface {
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getIdentityKeyAddresses(IdentityKey: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetIdentityKeyAddressesResponseBody, any>>;
    /**
     * Get identity key nonce
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getIdentityKeyNonce(IdentityKey: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetIdentityKeyNonceResponseBody, any>>;
    /**
     *
     * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getMailchainPublicKey(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMailchainPublicKeyResponseBody, any>>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getMsgKey(IdentityKey: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMsgKeyResponseBody, any>>;
    /**
     * Get protocol address nonce
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getProtocolAddressNonce(Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetProtocolAddressNonceResponseBody, any>>;
    /**
     * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
     * @summary Get\'s the private messaging key for a blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getVendedPrivateMessagingKey(Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', IdentityKey: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetVendedPrivateMessagingKeyResponseBody, any>>;
    /**
     * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
     * @summary Get\'s the public messaging key for a blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getVendedPublicMessagingKey(Address: string, Protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin', options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMessagingKeyResponseBody, any>>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    putMsgKeyByIDKey(IdentityKey: string, Body: PutMsgKeyByIDKeyRequestBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * TransportApi - axios parameter creator
 * @export
 */
export declare const TransportApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get unconfirmed delivery requests for a recipient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeliveryRequests: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get encrypted payload message body
     * @param {string} PayloadId The payload id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEncryptedPayload: (PayloadId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a new request that delivers a message to the intended address.
     * @summary Add a delivery request
     * @param {PostDeliveryRequestRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDeliveryRequest: (Body: PostDeliveryRequestRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Store a payload for later delivery
     * @param {object} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postEncryptedPayload: (Body: object, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Put delivery request confirmation
     * @param {string} DeliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
     * @param {PutDeliveryRequestConfirmationRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putDeliveryRequestConfirmation: (DeliveryRequestHash: string, Body: PutDeliveryRequestConfirmationRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TransportApi - functional programming interface
 * @export
 */
export declare const TransportApiFp: (configuration?: Configuration) => {
    /**
     * Get unconfirmed delivery requests for a recipient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeliveryRequests(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDeliveryRequestsResponseBody>>;
    /**
     * Get encrypted payload message body
     * @param {string} PayloadId The payload id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEncryptedPayload(PayloadId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>>;
    /**
     * Create a new request that delivers a message to the intended address.
     * @summary Add a delivery request
     * @param {PostDeliveryRequestRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDeliveryRequest(Body: PostDeliveryRequestRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostDeliveryRequestResponseBody>>;
    /**
     * Store a payload for later delivery
     * @param {object} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postEncryptedPayload(Body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostPayloadResponseBody>>;
    /**
     * Put delivery request confirmation
     * @param {string} DeliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
     * @param {PutDeliveryRequestConfirmationRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putDeliveryRequestConfirmation(DeliveryRequestHash: string, Body: PutDeliveryRequestConfirmationRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * TransportApi - factory interface
 * @export
 */
export declare const TransportApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get unconfirmed delivery requests for a recipient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeliveryRequests(options?: any): AxiosPromise<GetDeliveryRequestsResponseBody>;
    /**
     * Get encrypted payload message body
     * @param {string} PayloadId The payload id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEncryptedPayload(PayloadId: string, options?: any): AxiosPromise<object>;
    /**
     * Create a new request that delivers a message to the intended address.
     * @summary Add a delivery request
     * @param {PostDeliveryRequestRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDeliveryRequest(Body: PostDeliveryRequestRequestBody, options?: any): AxiosPromise<PostDeliveryRequestResponseBody>;
    /**
     * Store a payload for later delivery
     * @param {object} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postEncryptedPayload(Body: object, options?: any): AxiosPromise<PostPayloadResponseBody>;
    /**
     * Put delivery request confirmation
     * @param {string} DeliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
     * @param {PutDeliveryRequestConfirmationRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putDeliveryRequestConfirmation(DeliveryRequestHash: string, Body: PutDeliveryRequestConfirmationRequestBody, options?: any): AxiosPromise<void>;
};
/**
 * TransportApi - interface
 * @export
 * @interface TransportApi
 */
export interface TransportApiInterface {
    /**
     * Get unconfirmed delivery requests for a recipient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApiInterface
     */
    getDeliveryRequests(options?: AxiosRequestConfig): AxiosPromise<GetDeliveryRequestsResponseBody>;
    /**
     * Get encrypted payload message body
     * @param {string} PayloadId The payload id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApiInterface
     */
    getEncryptedPayload(PayloadId: string, options?: AxiosRequestConfig): AxiosPromise<object>;
    /**
     * Create a new request that delivers a message to the intended address.
     * @summary Add a delivery request
     * @param {PostDeliveryRequestRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApiInterface
     */
    postDeliveryRequest(Body: PostDeliveryRequestRequestBody, options?: AxiosRequestConfig): AxiosPromise<PostDeliveryRequestResponseBody>;
    /**
     * Store a payload for later delivery
     * @param {object} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApiInterface
     */
    postEncryptedPayload(Body: object, options?: AxiosRequestConfig): AxiosPromise<PostPayloadResponseBody>;
    /**
     * Put delivery request confirmation
     * @param {string} DeliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
     * @param {PutDeliveryRequestConfirmationRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApiInterface
     */
    putDeliveryRequestConfirmation(DeliveryRequestHash: string, Body: PutDeliveryRequestConfirmationRequestBody, options?: AxiosRequestConfig): AxiosPromise<void>;
}
/**
 * TransportApi - object-oriented interface
 * @export
 * @class TransportApi
 * @extends {BaseAPI}
 */
export declare class TransportApi extends BaseAPI implements TransportApiInterface {
    /**
     * Get unconfirmed delivery requests for a recipient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApi
     */
    getDeliveryRequests(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetDeliveryRequestsResponseBody, any>>;
    /**
     * Get encrypted payload message body
     * @param {string} PayloadId The payload id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApi
     */
    getEncryptedPayload(PayloadId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<object, any>>;
    /**
     * Create a new request that delivers a message to the intended address.
     * @summary Add a delivery request
     * @param {PostDeliveryRequestRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApi
     */
    postDeliveryRequest(Body: PostDeliveryRequestRequestBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PostDeliveryRequestResponseBody, any>>;
    /**
     * Store a payload for later delivery
     * @param {object} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApi
     */
    postEncryptedPayload(Body: object, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PostPayloadResponseBody, any>>;
    /**
     * Put delivery request confirmation
     * @param {string} DeliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
     * @param {PutDeliveryRequestConfirmationRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApi
     */
    putDeliveryRequestConfirmation(DeliveryRequestHash: string, Body: PutDeliveryRequestConfirmationRequestBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * UserApi - axios parameter creator
 * @export
 */
export declare const UserApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Deletes an mailbox from the account.
     * @param {string} MailboxId ID of the mailbox to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserMailbox: (MailboxId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
     * @summary Session cookie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCookie: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get mailboxes registered with Mailchain account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMailboxes: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserSettings: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get username for currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsername: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Adds an mailboxes to an account.
     * @param {PostUserMailboxRequestBody} Body Encrypted list of mailboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserMailbox: (Body: PostUserMailboxRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Updates a previous stored mailbox for an account.
     * @param {string} MailboxId ID of the mailbox to update
     * @param {PutUserMailboxRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserMailbox: (MailboxId: string, Body: PutUserMailboxRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Sets a user setting.
     * @param {string} Setting Name of the setting to store
     * @param {PutUserSettingRequestBody} Body Encrypted private key to store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserSetting: (Setting: string, Body: PutUserSettingRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * UserApi - functional programming interface
 * @export
 */
export declare const UserApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Deletes an mailbox from the account.
     * @param {string} MailboxId ID of the mailbox to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserMailbox(MailboxId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
     * @summary Session cookie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCookie(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSessionCookieResponseBody>>;
    /**
     *
     * @summary Get mailboxes registered with Mailchain account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMailboxes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserMailboxesResponseBody>>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserSettingsResponseBody>>;
    /**
     * Get username for currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsername(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsernameResponseBody>>;
    /**
     *
     * @summary Adds an mailboxes to an account.
     * @param {PostUserMailboxRequestBody} Body Encrypted list of mailboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserMailbox(Body: PostUserMailboxRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostUserMailboxResponseBody>>;
    /**
     *
     * @summary Updates a previous stored mailbox for an account.
     * @param {string} MailboxId ID of the mailbox to update
     * @param {PutUserMailboxRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserMailbox(MailboxId: string, Body: PutUserMailboxRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Sets a user setting.
     * @param {string} Setting Name of the setting to store
     * @param {PutUserSettingRequestBody} Body Encrypted private key to store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserSetting(Setting: string, Body: PutUserSettingRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * UserApi - factory interface
 * @export
 */
export declare const UserApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Deletes an mailbox from the account.
     * @param {string} MailboxId ID of the mailbox to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserMailbox(MailboxId: string, options?: any): AxiosPromise<void>;
    /**
     * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
     * @summary Session cookie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCookie(options?: any): AxiosPromise<GetSessionCookieResponseBody>;
    /**
     *
     * @summary Get mailboxes registered with Mailchain account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMailboxes(options?: any): AxiosPromise<GetUserMailboxesResponseBody>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserSettings(options?: any): AxiosPromise<GetUserSettingsResponseBody>;
    /**
     * Get username for currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsername(options?: any): AxiosPromise<GetUsernameResponseBody>;
    /**
     *
     * @summary Adds an mailboxes to an account.
     * @param {PostUserMailboxRequestBody} Body Encrypted list of mailboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserMailbox(Body: PostUserMailboxRequestBody, options?: any): AxiosPromise<PostUserMailboxResponseBody>;
    /**
     *
     * @summary Updates a previous stored mailbox for an account.
     * @param {string} MailboxId ID of the mailbox to update
     * @param {PutUserMailboxRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserMailbox(MailboxId: string, Body: PutUserMailboxRequestBody, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Sets a user setting.
     * @param {string} Setting Name of the setting to store
     * @param {PutUserSettingRequestBody} Body Encrypted private key to store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserSetting(Setting: string, Body: PutUserSettingRequestBody, options?: any): AxiosPromise<void>;
};
/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     *
     * @summary Deletes an mailbox from the account.
     * @param {string} MailboxId ID of the mailbox to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUserMailbox(MailboxId: string, options?: AxiosRequestConfig): AxiosPromise<void>;
    /**
     * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
     * @summary Session cookie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getSessionCookie(options?: AxiosRequestConfig): AxiosPromise<GetSessionCookieResponseBody>;
    /**
     *
     * @summary Get mailboxes registered with Mailchain account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserMailboxes(options?: AxiosRequestConfig): AxiosPromise<GetUserMailboxesResponseBody>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserSettings(options?: AxiosRequestConfig): AxiosPromise<GetUserSettingsResponseBody>;
    /**
     * Get username for currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUsername(options?: AxiosRequestConfig): AxiosPromise<GetUsernameResponseBody>;
    /**
     *
     * @summary Adds an mailboxes to an account.
     * @param {PostUserMailboxRequestBody} Body Encrypted list of mailboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    postUserMailbox(Body: PostUserMailboxRequestBody, options?: AxiosRequestConfig): AxiosPromise<PostUserMailboxResponseBody>;
    /**
     *
     * @summary Updates a previous stored mailbox for an account.
     * @param {string} MailboxId ID of the mailbox to update
     * @param {PutUserMailboxRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    putUserMailbox(MailboxId: string, Body: PutUserMailboxRequestBody, options?: AxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Sets a user setting.
     * @param {string} Setting Name of the setting to store
     * @param {PutUserSettingRequestBody} Body Encrypted private key to store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    putUserSetting(Setting: string, Body: PutUserSettingRequestBody, options?: AxiosRequestConfig): AxiosPromise<void>;
}
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export declare class UserApi extends BaseAPI implements UserApiInterface {
    /**
     *
     * @summary Deletes an mailbox from the account.
     * @param {string} MailboxId ID of the mailbox to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUserMailbox(MailboxId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
     * @summary Session cookie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getSessionCookie(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetSessionCookieResponseBody, any>>;
    /**
     *
     * @summary Get mailboxes registered with Mailchain account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserMailboxes(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetUserMailboxesResponseBody, any>>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserSettings(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetUserSettingsResponseBody, any>>;
    /**
     * Get username for currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUsername(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetUsernameResponseBody, any>>;
    /**
     *
     * @summary Adds an mailboxes to an account.
     * @param {PostUserMailboxRequestBody} Body Encrypted list of mailboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    postUserMailbox(Body: PostUserMailboxRequestBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PostUserMailboxResponseBody, any>>;
    /**
     *
     * @summary Updates a previous stored mailbox for an account.
     * @param {string} MailboxId ID of the mailbox to update
     * @param {PutUserMailboxRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    putUserMailbox(MailboxId: string, Body: PutUserMailboxRequestBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     *
     * @summary Sets a user setting.
     * @param {string} Setting Name of the setting to store
     * @param {PutUserSettingRequestBody} Body Encrypted private key to store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    putUserSetting(Setting: string, Body: PutUserSettingRequestBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * UsersApi - axios parameter creator
 * @export
 */
export declare const UsersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * This method will get the identity key associated with the Mailchain username.
     * @summary Identity key from blockchain address.
     * @param {string} Username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdentityKey: (Username: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Used to check if an username exists.
     * @param {string} Username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsernameAvailable: (Username: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * UsersApi - functional programming interface
 * @export
 */
export declare const UsersApiFp: (configuration?: Configuration) => {
    /**
     * This method will get the identity key associated with the Mailchain username.
     * @summary Identity key from blockchain address.
     * @param {string} Username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdentityKey(Username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserIdentityKeyResponseBody>>;
    /**
     *
     * @summary Used to check if an username exists.
     * @param {string} Username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsernameAvailable(Username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsernameAvailableResponseBody>>;
};
/**
 * UsersApi - factory interface
 * @export
 */
export declare const UsersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * This method will get the identity key associated with the Mailchain username.
     * @summary Identity key from blockchain address.
     * @param {string} Username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdentityKey(Username: string, options?: any): AxiosPromise<GetUserIdentityKeyResponseBody>;
    /**
     *
     * @summary Used to check if an username exists.
     * @param {string} Username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsernameAvailable(Username: string, options?: any): AxiosPromise<GetUsernameAvailableResponseBody>;
};
/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * This method will get the identity key associated with the Mailchain username.
     * @summary Identity key from blockchain address.
     * @param {string} Username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getUserIdentityKey(Username: string, options?: AxiosRequestConfig): AxiosPromise<GetUserIdentityKeyResponseBody>;
    /**
     *
     * @summary Used to check if an username exists.
     * @param {string} Username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getUsernameAvailable(Username: string, options?: AxiosRequestConfig): AxiosPromise<GetUsernameAvailableResponseBody>;
}
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export declare class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * This method will get the identity key associated with the Mailchain username.
     * @summary Identity key from blockchain address.
     * @param {string} Username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserIdentityKey(Username: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetUserIdentityKeyResponseBody, any>>;
    /**
     *
     * @summary Used to check if an username exists.
     * @param {string} Username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsernameAvailable(Username: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetUsernameAvailableResponseBody, any>>;
}
/**
 * VersionApi - axios parameter creator
 * @export
 */
export declare const VersionApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
     * @summary Get version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * VersionApi - functional programming interface
 * @export
 */
export declare const VersionApiFp: (configuration?: Configuration) => {
    /**
     * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
     * @summary Get version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVersionResponseBody>>;
};
/**
 * VersionApi - factory interface
 * @export
 */
export declare const VersionApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
     * @summary Get version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion(options?: any): AxiosPromise<GetVersionResponseBody>;
};
/**
 * VersionApi - interface
 * @export
 * @interface VersionApi
 */
export interface VersionApiInterface {
    /**
     * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
     * @summary Get version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApiInterface
     */
    getVersion(options?: AxiosRequestConfig): AxiosPromise<GetVersionResponseBody>;
}
/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
export declare class VersionApi extends BaseAPI implements VersionApiInterface {
    /**
     * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
     * @summary Get version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    getVersion(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetVersionResponseBody, any>>;
}
