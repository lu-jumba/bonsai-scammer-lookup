'use strict';

var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');
var api = require('../api/api.js');
var errors = require('./errors.js');

/** Convert {@link PublicKey} to {@link ApiPublicKey}. */
function convertPublic(key) {
    switch (key.curve) {
        case crypto.KindED25519:
            return { curve: api.PublicKeyCurveEnum.Ed25519, value: encoding.encodeHexZeroX(key.bytes), encoding: 'hex/0x-prefix' };
        case crypto.KindSECP256K1:
            return { curve: api.PublicKeyCurveEnum.Secp256k1, value: encoding.encodeHexZeroX(key.bytes), encoding: 'hex/0x-prefix' };
        case crypto.KindSECP256R1:
            return { curve: api.PublicKeyCurveEnum.Secp256r1, value: encoding.encodeHexZeroX(key.bytes), encoding: 'hex/0x-prefix' };
        default:
            throw new errors.ErrorUnsupportedKey(key.curve);
    }
}
/** Convert {@link PrivateKey} to {@link ApiPrivateKey} */
function convertPrivate(key) {
    switch (key.curve) {
        case crypto.KindED25519:
            return { curve: api.PrivateKeyCurveEnum.Ed25519, value: encoding.encodeHexZeroX(key.bytes), encoding: 'hex/0x-prefix' };
        case crypto.KindSECP256K1:
            return {
                curve: api.PrivateKeyCurveEnum.Secp256k1,
                value: encoding.encodeHexZeroX(key.bytes),
                encoding: 'hex/0x-prefix',
            };
        case crypto.KindSECP256R1:
            return {
                curve: api.PrivateKeyCurveEnum.Secp256r1,
                value: encoding.encodeHexZeroX(key.bytes),
                encoding: 'hex/0x-prefix',
            };
        default:
            throw new errors.ErrorUnsupportedKey(key.curve);
    }
}

exports.convertPrivate = convertPrivate;
exports.convertPublic = convertPublic;
