'use strict';

var crypto = require('@mailchain/crypto');
var encoding = require('@mailchain/encoding');
var secp256r1 = require('@mailchain/crypto/secp256r1');
var api = require('../api/api.js');
var errors = require('./errors.js');

/** Convert {@link ApiPublicKey} to {@link PublicKey} */
function convertPublic(key) {
    switch (key.curve) {
        case api.PublicKeyCurveEnum.Ed25519:
            return new crypto.ED25519PublicKey(encoding.decode(key.encoding, key.value));
        case api.PublicKeyCurveEnum.Secp256k1:
            return new crypto.SECP256K1PublicKey(encoding.decode(key.encoding, key.value));
        case api.PublicKeyCurveEnum.Secp256r1:
            return new secp256r1.SECP256R1PublicKey(encoding.decode(key.encoding, key.value));
        default:
            throw new errors.ErrorUnsupportedKey(key.curve);
    }
}
/** Convert {@link ApiPrivateKey} to {@link PrivateKey} */
function convertPrivate(key) {
    switch (key.curve) {
        case api.PrivateKeyCurveEnum.Ed25519:
            return crypto.ED25519PrivateKey.fromSecretKey(encoding.decode(key.encoding, key.value));
        case api.PrivateKeyCurveEnum.Secp256k1:
            return new crypto.SECP256K1PrivateKey(encoding.decode(key.encoding, key.value));
        case api.PrivateKeyCurveEnum.Secp256r1:
            return new secp256r1.SECP256R1PrivateKey(encoding.decode(key.encoding, key.value));
        default:
            throw new errors.ErrorUnsupportedKey(key.curve);
    }
}

exports.convertPrivate = convertPrivate;
exports.convertPublic = convertPublic;
