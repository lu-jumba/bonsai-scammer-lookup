'use strict';

var globalAxios = require('axios');
var common = require('./common.js');
var base = require('./base.js');

/* tslint:disable */
const AddressEncodingEnum = {
    Hex0xPrefix: 'hex/0x-prefix',
    HexPlain: 'hex/plain',
    TextUtf8: 'text/utf-8',
    Base58Plain: 'base58/plain'
};
const ContractCallMethodEnum = {
    Post: 'POST',
    Get: 'GET'
};
const EncryptedAccountSecretEncryptionKindEnum = {
    Opaque: 'opaque',
    Metamask: 'metamask'
};
const EncryptedAccountSecretSecretKindEnum = {
    Account: 'account',
    Mnemonic: 'mnemonic'
};
const GetUsernameAvailableResponseBodyReasonEnum = {
    Reserved: 'reserved',
    Invalid: 'invalid',
    Taken: 'taken',
    Available: 'available',
    Unavailable: 'unavailable'
};
const PrivateKeyCurveEnum = {
    Secp256k1: 'secp256k1',
    Ed25519: 'ed25519',
    Secp256r1: 'secp256r1'
};
const PrivateKeyEncodingEnum = {
    _0xPrefix: 'hex/0x-prefix',
    Plain: 'hex/plain'
};
const PublicKeyCurveEnum = {
    Secp256k1: 'secp256k1',
    Ed25519: 'ed25519',
    Secp256r1: 'secp256r1'
};
const PublicKeyEncodingEnum = {
    _0xPrefix: 'hex/0x-prefix',
    Plain: 'hex/plain'
};
const PutEncryptedMessageRequestBodyFolderEnum = {
    Outbox: 'outbox',
    Inbox: 'inbox'
};
const RegisteredKeyProofSigningMethodEnum = {
    EthereumPersonalMessage: 'ethereum_personal_message',
    RawEd25519: 'raw_ed25519',
    TezosSignedMessageMicheline: 'tezos_signed_message_micheline'
};
/**
 * AddressesApi - axios parameter creator
 * @export
 */
const AddressesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get identity for an address.
         * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressIdentityKey: async (Address, options = {}) => {
            // verify required parameter 'Address' is not null or undefined
            common.assertParamExists('getAddressIdentityKey', 'Address', Address);
            const localVarPath = `/addresses/{address}/identity-key`
                .replace(`{${"address"}}`, encodeURIComponent(String(Address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get messaging key for an address.
         * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressMessagingKey: async (Address, options = {}) => {
            // verify required parameter 'Address' is not null or undefined
            common.assertParamExists('getAddressMessagingKey', 'Address', Address);
            const localVarPath = `/addresses/{address}/messaging-key`
                .replace(`{${"address"}}`, encodeURIComponent(String(Address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get status for messaging key for an address.
         * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressMessagingKeyStatus: async (Address, options = {}) => {
            // verify required parameter 'Address' is not null or undefined
            common.assertParamExists('getAddressMessagingKeyStatus', 'Address', Address);
            const localVarPath = `/addresses/{address}/resolved-messaging-key`
                .replace(`{${"address"}}`, encodeURIComponent(String(Address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AddressesApi - functional programming interface
 * @export
 */
const AddressesApiFp = function (configuration) {
    const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get identity for an address.
         * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressIdentityKey(Address, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressIdentityKey(Address, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get messaging key for an address.
         * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressMessagingKey(Address, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressMessagingKey(Address, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get status for messaging key for an address.
         * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressMessagingKeyStatus(Address, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressMessagingKeyStatus(Address, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
    };
};
/**
 * AddressesApi - factory interface
 * @export
 */
const AddressesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AddressesApiFp(configuration);
    return {
        /**
         *
         * @summary Get identity for an address.
         * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressIdentityKey(Address, options) {
            return localVarFp.getAddressIdentityKey(Address, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get messaging key for an address.
         * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressMessagingKey(Address, options) {
            return localVarFp.getAddressMessagingKey(Address, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get status for messaging key for an address.
         * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressMessagingKeyStatus(Address, options) {
            return localVarFp.getAddressMessagingKeyStatus(Address, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
class AddressesApi extends base.BaseAPI {
    /**
     *
     * @summary Get identity for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    getAddressIdentityKey(Address, options) {
        return AddressesApiFp(this.configuration).getAddressIdentityKey(Address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get messaging key for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    getAddressMessagingKey(Address, options) {
        return AddressesApiFp(this.configuration).getAddressMessagingKey(Address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get status for messaging key for an address.
     * @param {string} Address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    getAddressMessagingKeyStatus(Address, options) {
        return AddressesApiFp(this.configuration).getAddressMessagingKeyStatus(Address, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * AuthApi - axios parameter creator
 * @export
 */
const AuthApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Finalize authentication.
         * @param {AccountAuthFinalizeRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAuthFinalize: async (Body, options = {}) => {
            const localVarPath = `/user/auth-finalize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Start authentication.
         * @param {AccountAuthInitRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAuthInit: async (Body, options = {}) => {
            const localVarPath = `/user/auth-init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Complete opaque registration flow.
         * @param {AccountRegisterCreateRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountRegisterCreate: async (Body, options = {}) => {
            const localVarPath = `/user/register-create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Finalize registration.
         * @param {AccountRegisterFinalizeRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountRegisterFinalize: async (Body, options = {}) => {
            const localVarPath = `/user/register-finalize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Start registration process.
         * @param {AccountRegisterInitRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountRegisterInit: async (Body, options = {}) => {
            const localVarPath = `/user/register-init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Complete opaque reset flow.
         * @param {PasswordResetCreateRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordResetCreate: async (Body, options = {}) => {
            const localVarPath = `/user/password-reset-create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Finalize reset password.
         * @param {PasswordResetFinalizeRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordResetFinalize: async (Body, options = {}) => {
            const localVarPath = `/user/password-reset-finalize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Start reset password process.
         * @param {PasswordResetInitRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordResetInit: async (Body, options = {}) => {
            const localVarPath = `/user/password-reset-init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AuthApi - functional programming interface
 * @export
 */
const AuthApiFp = function (configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Finalize authentication.
         * @param {AccountAuthFinalizeRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAuthFinalize(Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountAuthFinalize(Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Start authentication.
         * @param {AccountAuthInitRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAuthInit(Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountAuthInit(Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Complete opaque registration flow.
         * @param {AccountRegisterCreateRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountRegisterCreate(Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountRegisterCreate(Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Finalize registration.
         * @param {AccountRegisterFinalizeRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountRegisterFinalize(Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountRegisterFinalize(Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Start registration process.
         * @param {AccountRegisterInitRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountRegisterInit(Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountRegisterInit(Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Complete opaque reset flow.
         * @param {PasswordResetCreateRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passwordResetCreate(Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passwordResetCreate(Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Finalize reset password.
         * @param {PasswordResetFinalizeRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passwordResetFinalize(Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passwordResetFinalize(Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Start reset password process.
         * @param {PasswordResetInitRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passwordResetInit(Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passwordResetInit(Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
    };
};
/**
 * AuthApi - factory interface
 * @export
 */
const AuthApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AuthApiFp(configuration);
    return {
        /**
         *
         * @summary Finalize authentication.
         * @param {AccountAuthFinalizeRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAuthFinalize(Body, options) {
            return localVarFp.accountAuthFinalize(Body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Start authentication.
         * @param {AccountAuthInitRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAuthInit(Body, options) {
            return localVarFp.accountAuthInit(Body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Complete opaque registration flow.
         * @param {AccountRegisterCreateRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountRegisterCreate(Body, options) {
            return localVarFp.accountRegisterCreate(Body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Finalize registration.
         * @param {AccountRegisterFinalizeRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountRegisterFinalize(Body, options) {
            return localVarFp.accountRegisterFinalize(Body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Start registration process.
         * @param {AccountRegisterInitRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountRegisterInit(Body, options) {
            return localVarFp.accountRegisterInit(Body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Complete opaque reset flow.
         * @param {PasswordResetCreateRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordResetCreate(Body, options) {
            return localVarFp.passwordResetCreate(Body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Finalize reset password.
         * @param {PasswordResetFinalizeRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordResetFinalize(Body, options) {
            return localVarFp.passwordResetFinalize(Body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Start reset password process.
         * @param {PasswordResetInitRequestBody} [Body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordResetInit(Body, options) {
            return localVarFp.passwordResetInit(Body, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
class AuthApi extends base.BaseAPI {
    /**
     *
     * @summary Finalize authentication.
     * @param {AccountAuthFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    accountAuthFinalize(Body, options) {
        return AuthApiFp(this.configuration).accountAuthFinalize(Body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Start authentication.
     * @param {AccountAuthInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    accountAuthInit(Body, options) {
        return AuthApiFp(this.configuration).accountAuthInit(Body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Complete opaque registration flow.
     * @param {AccountRegisterCreateRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    accountRegisterCreate(Body, options) {
        return AuthApiFp(this.configuration).accountRegisterCreate(Body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Finalize registration.
     * @param {AccountRegisterFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    accountRegisterFinalize(Body, options) {
        return AuthApiFp(this.configuration).accountRegisterFinalize(Body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Start registration process.
     * @param {AccountRegisterInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    accountRegisterInit(Body, options) {
        return AuthApiFp(this.configuration).accountRegisterInit(Body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Complete opaque reset flow.
     * @param {PasswordResetCreateRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    passwordResetCreate(Body, options) {
        return AuthApiFp(this.configuration).passwordResetCreate(Body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Finalize reset password.
     * @param {PasswordResetFinalizeRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    passwordResetFinalize(Body, options) {
        return AuthApiFp(this.configuration).passwordResetFinalize(Body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Start reset password process.
     * @param {PasswordResetInitRequestBody} [Body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    passwordResetInit(Body, options) {
        return AuthApiFp(this.configuration).passwordResetInit(Body, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * IdentityKeysApi - axios parameter creator
 * @export
 */
const IdentityKeysApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
         * @summary Identity key from blockchain address.
         * @param {string} Address Address to look for encoded based on the protocol standard.
         * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityKey: async (Address, Protocol, options = {}) => {
            // verify required parameter 'Address' is not null or undefined
            common.assertParamExists('getIdentityKey', 'Address', Address);
            // verify required parameter 'Protocol' is not null or undefined
            common.assertParamExists('getIdentityKey', 'Protocol', Protocol);
            const localVarPath = `/protocols/{protocol}/addresses/{address}/identity-key`
                .replace(`{${"address"}}`, encodeURIComponent(String(Address)))
                .replace(`{${"protocol"}}`, encodeURIComponent(String(Protocol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
         * @summary Gets all for an address for an identity key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityKeyAddresses: async (IdentityKey, options = {}) => {
            // verify required parameter 'IdentityKey' is not null or undefined
            common.assertParamExists('getIdentityKeyAddresses', 'IdentityKey', IdentityKey);
            const localVarPath = `/identity-keys/{identityKey}/addresses`
                .replace(`{${"identityKey"}}`, encodeURIComponent(String(IdentityKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
         * @summary Get all linked names for a resolver
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityKeyResolvableNames: async (IdentityKey, options = {}) => {
            // verify required parameter 'IdentityKey' is not null or undefined
            common.assertParamExists('getIdentityKeyResolvableNames', 'IdentityKey', IdentityKey);
            const localVarPath = `/identity-keys/{identityKey}/resolvable-names`
                .replace(`{${"identityKey"}}`, encodeURIComponent(String(IdentityKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Mailchain messaging key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMsgKey: async (IdentityKey, options = {}) => {
            // verify required parameter 'IdentityKey' is not null or undefined
            common.assertParamExists('getMsgKey', 'IdentityKey', IdentityKey);
            const localVarPath = `/identity-key/{identityKey}/messaging-key`
                .replace(`{${"identityKey"}}`, encodeURIComponent(String(IdentityKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
         * @summary Store address identity key.
         * @param {string} Address Address to look for encoded based on the protocol standard.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {string} Protocol Protocol where address is looked up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAddressIdentityKey: async (Address, IdentityKey, Protocol, options = {}) => {
            // verify required parameter 'Address' is not null or undefined
            common.assertParamExists('putAddressIdentityKey', 'Address', Address);
            // verify required parameter 'IdentityKey' is not null or undefined
            common.assertParamExists('putAddressIdentityKey', 'IdentityKey', IdentityKey);
            // verify required parameter 'Protocol' is not null or undefined
            common.assertParamExists('putAddressIdentityKey', 'Protocol', Protocol);
            const localVarPath = `/protocols/{protocol}/addresses/{address}/identity-keys/{identityKey}`
                .replace(`{${"address"}}`, encodeURIComponent(String(Address)))
                .replace(`{${"identityKey"}}`, encodeURIComponent(String(IdentityKey)))
                .replace(`{${"protocol"}}`, encodeURIComponent(String(Protocol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
         * @summary Upload a messaging key for an address\'s identity key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {PutMsgKeyByIDKeyRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMsgKeyByIDKey: async (IdentityKey, Body, options = {}) => {
            // verify required parameter 'IdentityKey' is not null or undefined
            common.assertParamExists('putMsgKeyByIDKey', 'IdentityKey', IdentityKey);
            // verify required parameter 'Body' is not null or undefined
            common.assertParamExists('putMsgKeyByIDKey', 'Body', Body);
            const localVarPath = `/identity-key/{identityKey}/messaging-key`
                .replace(`{${"identityKey"}}`, encodeURIComponent(String(IdentityKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * IdentityKeysApi - functional programming interface
 * @export
 */
const IdentityKeysApiFp = function (configuration) {
    const localVarAxiosParamCreator = IdentityKeysApiAxiosParamCreator(configuration);
    return {
        /**
         * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
         * @summary Identity key from blockchain address.
         * @param {string} Address Address to look for encoded based on the protocol standard.
         * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityKey(Address, Protocol, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityKey(Address, Protocol, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
         * @summary Gets all for an address for an identity key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityKeyAddresses(IdentityKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityKeyAddresses(IdentityKey, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
         * @summary Get all linked names for a resolver
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityKeyResolvableNames(IdentityKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityKeyResolvableNames(IdentityKey, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Mailchain messaging key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMsgKey(IdentityKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMsgKey(IdentityKey, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
         * @summary Store address identity key.
         * @param {string} Address Address to look for encoded based on the protocol standard.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {string} Protocol Protocol where address is looked up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAddressIdentityKey(Address, IdentityKey, Protocol, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAddressIdentityKey(Address, IdentityKey, Protocol, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
         * @summary Upload a messaging key for an address\'s identity key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {PutMsgKeyByIDKeyRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putMsgKeyByIDKey(IdentityKey, Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putMsgKeyByIDKey(IdentityKey, Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
    };
};
/**
 * IdentityKeysApi - factory interface
 * @export
 */
const IdentityKeysApiFactory = function (configuration, basePath, axios) {
    const localVarFp = IdentityKeysApiFp(configuration);
    return {
        /**
         * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
         * @summary Identity key from blockchain address.
         * @param {string} Address Address to look for encoded based on the protocol standard.
         * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityKey(Address, Protocol, options) {
            return localVarFp.getIdentityKey(Address, Protocol, options).then((request) => request(axios, basePath));
        },
        /**
         * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
         * @summary Gets all for an address for an identity key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityKeyAddresses(IdentityKey, options) {
            return localVarFp.getIdentityKeyAddresses(IdentityKey, options).then((request) => request(axios, basePath));
        },
        /**
         * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
         * @summary Get all linked names for a resolver
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityKeyResolvableNames(IdentityKey, options) {
            return localVarFp.getIdentityKeyResolvableNames(IdentityKey, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Mailchain messaging key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMsgKey(IdentityKey, options) {
            return localVarFp.getMsgKey(IdentityKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
         * @summary Store address identity key.
         * @param {string} Address Address to look for encoded based on the protocol standard.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {string} Protocol Protocol where address is looked up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAddressIdentityKey(Address, IdentityKey, Protocol, options) {
            return localVarFp.putAddressIdentityKey(Address, IdentityKey, Protocol, options).then((request) => request(axios, basePath));
        },
        /**
         * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
         * @summary Upload a messaging key for an address\'s identity key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {PutMsgKeyByIDKeyRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMsgKeyByIDKey(IdentityKey, Body, options) {
            return localVarFp.putMsgKeyByIDKey(IdentityKey, Body, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * IdentityKeysApi - object-oriented interface
 * @export
 * @class IdentityKeysApi
 * @extends {BaseAPI}
 */
class IdentityKeysApi extends base.BaseAPI {
    /**
     * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
     * @summary Identity key from blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    getIdentityKey(Address, Protocol, options) {
        return IdentityKeysApiFp(this.configuration).getIdentityKey(Address, Protocol, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    getIdentityKeyAddresses(IdentityKey, options) {
        return IdentityKeysApiFp(this.configuration).getIdentityKeyAddresses(IdentityKey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
     * @summary Get all linked names for a resolver
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    getIdentityKeyResolvableNames(IdentityKey, options) {
        return IdentityKeysApiFp(this.configuration).getIdentityKeyResolvableNames(IdentityKey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    getMsgKey(IdentityKey, options) {
        return IdentityKeysApiFp(this.configuration).getMsgKey(IdentityKey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
     * @summary Store address identity key.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {string} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    putAddressIdentityKey(Address, IdentityKey, Protocol, options) {
        return IdentityKeysApiFp(this.configuration).putAddressIdentityKey(Address, IdentityKey, Protocol, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    putMsgKeyByIDKey(IdentityKey, Body, options) {
        return IdentityKeysApiFp(this.configuration).putMsgKeyByIDKey(IdentityKey, Body, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * InboxApi - axios parameter creator
 * @export
 */
const InboxApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Remove label from message.
         * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
         * @param {string} Label Label to add to the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessageLabel: async (MessageId, Label, options = {}) => {
            // verify required parameter 'MessageId' is not null or undefined
            common.assertParamExists('deleteMessageLabel', 'MessageId', MessageId);
            // verify required parameter 'Label' is not null or undefined
            common.assertParamExists('deleteMessageLabel', 'Label', Label);
            const localVarPath = `/inbox/messages/{messageId}/labels/{label}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(MessageId)))
                .replace(`{${"label"}}`, encodeURIComponent(String(Label)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get encrypted payload message body
         * @param {string} MessageId The message id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEncryptedMessageBody: async (MessageId, options = {}) => {
            // verify required parameter 'MessageId' is not null or undefined
            common.assertParamExists('getEncryptedMessageBody', 'MessageId', MessageId);
            const localVarPath = `/inbox/messages/{messageId}/body`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(MessageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get message item
         * @param {string} MessageId The message id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage: async (MessageId, options = {}) => {
            // verify required parameter 'MessageId' is not null or undefined
            common.assertParamExists('getMessage', 'MessageId', MessageId);
            const localVarPath = `/inbox/messages/{messageId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(MessageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get messages that have been archived
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesInArchivedView: async (options = {}) => {
            const localVarPath = `/inbox/views/archived`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get messages in inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesInInboxView: async (options = {}) => {
            const localVarPath = `/inbox/views/inbox`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get messages that have not sent yet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesInOutboxView: async (options = {}) => {
            const localVarPath = `/inbox/views/outbox`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get messages in sent folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesInSentView: async (options = {}) => {
            const localVarPath = `/inbox/views/sent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get messages marked as starred by the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesInStarredView: async (options = {}) => {
            const localVarPath = `/inbox/views/starred`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get messages in trash folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesInTrashView: async (options = {}) => {
            const localVarPath = `/inbox/views/trash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get messages that have not been read by the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesInUnreadView: async (options = {}) => {
            const localVarPath = `/inbox/views/unread`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get messages
         * @param {Array<string>} [Labels] Labels to search for.
         * @param {string} [From] Messages from. Rather than the address the identity key is hashed and searched for.
         * @param {Array<string>} [To] Messages to. Rather than the address the identity key is hashed and searched for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesSearch: async (Labels, From, To, options = {}) => {
            const localVarPath = `/inbox/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (Labels) {
                localVarQueryParameter['labels'] = Labels.join(base.COLLECTION_FORMATS.csv);
            }
            if (From !== undefined) {
                localVarQueryParameter['from'] = From;
            }
            if (To) {
                localVarQueryParameter['to'] = To.join(base.COLLECTION_FORMATS.csv);
            }
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store a message body for later retrieval
         * @param {object} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEncryptedMessageBody: async (Body, options = {}) => {
            // verify required parameter 'Body' is not null or undefined
            common.assertParamExists('postEncryptedMessageBody', 'Body', Body);
            const localVarPath = `/inbox/message-bodies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
         * @summary Add message to inbox.
         * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
         * @param {PutEncryptedMessageRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putEncryptedMessage: async (MessageId, Body, options = {}) => {
            // verify required parameter 'MessageId' is not null or undefined
            common.assertParamExists('putEncryptedMessage', 'MessageId', MessageId);
            // verify required parameter 'Body' is not null or undefined
            common.assertParamExists('putEncryptedMessage', 'Body', Body);
            const localVarPath = `/inbox/messages/{messageId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(MessageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add label to message.
         * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
         * @param {string} Label Label to add to the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMessageLabel: async (MessageId, Label, options = {}) => {
            // verify required parameter 'MessageId' is not null or undefined
            common.assertParamExists('putMessageLabel', 'MessageId', MessageId);
            // verify required parameter 'Label' is not null or undefined
            common.assertParamExists('putMessageLabel', 'Label', Label);
            const localVarPath = `/inbox/messages/{messageId}/labels/{label}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(MessageId)))
                .replace(`{${"label"}}`, encodeURIComponent(String(Label)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * InboxApi - functional programming interface
 * @export
 */
const InboxApiFp = function (configuration) {
    const localVarAxiosParamCreator = InboxApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Remove label from message.
         * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
         * @param {string} Label Label to add to the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessageLabel(MessageId, Label, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessageLabel(MessageId, Label, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Get encrypted payload message body
         * @param {string} MessageId The message id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEncryptedMessageBody(MessageId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEncryptedMessageBody(MessageId, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Get message item
         * @param {string} MessageId The message id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessage(MessageId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessage(MessageId, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Get messages that have been archived
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessagesInArchivedView(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesInArchivedView(options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Get messages in inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessagesInInboxView(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesInInboxView(options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get messages that have not sent yet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessagesInOutboxView(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesInOutboxView(options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Get messages in sent folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessagesInSentView(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesInSentView(options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get messages marked as starred by the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessagesInStarredView(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesInStarredView(options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Get messages in trash folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessagesInTrashView(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesInTrashView(options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get messages that have not been read by the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessagesInUnreadView(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesInUnreadView(options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Get messages
         * @param {Array<string>} [Labels] Labels to search for.
         * @param {string} [From] Messages from. Rather than the address the identity key is hashed and searched for.
         * @param {Array<string>} [To] Messages to. Rather than the address the identity key is hashed and searched for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessagesSearch(Labels, From, To, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesSearch(Labels, From, To, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Store a message body for later retrieval
         * @param {object} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postEncryptedMessageBody(Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postEncryptedMessageBody(Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
         * @summary Add message to inbox.
         * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
         * @param {PutEncryptedMessageRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putEncryptedMessage(MessageId, Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putEncryptedMessage(MessageId, Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Add label to message.
         * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
         * @param {string} Label Label to add to the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putMessageLabel(MessageId, Label, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putMessageLabel(MessageId, Label, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
    };
};
/**
 * InboxApi - factory interface
 * @export
 */
const InboxApiFactory = function (configuration, basePath, axios) {
    const localVarFp = InboxApiFp(configuration);
    return {
        /**
         *
         * @summary Remove label from message.
         * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
         * @param {string} Label Label to add to the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessageLabel(MessageId, Label, options) {
            return localVarFp.deleteMessageLabel(MessageId, Label, options).then((request) => request(axios, basePath));
        },
        /**
         * Get encrypted payload message body
         * @param {string} MessageId The message id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEncryptedMessageBody(MessageId, options) {
            return localVarFp.getEncryptedMessageBody(MessageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get message item
         * @param {string} MessageId The message id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(MessageId, options) {
            return localVarFp.getMessage(MessageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get messages that have been archived
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesInArchivedView(options) {
            return localVarFp.getMessagesInArchivedView(options).then((request) => request(axios, basePath));
        },
        /**
         * Get messages in inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesInInboxView(options) {
            return localVarFp.getMessagesInInboxView(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get messages that have not sent yet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesInOutboxView(options) {
            return localVarFp.getMessagesInOutboxView(options).then((request) => request(axios, basePath));
        },
        /**
         * Get messages in sent folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesInSentView(options) {
            return localVarFp.getMessagesInSentView(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get messages marked as starred by the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesInStarredView(options) {
            return localVarFp.getMessagesInStarredView(options).then((request) => request(axios, basePath));
        },
        /**
         * Get messages in trash folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesInTrashView(options) {
            return localVarFp.getMessagesInTrashView(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get messages that have not been read by the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesInUnreadView(options) {
            return localVarFp.getMessagesInUnreadView(options).then((request) => request(axios, basePath));
        },
        /**
         * Get messages
         * @param {Array<string>} [Labels] Labels to search for.
         * @param {string} [From] Messages from. Rather than the address the identity key is hashed and searched for.
         * @param {Array<string>} [To] Messages to. Rather than the address the identity key is hashed and searched for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesSearch(Labels, From, To, options) {
            return localVarFp.getMessagesSearch(Labels, From, To, options).then((request) => request(axios, basePath));
        },
        /**
         * Store a message body for later retrieval
         * @param {object} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEncryptedMessageBody(Body, options) {
            return localVarFp.postEncryptedMessageBody(Body, options).then((request) => request(axios, basePath));
        },
        /**
         * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
         * @summary Add message to inbox.
         * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
         * @param {PutEncryptedMessageRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putEncryptedMessage(MessageId, Body, options) {
            return localVarFp.putEncryptedMessage(MessageId, Body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add label to message.
         * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
         * @param {string} Label Label to add to the message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMessageLabel(MessageId, Label, options) {
            return localVarFp.putMessageLabel(MessageId, Label, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * InboxApi - object-oriented interface
 * @export
 * @class InboxApi
 * @extends {BaseAPI}
 */
class InboxApi extends base.BaseAPI {
    /**
     *
     * @summary Remove label from message.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} Label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    deleteMessageLabel(MessageId, Label, options) {
        return InboxApiFp(this.configuration).deleteMessageLabel(MessageId, Label, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get encrypted payload message body
     * @param {string} MessageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getEncryptedMessageBody(MessageId, options) {
        return InboxApiFp(this.configuration).getEncryptedMessageBody(MessageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get message item
     * @param {string} MessageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessage(MessageId, options) {
        return InboxApiFp(this.configuration).getMessage(MessageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get messages that have been archived
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInArchivedView(options) {
        return InboxApiFp(this.configuration).getMessagesInArchivedView(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get messages in inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInInboxView(options) {
        return InboxApiFp(this.configuration).getMessagesInInboxView(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get messages that have not sent yet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInOutboxView(options) {
        return InboxApiFp(this.configuration).getMessagesInOutboxView(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get messages in sent folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInSentView(options) {
        return InboxApiFp(this.configuration).getMessagesInSentView(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get messages marked as starred by the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInStarredView(options) {
        return InboxApiFp(this.configuration).getMessagesInStarredView(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get messages in trash folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInTrashView(options) {
        return InboxApiFp(this.configuration).getMessagesInTrashView(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get messages that have not been read by the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInUnreadView(options) {
        return InboxApiFp(this.configuration).getMessagesInUnreadView(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get messages
     * @param {Array<string>} [Labels] Labels to search for.
     * @param {string} [From] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [To] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesSearch(Labels, From, To, options) {
        return InboxApiFp(this.configuration).getMessagesSearch(Labels, From, To, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Store a message body for later retrieval
     * @param {object} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    postEncryptedMessageBody(Body, options) {
        return InboxApiFp(this.configuration).postEncryptedMessageBody(Body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
     * @summary Add message to inbox.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {PutEncryptedMessageRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    putEncryptedMessage(MessageId, Body, options) {
        return InboxApiFp(this.configuration).putEncryptedMessage(MessageId, Body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add label to message.
     * @param {string} MessageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} Label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    putMessageLabel(MessageId, Label, options) {
        return InboxApiFp(this.configuration).putMessageLabel(MessageId, Label, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * MessagingKeysApi - axios parameter creator
 * @export
 */
const MessagingKeysApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
         * @summary Gets all for an address for an identity key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityKeyAddresses: async (IdentityKey, options = {}) => {
            // verify required parameter 'IdentityKey' is not null or undefined
            common.assertParamExists('getIdentityKeyAddresses', 'IdentityKey', IdentityKey);
            const localVarPath = `/identity-keys/{identityKey}/addresses`
                .replace(`{${"identityKey"}}`, encodeURIComponent(String(IdentityKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get identity key nonce
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityKeyNonce: async (IdentityKey, options = {}) => {
            // verify required parameter 'IdentityKey' is not null or undefined
            common.assertParamExists('getIdentityKeyNonce', 'IdentityKey', IdentityKey);
            const localVarPath = `/identity-key/{identityKey}/nonce`
                .replace(`{${"identityKey"}}`, encodeURIComponent(String(IdentityKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailchainPublicKey: async (options = {}) => {
            const localVarPath = `/verification-keys/messaging`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Mailchain messaging key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMsgKey: async (IdentityKey, options = {}) => {
            // verify required parameter 'IdentityKey' is not null or undefined
            common.assertParamExists('getMsgKey', 'IdentityKey', IdentityKey);
            const localVarPath = `/identity-key/{identityKey}/messaging-key`
                .replace(`{${"identityKey"}}`, encodeURIComponent(String(IdentityKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get protocol address nonce
         * @param {string} Address Address to look for encoded based on the protocol standard.
         * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProtocolAddressNonce: async (Address, Protocol, options = {}) => {
            // verify required parameter 'Address' is not null or undefined
            common.assertParamExists('getProtocolAddressNonce', 'Address', Address);
            // verify required parameter 'Protocol' is not null or undefined
            common.assertParamExists('getProtocolAddressNonce', 'Protocol', Protocol);
            const localVarPath = `/protocols/{protocol}/addresses/{address}/nonce`
                .replace(`{${"address"}}`, encodeURIComponent(String(Address)))
                .replace(`{${"protocol"}}`, encodeURIComponent(String(Protocol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
         * @summary Get\'s the private messaging key for a blockchain address.
         * @param {string} Address Address to look for encoded based on the protocol standard.
         * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVendedPrivateMessagingKey: async (Address, Protocol, IdentityKey, options = {}) => {
            // verify required parameter 'Address' is not null or undefined
            common.assertParamExists('getVendedPrivateMessagingKey', 'Address', Address);
            // verify required parameter 'Protocol' is not null or undefined
            common.assertParamExists('getVendedPrivateMessagingKey', 'Protocol', Protocol);
            // verify required parameter 'IdentityKey' is not null or undefined
            common.assertParamExists('getVendedPrivateMessagingKey', 'IdentityKey', IdentityKey);
            const localVarPath = `/protocols/{protocol}/addresses/{address}/vended-private-messaging-key`
                .replace(`{${"address"}}`, encodeURIComponent(String(Address)))
                .replace(`{${"protocol"}}`, encodeURIComponent(String(Protocol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (IdentityKey !== undefined) {
                localVarQueryParameter['identityKey'] = IdentityKey;
            }
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
         * @summary Get\'s the public messaging key for a blockchain address.
         * @param {string} Address Address to look for encoded based on the protocol standard.
         * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVendedPublicMessagingKey: async (Address, Protocol, options = {}) => {
            // verify required parameter 'Address' is not null or undefined
            common.assertParamExists('getVendedPublicMessagingKey', 'Address', Address);
            // verify required parameter 'Protocol' is not null or undefined
            common.assertParamExists('getVendedPublicMessagingKey', 'Protocol', Protocol);
            const localVarPath = `/protocols/{protocol}/addresses/{address}/vended-public-messaging-key`
                .replace(`{${"address"}}`, encodeURIComponent(String(Address)))
                .replace(`{${"protocol"}}`, encodeURIComponent(String(Protocol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
         * @summary Upload a messaging key for an address\'s identity key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {PutMsgKeyByIDKeyRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMsgKeyByIDKey: async (IdentityKey, Body, options = {}) => {
            // verify required parameter 'IdentityKey' is not null or undefined
            common.assertParamExists('putMsgKeyByIDKey', 'IdentityKey', IdentityKey);
            // verify required parameter 'Body' is not null or undefined
            common.assertParamExists('putMsgKeyByIDKey', 'Body', Body);
            const localVarPath = `/identity-key/{identityKey}/messaging-key`
                .replace(`{${"identityKey"}}`, encodeURIComponent(String(IdentityKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MessagingKeysApi - functional programming interface
 * @export
 */
const MessagingKeysApiFp = function (configuration) {
    const localVarAxiosParamCreator = MessagingKeysApiAxiosParamCreator(configuration);
    return {
        /**
         * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
         * @summary Gets all for an address for an identity key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityKeyAddresses(IdentityKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityKeyAddresses(IdentityKey, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Get identity key nonce
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityKeyNonce(IdentityKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityKeyNonce(IdentityKey, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMailchainPublicKey(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMailchainPublicKey(options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Mailchain messaging key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMsgKey(IdentityKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMsgKey(IdentityKey, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Get protocol address nonce
         * @param {string} Address Address to look for encoded based on the protocol standard.
         * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProtocolAddressNonce(Address, Protocol, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProtocolAddressNonce(Address, Protocol, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
         * @summary Get\'s the private messaging key for a blockchain address.
         * @param {string} Address Address to look for encoded based on the protocol standard.
         * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVendedPrivateMessagingKey(Address, Protocol, IdentityKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVendedPrivateMessagingKey(Address, Protocol, IdentityKey, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
         * @summary Get\'s the public messaging key for a blockchain address.
         * @param {string} Address Address to look for encoded based on the protocol standard.
         * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVendedPublicMessagingKey(Address, Protocol, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVendedPublicMessagingKey(Address, Protocol, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
         * @summary Upload a messaging key for an address\'s identity key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {PutMsgKeyByIDKeyRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putMsgKeyByIDKey(IdentityKey, Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putMsgKeyByIDKey(IdentityKey, Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
    };
};
/**
 * MessagingKeysApi - factory interface
 * @export
 */
const MessagingKeysApiFactory = function (configuration, basePath, axios) {
    const localVarFp = MessagingKeysApiFp(configuration);
    return {
        /**
         * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
         * @summary Gets all for an address for an identity key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityKeyAddresses(IdentityKey, options) {
            return localVarFp.getIdentityKeyAddresses(IdentityKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get identity key nonce
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityKeyNonce(IdentityKey, options) {
            return localVarFp.getIdentityKeyNonce(IdentityKey, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMailchainPublicKey(options) {
            return localVarFp.getMailchainPublicKey(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Mailchain messaging key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMsgKey(IdentityKey, options) {
            return localVarFp.getMsgKey(IdentityKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get protocol address nonce
         * @param {string} Address Address to look for encoded based on the protocol standard.
         * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProtocolAddressNonce(Address, Protocol, options) {
            return localVarFp.getProtocolAddressNonce(Address, Protocol, options).then((request) => request(axios, basePath));
        },
        /**
         * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
         * @summary Get\'s the private messaging key for a blockchain address.
         * @param {string} Address Address to look for encoded based on the protocol standard.
         * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVendedPrivateMessagingKey(Address, Protocol, IdentityKey, options) {
            return localVarFp.getVendedPrivateMessagingKey(Address, Protocol, IdentityKey, options).then((request) => request(axios, basePath));
        },
        /**
         * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
         * @summary Get\'s the public messaging key for a blockchain address.
         * @param {string} Address Address to look for encoded based on the protocol standard.
         * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVendedPublicMessagingKey(Address, Protocol, options) {
            return localVarFp.getVendedPublicMessagingKey(Address, Protocol, options).then((request) => request(axios, basePath));
        },
        /**
         * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
         * @summary Upload a messaging key for an address\'s identity key.
         * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
         * @param {PutMsgKeyByIDKeyRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMsgKeyByIDKey(IdentityKey, Body, options) {
            return localVarFp.putMsgKeyByIDKey(IdentityKey, Body, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * MessagingKeysApi - object-oriented interface
 * @export
 * @class MessagingKeysApi
 * @extends {BaseAPI}
 */
class MessagingKeysApi extends base.BaseAPI {
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getIdentityKeyAddresses(IdentityKey, options) {
        return MessagingKeysApiFp(this.configuration).getIdentityKeyAddresses(IdentityKey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get identity key nonce
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getIdentityKeyNonce(IdentityKey, options) {
        return MessagingKeysApiFp(this.configuration).getIdentityKeyNonce(IdentityKey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getMailchainPublicKey(options) {
        return MessagingKeysApiFp(this.configuration).getMailchainPublicKey(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getMsgKey(IdentityKey, options) {
        return MessagingKeysApiFp(this.configuration).getMsgKey(IdentityKey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get protocol address nonce
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getProtocolAddressNonce(Address, Protocol, options) {
        return MessagingKeysApiFp(this.configuration).getProtocolAddressNonce(Address, Protocol, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
     * @summary Get\'s the private messaging key for a blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getVendedPrivateMessagingKey(Address, Protocol, IdentityKey, options) {
        return MessagingKeysApiFp(this.configuration).getVendedPrivateMessagingKey(Address, Protocol, IdentityKey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
     * @summary Get\'s the public messaging key for a blockchain address.
     * @param {string} Address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin'} Protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getVendedPublicMessagingKey(Address, Protocol, options) {
        return MessagingKeysApiFp(this.configuration).getVendedPublicMessagingKey(Address, Protocol, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} IdentityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    putMsgKeyByIDKey(IdentityKey, Body, options) {
        return MessagingKeysApiFp(this.configuration).putMsgKeyByIDKey(IdentityKey, Body, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TransportApi - axios parameter creator
 * @export
 */
const TransportApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get unconfirmed delivery requests for a recipient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeliveryRequests: async (options = {}) => {
            const localVarPath = `/transport/delivery-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get encrypted payload message body
         * @param {string} PayloadId The payload id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEncryptedPayload: async (PayloadId, options = {}) => {
            // verify required parameter 'PayloadId' is not null or undefined
            common.assertParamExists('getEncryptedPayload', 'PayloadId', PayloadId);
            const localVarPath = `/transport/payloads/{payloadId}`
                .replace(`{${"payloadId"}}`, encodeURIComponent(String(PayloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new request that delivers a message to the intended address.
         * @summary Add a delivery request
         * @param {PostDeliveryRequestRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeliveryRequest: async (Body, options = {}) => {
            // verify required parameter 'Body' is not null or undefined
            common.assertParamExists('postDeliveryRequest', 'Body', Body);
            const localVarPath = `/transport/delivery-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store a payload for later delivery
         * @param {object} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEncryptedPayload: async (Body, options = {}) => {
            // verify required parameter 'Body' is not null or undefined
            common.assertParamExists('postEncryptedPayload', 'Body', Body);
            const localVarPath = `/transport/payloads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Put delivery request confirmation
         * @param {string} DeliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
         * @param {PutDeliveryRequestConfirmationRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDeliveryRequestConfirmation: async (DeliveryRequestHash, Body, options = {}) => {
            // verify required parameter 'DeliveryRequestHash' is not null or undefined
            common.assertParamExists('putDeliveryRequestConfirmation', 'DeliveryRequestHash', DeliveryRequestHash);
            // verify required parameter 'Body' is not null or undefined
            common.assertParamExists('putDeliveryRequestConfirmation', 'Body', Body);
            const localVarPath = `/transport/delivery-requests/{deliveryRequestHash}/delivery-proof`
                .replace(`{${"deliveryRequestHash"}}`, encodeURIComponent(String(DeliveryRequestHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TransportApi - functional programming interface
 * @export
 */
const TransportApiFp = function (configuration) {
    const localVarAxiosParamCreator = TransportApiAxiosParamCreator(configuration);
    return {
        /**
         * Get unconfirmed delivery requests for a recipient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeliveryRequests(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeliveryRequests(options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Get encrypted payload message body
         * @param {string} PayloadId The payload id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEncryptedPayload(PayloadId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEncryptedPayload(PayloadId, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Create a new request that delivers a message to the intended address.
         * @summary Add a delivery request
         * @param {PostDeliveryRequestRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDeliveryRequest(Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDeliveryRequest(Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Store a payload for later delivery
         * @param {object} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postEncryptedPayload(Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postEncryptedPayload(Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Put delivery request confirmation
         * @param {string} DeliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
         * @param {PutDeliveryRequestConfirmationRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putDeliveryRequestConfirmation(DeliveryRequestHash, Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putDeliveryRequestConfirmation(DeliveryRequestHash, Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
    };
};
/**
 * TransportApi - factory interface
 * @export
 */
const TransportApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TransportApiFp(configuration);
    return {
        /**
         * Get unconfirmed delivery requests for a recipient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeliveryRequests(options) {
            return localVarFp.getDeliveryRequests(options).then((request) => request(axios, basePath));
        },
        /**
         * Get encrypted payload message body
         * @param {string} PayloadId The payload id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEncryptedPayload(PayloadId, options) {
            return localVarFp.getEncryptedPayload(PayloadId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new request that delivers a message to the intended address.
         * @summary Add a delivery request
         * @param {PostDeliveryRequestRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeliveryRequest(Body, options) {
            return localVarFp.postDeliveryRequest(Body, options).then((request) => request(axios, basePath));
        },
        /**
         * Store a payload for later delivery
         * @param {object} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEncryptedPayload(Body, options) {
            return localVarFp.postEncryptedPayload(Body, options).then((request) => request(axios, basePath));
        },
        /**
         * Put delivery request confirmation
         * @param {string} DeliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
         * @param {PutDeliveryRequestConfirmationRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDeliveryRequestConfirmation(DeliveryRequestHash, Body, options) {
            return localVarFp.putDeliveryRequestConfirmation(DeliveryRequestHash, Body, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TransportApi - object-oriented interface
 * @export
 * @class TransportApi
 * @extends {BaseAPI}
 */
class TransportApi extends base.BaseAPI {
    /**
     * Get unconfirmed delivery requests for a recipient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApi
     */
    getDeliveryRequests(options) {
        return TransportApiFp(this.configuration).getDeliveryRequests(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get encrypted payload message body
     * @param {string} PayloadId The payload id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApi
     */
    getEncryptedPayload(PayloadId, options) {
        return TransportApiFp(this.configuration).getEncryptedPayload(PayloadId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new request that delivers a message to the intended address.
     * @summary Add a delivery request
     * @param {PostDeliveryRequestRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApi
     */
    postDeliveryRequest(Body, options) {
        return TransportApiFp(this.configuration).postDeliveryRequest(Body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Store a payload for later delivery
     * @param {object} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApi
     */
    postEncryptedPayload(Body, options) {
        return TransportApiFp(this.configuration).postEncryptedPayload(Body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Put delivery request confirmation
     * @param {string} DeliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
     * @param {PutDeliveryRequestConfirmationRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApi
     */
    putDeliveryRequestConfirmation(DeliveryRequestHash, Body, options) {
        return TransportApiFp(this.configuration).putDeliveryRequestConfirmation(DeliveryRequestHash, Body, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserApi - axios parameter creator
 * @export
 */
const UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Deletes an mailbox from the account.
         * @param {string} MailboxId ID of the mailbox to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserMailbox: async (MailboxId, options = {}) => {
            // verify required parameter 'MailboxId' is not null or undefined
            common.assertParamExists('deleteUserMailbox', 'MailboxId', MailboxId);
            const localVarPath = `/user/mailboxes/{mailboxId}`
                .replace(`{${"mailboxId"}}`, encodeURIComponent(String(MailboxId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
         * @summary Session cookie.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionCookie: async (options = {}) => {
            const localVarPath = `/user/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get mailboxes registered with Mailchain account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserMailboxes: async (options = {}) => {
            const localVarPath = `/user/mailboxes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Mailchain messaging key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings: async (options = {}) => {
            const localVarPath = `/user/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get username for currently authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsername: async (options = {}) => {
            const localVarPath = `/user/username`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Adds an mailboxes to an account.
         * @param {PostUserMailboxRequestBody} Body Encrypted list of mailboxes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserMailbox: async (Body, options = {}) => {
            // verify required parameter 'Body' is not null or undefined
            common.assertParamExists('postUserMailbox', 'Body', Body);
            const localVarPath = `/user/mailboxes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates a previous stored mailbox for an account.
         * @param {string} MailboxId ID of the mailbox to update
         * @param {PutUserMailboxRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserMailbox: async (MailboxId, Body, options = {}) => {
            // verify required parameter 'MailboxId' is not null or undefined
            common.assertParamExists('putUserMailbox', 'MailboxId', MailboxId);
            // verify required parameter 'Body' is not null or undefined
            common.assertParamExists('putUserMailbox', 'Body', Body);
            const localVarPath = `/user/mailboxes/{mailboxId}`
                .replace(`{${"mailboxId"}}`, encodeURIComponent(String(MailboxId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Sets a user setting.
         * @param {string} Setting Name of the setting to store
         * @param {PutUserSettingRequestBody} Body Encrypted private key to store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserSetting: async (Setting, Body, options = {}) => {
            // verify required parameter 'Setting' is not null or undefined
            common.assertParamExists('putUserSetting', 'Setting', Setting);
            // verify required parameter 'Body' is not null or undefined
            common.assertParamExists('putUserSetting', 'Body', Body);
            const localVarPath = `/user/settings/{setting}`
                .replace(`{${"setting"}}`, encodeURIComponent(String(Setting)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = common.serializeDataIfNeeded(Body, localVarRequestOptions, configuration);
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserApi - functional programming interface
 * @export
 */
const UserApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Deletes an mailbox from the account.
         * @param {string} MailboxId ID of the mailbox to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserMailbox(MailboxId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserMailbox(MailboxId, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
         * @summary Session cookie.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionCookie(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionCookie(options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get mailboxes registered with Mailchain account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserMailboxes(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserMailboxes(options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a Mailchain messaging key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSettings(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSettings(options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         * Get username for currently authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsername(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsername(options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Adds an mailboxes to an account.
         * @param {PostUserMailboxRequestBody} Body Encrypted list of mailboxes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserMailbox(Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserMailbox(Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates a previous stored mailbox for an account.
         * @param {string} MailboxId ID of the mailbox to update
         * @param {PutUserMailboxRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserMailbox(MailboxId, Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserMailbox(MailboxId, Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Sets a user setting.
         * @param {string} Setting Name of the setting to store
         * @param {PutUserSettingRequestBody} Body Encrypted private key to store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUserSetting(Setting, Body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUserSetting(Setting, Body, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
    };
};
/**
 * UserApi - factory interface
 * @export
 */
const UserApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserApiFp(configuration);
    return {
        /**
         *
         * @summary Deletes an mailbox from the account.
         * @param {string} MailboxId ID of the mailbox to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserMailbox(MailboxId, options) {
            return localVarFp.deleteUserMailbox(MailboxId, options).then((request) => request(axios, basePath));
        },
        /**
         * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
         * @summary Session cookie.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionCookie(options) {
            return localVarFp.getSessionCookie(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get mailboxes registered with Mailchain account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserMailboxes(options) {
            return localVarFp.getUserMailboxes(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a Mailchain messaging key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings(options) {
            return localVarFp.getUserSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Get username for currently authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsername(options) {
            return localVarFp.getUsername(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Adds an mailboxes to an account.
         * @param {PostUserMailboxRequestBody} Body Encrypted list of mailboxes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserMailbox(Body, options) {
            return localVarFp.postUserMailbox(Body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a previous stored mailbox for an account.
         * @param {string} MailboxId ID of the mailbox to update
         * @param {PutUserMailboxRequestBody} Body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserMailbox(MailboxId, Body, options) {
            return localVarFp.putUserMailbox(MailboxId, Body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Sets a user setting.
         * @param {string} Setting Name of the setting to store
         * @param {PutUserSettingRequestBody} Body Encrypted private key to store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserSetting(Setting, Body, options) {
            return localVarFp.putUserSetting(Setting, Body, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends base.BaseAPI {
    /**
     *
     * @summary Deletes an mailbox from the account.
     * @param {string} MailboxId ID of the mailbox to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUserMailbox(MailboxId, options) {
        return UserApiFp(this.configuration).deleteUserMailbox(MailboxId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
     * @summary Session cookie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getSessionCookie(options) {
        return UserApiFp(this.configuration).getSessionCookie(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get mailboxes registered with Mailchain account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserMailboxes(options) {
        return UserApiFp(this.configuration).getUserMailboxes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserSettings(options) {
        return UserApiFp(this.configuration).getUserSettings(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get username for currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUsername(options) {
        return UserApiFp(this.configuration).getUsername(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Adds an mailboxes to an account.
     * @param {PostUserMailboxRequestBody} Body Encrypted list of mailboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    postUserMailbox(Body, options) {
        return UserApiFp(this.configuration).postUserMailbox(Body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a previous stored mailbox for an account.
     * @param {string} MailboxId ID of the mailbox to update
     * @param {PutUserMailboxRequestBody} Body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    putUserMailbox(MailboxId, Body, options) {
        return UserApiFp(this.configuration).putUserMailbox(MailboxId, Body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Sets a user setting.
     * @param {string} Setting Name of the setting to store
     * @param {PutUserSettingRequestBody} Body Encrypted private key to store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    putUserSetting(Setting, Body, options) {
        return UserApiFp(this.configuration).putUserSetting(Setting, Body, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UsersApi - axios parameter creator
 * @export
 */
const UsersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This method will get the identity key associated with the Mailchain username.
         * @summary Identity key from blockchain address.
         * @param {string} Username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserIdentityKey: async (Username, options = {}) => {
            // verify required parameter 'Username' is not null or undefined
            common.assertParamExists('getUserIdentityKey', 'Username', Username);
            const localVarPath = `/users/{username}/identity-key`
                .replace(`{${"username"}}`, encodeURIComponent(String(Username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Used to check if an username exists.
         * @param {string} Username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsernameAvailable: async (Username, options = {}) => {
            // verify required parameter 'Username' is not null or undefined
            common.assertParamExists('getUsernameAvailable', 'Username', Username);
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (Username !== undefined) {
                localVarQueryParameter['username'] = Username;
            }
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UsersApi - functional programming interface
 * @export
 */
const UsersApiFp = function (configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
    return {
        /**
         * This method will get the identity key associated with the Mailchain username.
         * @summary Identity key from blockchain address.
         * @param {string} Username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserIdentityKey(Username, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserIdentityKey(Username, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Used to check if an username exists.
         * @param {string} Username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsernameAvailable(Username, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsernameAvailable(Username, options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
    };
};
/**
 * UsersApi - factory interface
 * @export
 */
const UsersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UsersApiFp(configuration);
    return {
        /**
         * This method will get the identity key associated with the Mailchain username.
         * @summary Identity key from blockchain address.
         * @param {string} Username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserIdentityKey(Username, options) {
            return localVarFp.getUserIdentityKey(Username, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Used to check if an username exists.
         * @param {string} Username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsernameAvailable(Username, options) {
            return localVarFp.getUsernameAvailable(Username, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
class UsersApi extends base.BaseAPI {
    /**
     * This method will get the identity key associated with the Mailchain username.
     * @summary Identity key from blockchain address.
     * @param {string} Username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserIdentityKey(Username, options) {
        return UsersApiFp(this.configuration).getUserIdentityKey(Username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Used to check if an username exists.
     * @param {string} Username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsernameAvailable(Username, options) {
        return UsersApiFp(this.configuration).getUsernameAvailable(Username, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * VersionApi - axios parameter creator
 * @export
 */
const VersionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
         * @summary Get version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options = {}) => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            common.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: common.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * VersionApi - functional programming interface
 * @export
 */
const VersionApiFp = function (configuration) {
    const localVarAxiosParamCreator = VersionApiAxiosParamCreator(configuration);
    return {
        /**
         * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
         * @summary Get version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(options);
            return common.createRequestFunction(localVarAxiosArgs, globalAxios, base.BASE_PATH, configuration);
        },
    };
};
/**
 * VersionApi - factory interface
 * @export
 */
const VersionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = VersionApiFp(configuration);
    return {
        /**
         * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
         * @summary Get version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options) {
            return localVarFp.getVersion(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
class VersionApi extends base.BaseAPI {
    /**
     * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
     * @summary Get version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    getVersion(options) {
        return VersionApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }
}

exports.AddressEncodingEnum = AddressEncodingEnum;
exports.AddressesApi = AddressesApi;
exports.AddressesApiAxiosParamCreator = AddressesApiAxiosParamCreator;
exports.AddressesApiFactory = AddressesApiFactory;
exports.AddressesApiFp = AddressesApiFp;
exports.AuthApi = AuthApi;
exports.AuthApiAxiosParamCreator = AuthApiAxiosParamCreator;
exports.AuthApiFactory = AuthApiFactory;
exports.AuthApiFp = AuthApiFp;
exports.ContractCallMethodEnum = ContractCallMethodEnum;
exports.EncryptedAccountSecretEncryptionKindEnum = EncryptedAccountSecretEncryptionKindEnum;
exports.EncryptedAccountSecretSecretKindEnum = EncryptedAccountSecretSecretKindEnum;
exports.GetUsernameAvailableResponseBodyReasonEnum = GetUsernameAvailableResponseBodyReasonEnum;
exports.IdentityKeysApi = IdentityKeysApi;
exports.IdentityKeysApiAxiosParamCreator = IdentityKeysApiAxiosParamCreator;
exports.IdentityKeysApiFactory = IdentityKeysApiFactory;
exports.IdentityKeysApiFp = IdentityKeysApiFp;
exports.InboxApi = InboxApi;
exports.InboxApiAxiosParamCreator = InboxApiAxiosParamCreator;
exports.InboxApiFactory = InboxApiFactory;
exports.InboxApiFp = InboxApiFp;
exports.MessagingKeysApi = MessagingKeysApi;
exports.MessagingKeysApiAxiosParamCreator = MessagingKeysApiAxiosParamCreator;
exports.MessagingKeysApiFactory = MessagingKeysApiFactory;
exports.MessagingKeysApiFp = MessagingKeysApiFp;
exports.PrivateKeyCurveEnum = PrivateKeyCurveEnum;
exports.PrivateKeyEncodingEnum = PrivateKeyEncodingEnum;
exports.PublicKeyCurveEnum = PublicKeyCurveEnum;
exports.PublicKeyEncodingEnum = PublicKeyEncodingEnum;
exports.PutEncryptedMessageRequestBodyFolderEnum = PutEncryptedMessageRequestBodyFolderEnum;
exports.RegisteredKeyProofSigningMethodEnum = RegisteredKeyProofSigningMethodEnum;
exports.TransportApi = TransportApi;
exports.TransportApiAxiosParamCreator = TransportApiAxiosParamCreator;
exports.TransportApiFactory = TransportApiFactory;
exports.TransportApiFp = TransportApiFp;
exports.UserApi = UserApi;
exports.UserApiAxiosParamCreator = UserApiAxiosParamCreator;
exports.UserApiFactory = UserApiFactory;
exports.UserApiFp = UserApiFp;
exports.UsersApi = UsersApi;
exports.UsersApiAxiosParamCreator = UsersApiAxiosParamCreator;
exports.UsersApiFactory = UsersApiFactory;
exports.UsersApiFp = UsersApiFp;
exports.VersionApi = VersionApi;
exports.VersionApiAxiosParamCreator = VersionApiAxiosParamCreator;
exports.VersionApiFactory = VersionApiFactory;
exports.VersionApiFp = VersionApiFp;
